import {
  A,
  CONSTANTS,
  Circle,
  ERROR_TYPES,
  G,
  Image as Image2,
  Path,
  Polygon,
  Rect,
  SVG,
  Text,
  addDataToAppointNodes,
  addHtmlStyle,
  addXmlns,
  asyncRun,
  bfsWalk,
  checkIsNodeStyleDataKey,
  checkIsRichText,
  checkNodeListIsEqual,
  checkNodeOuter,
  checkSmmFormatData,
  copyNodeTree,
  copyRenderTree,
  createForeignObjectNode,
  createSmmFormatData,
  createUid,
  createUidForAppointNodes,
  cssContent,
  degToRad,
  focusInput,
  formatDataToArray,
  formatGetNodeGeneralization,
  generateColorByContent,
  getDataFromClipboard,
  getNodeDataIndex,
  getNodeIndexInNodeList,
  getNodeTreeBoundingRect,
  getObjectChangedProps,
  getStrWithBrFromHtml,
  getTextFromHtml,
  getTopAncestorsFomNodeList,
  handleGetSvgDataExtraContent,
  handleInputPasteText,
  htmlEscape,
  initRootNodePositionMap,
  isSameObject,
  isUndef,
  layoutValueList,
  loadImage,
  measureText,
  mergerIconList,
  nextTick,
  parseAddGeneralizationNodeList,
  removeFromParentNodeData,
  removeHtmlStyle,
  removeRichTextStyes,
  resizeImgSize,
  selectAllInput,
  setDataToClipboard,
  simpleDeepClone,
  sortNodeList,
  throttle,
  transformTreeDataToObject,
  walk
} from "./chunk-GONZX4TM.js";
import {
  require_eventemitter3
} from "./chunk-RP5LA7RX.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/simple-mind-map/src/core/view/View.js
var View = class {
  //  构造函数
  constructor(opt = {}) {
    this.opt = opt;
    this.mindMap = this.opt.mindMap;
    this.scale = 1;
    this.sx = 0;
    this.sy = 0;
    this.x = 0;
    this.y = 0;
    this.firstDrag = true;
    this.setTransformData(this.mindMap.opt.viewData);
    this.bind();
  }
  //  绑定
  bind() {
    this.mindMap.keyCommand.addShortcut("Control+=", () => {
      this.enlarge();
    });
    this.mindMap.keyCommand.addShortcut("Control+-", () => {
      this.narrow();
    });
    this.mindMap.keyCommand.addShortcut("Control+i", () => {
      this.fit();
    });
    this.mindMap.event.on("mousedown", (e) => {
      if (this.mindMap.opt.isDisableDrag) return;
      e.preventDefault();
      this.sx = this.x;
      this.sy = this.y;
    });
    this.mindMap.event.on("drag", (e, event) => {
      if (e.ctrlKey || e.metaKey || this.mindMap.opt.isDisableDrag) {
        return;
      }
      if (this.firstDrag) {
        this.firstDrag = false;
        if (this.mindMap.renderer.activeNodeList.length > 0) {
          this.mindMap.execCommand("CLEAR_ACTIVE_NODE");
        }
      }
      this.x = this.sx + event.mousemoveOffset.x;
      this.y = this.sy + event.mousemoveOffset.y;
      this.transform();
    });
    this.mindMap.event.on("mouseup", () => {
      this.firstDrag = true;
    });
    this.mindMap.event.on("mousewheel", (e, dirs, event, isTouchPad) => {
      const {
        customHandleMousewheel,
        mousewheelAction,
        mouseScaleCenterUseMousePosition,
        mousewheelMoveStep,
        mousewheelZoomActionReverse,
        disableMouseWheelZoom
      } = this.mindMap.opt;
      if (customHandleMousewheel && typeof customHandleMousewheel === "function") {
        return customHandleMousewheel(e);
      }
      if (mousewheelAction === CONSTANTS.MOUSE_WHEEL_ACTION.ZOOM || e.ctrlKey || e.metaKey) {
        if (disableMouseWheelZoom) return;
        const { x: clientX, y: clientY } = this.mindMap.toPos(
          e.clientX,
          e.clientY
        );
        const cx = mouseScaleCenterUseMousePosition ? clientX : void 0;
        const cy = mouseScaleCenterUseMousePosition ? clientY : void 0;
        if (isTouchPad && (dirs.includes(CONSTANTS.DIR.LEFT) || dirs.includes(CONSTANTS.DIR.RIGHT))) {
          dirs = dirs.filter((dir) => {
            return ![CONSTANTS.DIR.LEFT, CONSTANTS.DIR.RIGHT].includes(dir);
          });
        }
        switch (true) {
          case dirs.includes(CONSTANTS.DIR.UP || CONSTANTS.DIR.LEFT):
            mousewheelZoomActionReverse ? this.enlarge(cx, cy, isTouchPad) : this.narrow(cx, cy, isTouchPad);
            break;
          case dirs.includes(CONSTANTS.DIR.DOWN || CONSTANTS.DIR.RIGHT):
            mousewheelZoomActionReverse ? this.narrow(cx, cy, isTouchPad) : this.enlarge(cx, cy, isTouchPad);
            break;
        }
      } else {
        const step = isTouchPad ? 10 : mousewheelMoveStep;
        let mx = 0;
        let my = 0;
        if (dirs.includes(CONSTANTS.DIR.DOWN)) {
          my = -step;
        }
        if (dirs.includes(CONSTANTS.DIR.UP)) {
          my = step;
        }
        if (dirs.includes(CONSTANTS.DIR.LEFT)) {
          mx = step;
        }
        if (dirs.includes(CONSTANTS.DIR.RIGHT)) {
          mx = -step;
        }
        this.translateXY(mx, my);
      }
    });
    this.mindMap.on("resize", () => {
      if (!this.checkNeedMindMapInCanvas()) return;
      this.transform();
    });
  }
  //  获取当前变换状态数据
  getTransformData() {
    return {
      transform: this.mindMap.draw.transform(),
      state: {
        scale: this.scale,
        x: this.x,
        y: this.y,
        sx: this.sx,
        sy: this.sy
      }
    };
  }
  //  动态设置变换状态数据
  setTransformData(viewData) {
    if (viewData) {
      Object.keys(viewData.state).forEach((prop) => {
        this[prop] = viewData.state[prop];
      });
      this.mindMap.draw.transform({
        ...viewData.transform
      });
      this.mindMap.emit("view_data_change", this.getTransformData());
      this.emitEvent("scale");
      this.emitEvent("translate");
    }
  }
  //  平移x,y方向
  translateXY(x, y) {
    if (x === 0 && y === 0) return;
    this.x += x;
    this.y += y;
    this.transform();
    this.emitEvent("translate");
  }
  //  平移x方向
  translateX(step) {
    if (step === 0) return;
    this.x += step;
    this.transform();
    this.emitEvent("translate");
  }
  //  平移x方式到
  translateXTo(x) {
    this.x = x;
    this.transform();
    this.emitEvent("translate");
  }
  //  平移y方向
  translateY(step) {
    if (step === 0) return;
    this.y += step;
    this.transform();
    this.emitEvent("translate");
  }
  //  平移y方向到
  translateYTo(y) {
    this.y = y;
    this.transform();
    this.emitEvent("translate");
  }
  //   应用变换
  transform() {
    try {
      this.limitMindMapInCanvas();
    } catch (error) {
    }
    this.mindMap.draw.transform({
      origin: [0, 0],
      scale: this.scale,
      translate: [this.x, this.y]
    });
    this.mindMap.emit("view_data_change", this.getTransformData());
  }
  //  恢复
  reset() {
    const scaleChange = this.scale !== 1;
    const translateChange = this.x !== 0 || this.y !== 0;
    this.scale = 1;
    this.x = 0;
    this.y = 0;
    this.transform();
    if (scaleChange) {
      this.emitEvent("scale");
    }
    if (translateChange) {
      this.emitEvent("translate");
    }
  }
  //  缩小
  narrow(cx, cy, isTouchPad) {
    const scaleRatio = this.mindMap.opt.scaleRatio / (isTouchPad ? 5 : 1);
    const scale = Math.max(this.scale - scaleRatio, 0.1);
    this.scaleInCenter(scale, cx, cy);
    this.transform();
    this.emitEvent("scale");
  }
  //  放大
  enlarge(cx, cy, isTouchPad) {
    const scaleRatio = this.mindMap.opt.scaleRatio / (isTouchPad ? 5 : 1);
    const scale = this.scale + scaleRatio;
    this.scaleInCenter(scale, cx, cy);
    this.transform();
    this.emitEvent("scale");
  }
  // 基于指定中心进行缩放，cx，cy 可不指定，此时会使用画布中心点
  scaleInCenter(scale, cx, cy) {
    if (cx === void 0 || cy === void 0) {
      cx = this.mindMap.width / 2;
      cy = this.mindMap.height / 2;
    }
    const prevScale = this.scale;
    const ratio = 1 - scale / prevScale;
    const dx = (cx - this.x) * ratio;
    const dy = (cy - this.y) * ratio;
    this.x += dx;
    this.y += dy;
    this.scale = scale;
  }
  //  设置缩放
  setScale(scale, cx, cy) {
    if (cx !== void 0 && cy !== void 0) {
      this.scaleInCenter(scale, cx, cy);
    } else {
      this.scale = scale;
    }
    this.transform();
    this.emitEvent("scale");
  }
  // 适应画布大小
  fit(getRbox = () => {
  }, enlarge = false, fitPadding) {
    fitPadding = fitPadding === void 0 ? this.mindMap.opt.fitPadding : fitPadding;
    const draw = this.mindMap.draw;
    const origTransform = draw.transform();
    const rect = getRbox() || draw.rbox();
    const drawWidth = rect.width / origTransform.scaleX;
    const drawHeight = rect.height / origTransform.scaleY;
    const drawRatio = drawWidth / drawHeight;
    let { width: elWidth, height: elHeight } = this.mindMap.elRect;
    elWidth = elWidth - fitPadding * 2;
    elHeight = elHeight - fitPadding * 2;
    const elRatio = elWidth / elHeight;
    let newScale = 0;
    let flag = "";
    if (drawWidth <= elWidth && drawHeight <= elHeight && !enlarge) {
      newScale = 1;
      flag = 1;
    } else {
      let newWidth = 0;
      let newHeight = 0;
      if (drawRatio > elRatio) {
        newWidth = elWidth;
        newHeight = elWidth / drawRatio;
        flag = 2;
      } else {
        newHeight = elHeight;
        newWidth = elHeight * drawRatio;
        flag = 3;
      }
      newScale = newWidth / drawWidth;
    }
    this.setScale(newScale);
    const newRect = getRbox() || draw.rbox();
    newRect.x -= this.mindMap.elRect.left;
    newRect.y -= this.mindMap.elRect.top;
    let newX = 0;
    let newY = 0;
    if (flag === 1) {
      newX = -newRect.x + fitPadding + (elWidth - newRect.width) / 2;
      newY = -newRect.y + fitPadding + (elHeight - newRect.height) / 2;
    } else if (flag === 2) {
      newX = -newRect.x + fitPadding;
      newY = -newRect.y + fitPadding + (elHeight - newRect.height) / 2;
    } else if (flag === 3) {
      newX = -newRect.x + fitPadding + (elWidth - newRect.width) / 2;
      newY = -newRect.y + fitPadding;
    }
    this.translateXY(newX, newY);
  }
  // 判断是否需要将思维导图限制在画布内
  checkNeedMindMapInCanvas() {
    const { isLimitMindMapInCanvasWhenHasScrollbar, isLimitMindMapInCanvas } = this.mindMap.opt;
    if (this.mindMap.scrollbar) {
      return isLimitMindMapInCanvasWhenHasScrollbar;
    } else {
      return isLimitMindMapInCanvas;
    }
  }
  // 将思维导图限制在画布内
  limitMindMapInCanvas() {
    if (!this.checkNeedMindMapInCanvas()) return;
    let { scale, left, top, right, bottom } = this.getPositionLimit();
    const centerXChange = (this.mindMap.width - this.mindMap.initWidth) / 2 * scale;
    const centerYChange = (this.mindMap.height - this.mindMap.initHeight) / 2 * scale;
    const scaleRatio = this.scale / scale;
    left *= scaleRatio;
    right *= scaleRatio;
    top *= scaleRatio;
    bottom *= scaleRatio;
    const centerX = this.mindMap.width / 2;
    const centerY = this.mindMap.height / 2;
    const scaleOffset = this.scale - 1;
    left -= scaleOffset * centerX - centerXChange;
    right -= scaleOffset * centerX - centerXChange;
    top -= scaleOffset * centerY - centerYChange;
    bottom -= scaleOffset * centerY - centerYChange;
    if (this.x > left) {
      this.x = left;
    }
    if (this.x < right) {
      this.x = right;
    }
    if (this.y > top) {
      this.y = top;
    }
    if (this.y < bottom) {
      this.y = bottom;
    }
  }
  // 计算图形四个方向的位置边界值
  getPositionLimit() {
    const { scaleX, scaleY } = this.mindMap.draw.transform();
    const drawRect = this.mindMap.draw.rbox();
    const rootRect = this.mindMap.renderer.root.group.rbox();
    const rootCenterOffset = this.mindMap.renderer.layout.getRootCenterOffset(
      rootRect.width,
      rootRect.height
    );
    const left = rootRect.x - drawRect.x - rootCenterOffset.x * scaleX;
    const right = rootRect.x - drawRect.x2 - rootCenterOffset.x * scaleX;
    const top = rootRect.y - drawRect.y - rootCenterOffset.y * scaleY;
    const bottom = rootRect.y - drawRect.y2 - rootCenterOffset.y * scaleY;
    return {
      scale: scaleX,
      left,
      right,
      top,
      bottom
    };
  }
  // 派发事件
  emitEvent(type) {
    switch (type) {
      case "scale":
        this.mindMap.emit("scale", this.scale);
      case "translate":
        this.mindMap.emit("translate", this.x, this.y);
    }
  }
};
var View_default = View;

// node_modules/simple-mind-map/src/core/event/Event.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var Event = class extends import_eventemitter3.default {
  //  构造函数
  constructor(opt = {}) {
    super();
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.isLeftMousedown = false;
    this.isRightMousedown = false;
    this.isMiddleMousedown = false;
    this.mousedownPos = {
      x: 0,
      y: 0
    };
    this.mousemovePos = {
      x: 0,
      y: 0
    };
    this.mousemoveOffset = {
      x: 0,
      y: 0
    };
    this.bindFn();
    this.bind();
  }
  //  绑定函数上下文
  bindFn() {
    this.onBodyMousedown = this.onBodyMousedown.bind(this);
    this.onBodyClick = this.onBodyClick.bind(this);
    this.onDrawClick = this.onDrawClick.bind(this);
    this.onMousedown = this.onMousedown.bind(this);
    this.onMousemove = this.onMousemove.bind(this);
    this.onMouseup = this.onMouseup.bind(this);
    this.onNodeMouseup = this.onNodeMouseup.bind(this);
    this.onMousewheel = this.onMousewheel.bind(this);
    this.onContextmenu = this.onContextmenu.bind(this);
    this.onSvgMousedown = this.onSvgMousedown.bind(this);
    this.onKeyup = this.onKeyup.bind(this);
    this.onMouseenter = this.onMouseenter.bind(this);
    this.onMouseleave = this.onMouseleave.bind(this);
  }
  //  绑定事件
  bind() {
    document.body.addEventListener("mousedown", this.onBodyMousedown);
    document.body.addEventListener("click", this.onBodyClick);
    this.mindMap.svg.on("click", this.onDrawClick);
    this.mindMap.el.addEventListener("mousedown", this.onMousedown);
    this.mindMap.svg.on("mousedown", this.onSvgMousedown);
    window.addEventListener("mousemove", this.onMousemove);
    window.addEventListener("mouseup", this.onMouseup);
    this.on("node_mouseup", this.onNodeMouseup);
    this.mindMap.el.addEventListener("wheel", this.onMousewheel);
    this.mindMap.svg.on("contextmenu", this.onContextmenu);
    this.mindMap.svg.on("mouseenter", this.onMouseenter);
    this.mindMap.svg.on("mouseleave", this.onMouseleave);
    window.addEventListener("keyup", this.onKeyup);
  }
  //  解绑事件
  unbind() {
    document.body.removeEventListener("mousedown", this.onBodyMousedown);
    document.body.removeEventListener("click", this.onBodyClick);
    this.mindMap.svg.off("click", this.onDrawClick);
    this.mindMap.el.removeEventListener("mousedown", this.onMousedown);
    window.removeEventListener("mousemove", this.onMousemove);
    window.removeEventListener("mouseup", this.onMouseup);
    this.off("node_mouseup", this.onNodeMouseup);
    this.mindMap.el.removeEventListener("wheel", this.onMousewheel);
    this.mindMap.svg.off("contextmenu", this.onContextmenu);
    this.mindMap.svg.off("mouseenter", this.onMouseenter);
    this.mindMap.svg.off("mouseleave", this.onMouseleave);
    window.removeEventListener("keyup", this.onKeyup);
  }
  //   画布的单击事件
  onDrawClick(e) {
    this.emit("draw_click", e);
  }
  // 页面的鼠标按下事件
  onBodyMousedown(e) {
    this.emit("body_mousedown", e);
  }
  // 页面的单击事件
  onBodyClick(e) {
    this.emit("body_click", e);
  }
  //   svg画布的鼠标按下事件
  onSvgMousedown(e) {
    this.emit("svg_mousedown", e);
  }
  //  鼠标按下事件
  onMousedown(e) {
    if (e.which === 1) {
      this.isLeftMousedown = true;
    } else if (e.which === 3) {
      this.isRightMousedown = true;
    } else if (e.which === 2) {
      this.isMiddleMousedown = true;
    }
    this.mousedownPos.x = e.clientX;
    this.mousedownPos.y = e.clientY;
    this.emit("mousedown", e, this);
  }
  //  鼠标移动事件
  onMousemove(e) {
    let { useLeftKeySelectionRightKeyDrag } = this.mindMap.opt;
    this.mousemovePos.x = e.clientX;
    this.mousemovePos.y = e.clientY;
    this.mousemoveOffset.x = e.clientX - this.mousedownPos.x;
    this.mousemoveOffset.y = e.clientY - this.mousedownPos.y;
    this.emit("mousemove", e, this);
    if (this.isMiddleMousedown || (useLeftKeySelectionRightKeyDrag ? this.isRightMousedown : this.isLeftMousedown)) {
      e.preventDefault();
      this.emit("drag", e, this);
    }
  }
  //  鼠标松开事件
  onMouseup(e) {
    this.onNodeMouseup();
    this.emit("mouseup", e, this);
  }
  // 节点鼠标松开事件
  onNodeMouseup() {
    this.isLeftMousedown = false;
    this.isRightMousedown = false;
    this.isMiddleMousedown = false;
  }
  //  鼠标滚动/触控板滑动
  onMousewheel(e) {
    e.stopPropagation();
    e.preventDefault();
    const dirs = [];
    if (e.deltaY < 0) dirs.push(CONSTANTS.DIR.UP);
    if (e.deltaY > 0) dirs.push(CONSTANTS.DIR.DOWN);
    if (e.deltaX < 0) dirs.push(CONSTANTS.DIR.LEFT);
    if (e.deltaX > 0) dirs.push(CONSTANTS.DIR.RIGHT);
    let isTouchPad = false;
    if (e.wheelDeltaY === e.deltaY * -3 || Math.abs(e.wheelDeltaY) <= 10) {
      isTouchPad = true;
    }
    this.emit("mousewheel", e, dirs, this, isTouchPad);
  }
  //  鼠标右键菜单事件
  onContextmenu(e) {
    e.preventDefault();
    if (e.ctrlKey) return;
    this.emit("contextmenu", e);
  }
  //  按键松开事件
  onKeyup(e) {
    this.emit("keyup", e);
  }
  // 进入
  onMouseenter(e) {
    this.emit("svg_mouseenter", e);
  }
  // 离开
  onMouseleave(e) {
    this.emit("svg_mouseleave", e);
  }
};
var Event_default = Event;

// node_modules/deepmerge/dist/es.js
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneIfNecessary(value, optionsArgument) {
  var clone = optionsArgument && optionsArgument.clone === true;
  return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
}
function defaultArrayMerge(target, source, optionsArgument) {
  var destination = target.slice();
  source.forEach(function(e, i) {
    if (typeof destination[i] === "undefined") {
      destination[i] = cloneIfNecessary(e, optionsArgument);
    } else if (isMergeableObject(e)) {
      destination[i] = deepmerge(target[i], e, optionsArgument);
    } else if (target.indexOf(e) === -1) {
      destination.push(cloneIfNecessary(e, optionsArgument));
    }
  });
  return destination;
}
function mergeObject(target, source, optionsArgument) {
  var destination = {};
  if (isMergeableObject(target)) {
    Object.keys(target).forEach(function(key) {
      destination[key] = cloneIfNecessary(target[key], optionsArgument);
    });
  }
  Object.keys(source).forEach(function(key) {
    if (!isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneIfNecessary(source[key], optionsArgument);
    } else {
      destination[key] = deepmerge(target[key], source[key], optionsArgument);
    }
  });
  return destination;
}
function deepmerge(target, source, optionsArgument) {
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var options = optionsArgument || { arrayMerge: defaultArrayMerge };
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneIfNecessary(source, optionsArgument);
  } else if (sourceIsArray) {
    var arrayMerge = options.arrayMerge || defaultArrayMerge;
    return arrayMerge(target, source, optionsArgument);
  } else {
    return mergeObject(target, source, optionsArgument);
  }
}
deepmerge.all = function deepmergeAll(array, optionsArgument) {
  if (!Array.isArray(array) || array.length < 2) {
    throw new Error("first argument should be an array with at least two elements");
  }
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, optionsArgument);
  });
};
var deepmerge_1 = deepmerge;
var es_default = deepmerge_1;

// node_modules/simple-mind-map/src/core/render/node/Style.js
var rootProp = ["paddingX", "paddingY"];
var backgroundStyleProps = [
  "backgroundColor",
  "backgroundImage",
  "backgroundRepeat",
  "backgroundPosition",
  "backgroundSize"
];
var Style = class _Style {
  //   设置背景样式
  static setBackgroundStyle(el, themeConfig) {
    if (!_Style.cacheStyle) {
      _Style.cacheStyle = {};
      let style = window.getComputedStyle(el);
      backgroundStyleProps.forEach((prop) => {
        _Style.cacheStyle[prop] = style[prop];
      });
    }
    let {
      backgroundColor,
      backgroundImage,
      backgroundRepeat,
      backgroundPosition,
      backgroundSize
    } = themeConfig;
    el.style.backgroundColor = backgroundColor;
    if (backgroundImage && backgroundImage !== "none") {
      el.style.backgroundImage = `url(${backgroundImage})`;
      el.style.backgroundRepeat = backgroundRepeat;
      el.style.backgroundPosition = backgroundPosition;
      el.style.backgroundSize = backgroundSize;
    } else {
      el.style.backgroundImage = "none";
    }
  }
  // 移除背景样式
  static removeBackgroundStyle(el) {
    if (!_Style.cacheStyle) return;
    backgroundStyleProps.forEach((prop) => {
      el.style[prop] = _Style.cacheStyle[prop];
    });
    _Style.cacheStyle = null;
  }
  //  构造函数
  constructor(ctx) {
    this.ctx = ctx;
    this._markerPath = null;
    this._marker = null;
    this._gradient = null;
  }
  //  合并样式
  merge(prop, root) {
    let themeConfig = this.ctx.mindMap.themeConfig;
    let defaultConfig = themeConfig.node;
    if (root || rootProp.includes(prop)) {
      defaultConfig = themeConfig;
    } else if (this.ctx.isGeneralization) {
      defaultConfig = themeConfig.generalization;
    } else if (this.ctx.layerIndex === 0) {
      defaultConfig = themeConfig.root;
    } else if (this.ctx.layerIndex === 1) {
      defaultConfig = themeConfig.second;
    }
    return this.getSelfStyle(prop) !== void 0 ? this.getSelfStyle(prop) : defaultConfig[prop];
  }
  //  获取某个样式值
  getStyle(prop, root) {
    return this.merge(prop, root);
  }
  //  获取自身自定义样式
  getSelfStyle(prop) {
    return this.ctx.getData(prop);
  }
  //  矩形
  rect(node) {
    this.shape(node);
    node.radius(this.merge("borderRadius"));
  }
  // 形状
  shape(node) {
    if (this.merge("gradientStyle")) {
      if (!this._gradient) {
        this._gradient = this.ctx.nodeDraw.gradient("linear");
      }
      this._gradient.update((add) => {
        add.stop(0, this.merge("startColor"));
        add.stop(1, this.merge("endColor"));
      });
      node.fill(this._gradient);
    } else {
      node.fill({
        color: this.merge("fillColor")
      });
    }
    node.stroke({
      color: this.merge("borderColor"),
      width: this.merge("borderWidth"),
      dasharray: this.merge("borderDasharray")
    });
  }
  //  文字
  text(node) {
    node.fill({
      color: this.merge("color")
    }).css({
      "font-family": this.merge("fontFamily"),
      "font-size": this.merge("fontSize"),
      "font-weight": this.merge("fontWeight"),
      "font-style": this.merge("fontStyle"),
      "text-decoration": this.merge("textDecoration")
    });
  }
  // 生成内联样式
  createStyleText() {
    return `
      color: ${this.merge("color")};
      font-family: ${this.merge("fontFamily")};
      font-size: ${this.merge("fontSize") + "px"};
      font-weight: ${this.merge("fontWeight")};
      font-style: ${this.merge("fontStyle")};
      text-decoration: ${this.merge("textDecoration")}
    `;
  }
  // 获取文本样式
  getTextFontStyle() {
    return {
      italic: this.merge("fontStyle") === "italic",
      bold: this.merge("fontWeight"),
      fontSize: this.merge("fontSize"),
      fontFamily: this.merge("fontFamily")
    };
  }
  //  html文字节点
  domText(node, fontSizeScale = 1, isMultiLine) {
    node.style.fontFamily = this.merge("fontFamily");
    node.style.fontSize = this.merge("fontSize") * fontSizeScale + "px";
    node.style.fontWeight = this.merge("fontWeight") || "normal";
    node.style.lineHeight = !isMultiLine ? "normal" : this.merge("lineHeight");
    node.style.fontStyle = this.merge("fontStyle");
  }
  //  标签文字
  tagText(node, style) {
    node.fill({
      color: "#fff"
    }).css({
      "font-size": style.fontSize + "px"
    });
  }
  //  标签矩形
  tagRect(node, style) {
    node.fill({
      color: style.fill
    });
    if (style.radius) {
      node.radius(style.radius);
    }
  }
  //  内置图标
  iconNode(node) {
    node.attr({
      fill: this.merge("color")
    });
  }
  //  连线
  line(line, { width, color, dasharray } = {}, enableMarker, childNode) {
    line.stroke({ color, dasharray, width }).fill({ color: "none" });
    if (enableMarker) {
      const showMarker = this.merge("showLineMarker", true);
      const childNodeStyle = childNode.style;
      if (showMarker) {
        childNodeStyle._marker = childNodeStyle._marker || childNodeStyle.createMarker();
        childNodeStyle._markerPath.stroke({ color }).fill({ color });
        line.attr("marker-start", "");
        line.attr("marker-end", "");
        const dir = childNodeStyle.merge("lineMarkerDir");
        line.marker(dir, childNodeStyle._marker);
      } else if (childNodeStyle._marker) {
        line.attr("marker-start", "");
        line.attr("marker-end", "");
        childNodeStyle._marker.remove();
        childNodeStyle._marker = null;
      }
    }
  }
  // 创建箭头
  createMarker() {
    return this.ctx.lineDraw.marker(20, 20, (add) => {
      add.ref(8, 5);
      add.size(20, 20);
      add.attr("markerUnits", "userSpaceOnUse");
      add.attr("orient", "auto-start-reverse");
      this._markerPath = add.path("M0,0 L2,5 L0,10 L10,5 Z");
    });
  }
  //  概要连线
  generalizationLine(node) {
    node.stroke({
      width: this.merge("generalizationLineWidth", true),
      color: this.merge("generalizationLineColor", true)
    }).fill({ color: "none" });
  }
  //  展开收起按钮
  iconBtn(node, node2, fillNode) {
    let { color, fill, fontSize, fontColor } = this.ctx.mindMap.opt.expandBtnStyle || {
      color: "#808080",
      fill: "#fff",
      fontSize: 12,
      strokeColor: "#333333",
      fontColor: "#333333"
    };
    node.fill({ color });
    node2.fill({ color });
    fillNode.fill({ color: fill });
    if (this.ctx.mindMap.opt.isShowExpandNum) {
      node.attr({ "font-size": fontSize, "font-color": fontColor });
    }
  }
  // 是否设置了自定义的样式
  hasCustomStyle() {
    let res = false;
    Object.keys(this.ctx.getData()).forEach((item) => {
      if (checkIsNodeStyleDataKey(item)) {
        res = true;
      }
    });
    return res;
  }
  // hover和激活节点
  hoverNode(node) {
    const { hoverRectColor } = this.ctx.mindMap.opt;
    node.radius(5).fill("none").stroke({
      color: hoverRectColor
    });
  }
  // 所属节点被删除时的操作
  onRemove() {
    if (this._marker) {
      this._marker.remove();
      this._marker = null;
    }
    if (this._markerPath) {
      this._markerPath.remove();
      this._markerPath = null;
    }
    if (this._gradient) {
      this._gradient.remove();
      this._gradient = null;
    }
  }
};
Style.cacheStyle = null;
var Style_default = Style;

// node_modules/simple-mind-map/src/core/render/node/Shape.js
var Shape = class {
  constructor(node) {
    this.node = node;
    this.mindMap = node.mindMap;
  }
  //  形状需要的padding
  getShapePadding(width, height, paddingX, paddingY) {
    const shape = this.node.getShape();
    const defaultPaddingX = 15;
    const defaultPaddingY = 5;
    const actWidth = width + paddingX * 2;
    const actHeight = height + paddingY * 2;
    const actOffset = Math.abs(actWidth - actHeight);
    switch (shape) {
      case CONSTANTS.SHAPE.ROUNDED_RECTANGLE:
        return {
          paddingX: height > width ? (height - width) / 2 : 0,
          paddingY: 0
        };
      case CONSTANTS.SHAPE.DIAMOND:
        return {
          paddingX: width / 2,
          paddingY: height / 2
        };
      case CONSTANTS.SHAPE.PARALLELOGRAM:
        return {
          paddingX: paddingX <= 0 ? defaultPaddingX : 0,
          paddingY: 0
        };
      case CONSTANTS.SHAPE.OUTER_TRIANGULAR_RECTANGLE:
        return {
          paddingX: paddingX <= 0 ? defaultPaddingX : 0,
          paddingY: 0
        };
      case CONSTANTS.SHAPE.INNER_TRIANGULAR_RECTANGLE:
        return {
          paddingX: paddingX <= 0 ? defaultPaddingX : 0,
          paddingY: 0
        };
      case CONSTANTS.SHAPE.ELLIPSE:
        return {
          paddingX: paddingX <= 0 ? defaultPaddingX : 0,
          paddingY: paddingY <= 0 ? defaultPaddingY : 0
        };
      case CONSTANTS.SHAPE.CIRCLE:
        return {
          paddingX: actHeight > actWidth ? actOffset / 2 : 0,
          paddingY: actHeight < actWidth ? actOffset / 2 : 0
        };
      default:
        return {
          paddingX: 0,
          paddingY: 0
        };
    }
  }
  //  创建形状节点
  createShape() {
    const shape = this.node.getShape();
    let node = null;
    if (shape === CONSTANTS.SHAPE.RECTANGLE) {
      node = this.createRect();
    } else if (shape === CONSTANTS.SHAPE.DIAMOND) {
      node = this.createDiamond();
    } else if (shape === CONSTANTS.SHAPE.PARALLELOGRAM) {
      node = this.createParallelogram();
    } else if (shape === CONSTANTS.SHAPE.ROUNDED_RECTANGLE) {
      node = this.createRoundedRectangle();
    } else if (shape === CONSTANTS.SHAPE.OCTAGONAL_RECTANGLE) {
      node = this.createOctagonalRectangle();
    } else if (shape === CONSTANTS.SHAPE.OUTER_TRIANGULAR_RECTANGLE) {
      node = this.createOuterTriangularRectangle();
    } else if (shape === CONSTANTS.SHAPE.INNER_TRIANGULAR_RECTANGLE) {
      node = this.createInnerTriangularRectangle();
    } else if (shape === CONSTANTS.SHAPE.ELLIPSE) {
      node = this.createEllipse();
    } else if (shape === CONSTANTS.SHAPE.CIRCLE) {
      node = this.createCircle();
    }
    return node;
  }
  // 获取节点减去节点边框宽度、hover节点边框宽度后的尺寸
  getNodeSize() {
    const borderWidth = this.node.getBorderWidth();
    let { width, height } = this.node;
    width -= borderWidth;
    height -= borderWidth;
    return {
      width,
      height
    };
  }
  // 创建路径节点
  createPath(pathStr) {
    const { customCreateNodePath } = this.mindMap.opt;
    if (customCreateNodePath) {
      return SVG(customCreateNodePath(pathStr));
    }
    return new Path().plot(pathStr);
  }
  // 创建多边形节点
  createPolygon(points) {
    const { customCreateNodePolygon } = this.mindMap.opt;
    if (customCreateNodePolygon) {
      return SVG(customCreateNodePolygon(points));
    }
    return new Polygon().plot(points);
  }
  // 创建矩形
  createRect() {
    let { width, height } = this.getNodeSize();
    let borderRadius = this.node.style.merge("borderRadius");
    const pathStr = `
      M${borderRadius},0
      L${width - borderRadius},0
      C${width - borderRadius},0 ${width},${0} ${width},${borderRadius}
      L${width},${height - borderRadius}
      C${width},${height - borderRadius} ${width},${height} ${width - borderRadius},${height}
      L${borderRadius},${height}
      C${borderRadius},${height} ${0},${height} ${0},${height - borderRadius}
      L${0},${borderRadius}
      C${0},${borderRadius} ${0},${0} ${borderRadius},${0}
      Z
    `;
    return this.createPath(pathStr);
  }
  //  创建菱形
  createDiamond() {
    let { width, height } = this.getNodeSize();
    let halfWidth = width / 2;
    let halfHeight = height / 2;
    let topX = halfWidth;
    let topY = 0;
    let rightX = width;
    let rightY = halfHeight;
    let bottomX = halfWidth;
    let bottomY = height;
    let leftX = 0;
    let leftY = halfHeight;
    const points = [
      [topX, topY],
      [rightX, rightY],
      [bottomX, bottomY],
      [leftX, leftY]
    ];
    return this.createPolygon(points);
  }
  //  创建平行四边形
  createParallelogram() {
    let { paddingX } = this.node.getPaddingVale();
    paddingX = paddingX || this.node.shapePadding.paddingX;
    let { width, height } = this.getNodeSize();
    const points = [
      [paddingX, 0],
      [width, 0],
      [width - paddingX, height],
      [0, height]
    ];
    return this.createPolygon(points);
  }
  //  创建圆角矩形
  createRoundedRectangle() {
    let { width, height } = this.getNodeSize();
    let halfHeight = height / 2;
    const pathStr = `
      M${halfHeight},0
      L${width - halfHeight},0
      A${height / 2},${height / 2} 0 0,1 ${width - halfHeight},${height} 
      L${halfHeight},${height}
      A${height / 2},${height / 2} 0 0,1 ${halfHeight},${0}
    `;
    return this.createPath(pathStr);
  }
  //  创建八角矩形
  createOctagonalRectangle() {
    let w = 5;
    let { width, height } = this.getNodeSize();
    const points = [
      [0, w],
      [w, 0],
      [width - w, 0],
      [width, w],
      [width, height - w],
      [width - w, height],
      [w, height],
      [0, height - w]
    ];
    return this.createPolygon(points);
  }
  //  创建外三角矩形
  createOuterTriangularRectangle() {
    let { paddingX } = this.node.getPaddingVale();
    paddingX = paddingX || this.node.shapePadding.paddingX;
    let { width, height } = this.getNodeSize();
    const points = [
      [paddingX, 0],
      [width - paddingX, 0],
      [width, height / 2],
      [width - paddingX, height],
      [paddingX, height],
      [0, height / 2]
    ];
    return this.createPolygon(points);
  }
  //  创建内三角矩形
  createInnerTriangularRectangle() {
    let { paddingX } = this.node.getPaddingVale();
    paddingX = paddingX || this.node.shapePadding.paddingX;
    let { width, height } = this.getNodeSize();
    const points = [
      [0, 0],
      [width, 0],
      [width - paddingX / 2, height / 2],
      [width, height],
      [0, height],
      [paddingX / 2, height / 2]
    ];
    return this.createPolygon(points);
  }
  //  创建椭圆
  createEllipse() {
    let { width, height } = this.getNodeSize();
    let halfWidth = width / 2;
    let halfHeight = height / 2;
    const pathStr = `
      M${halfWidth},0
      A${halfWidth},${halfHeight} 0 0,1 ${halfWidth},${height} 
      M${halfWidth},${height} 
      A${halfWidth},${halfHeight} 0 0,1 ${halfWidth},${0} 
    `;
    return this.createPath(pathStr);
  }
  //  创建圆
  createCircle() {
    let { width, height } = this.getNodeSize();
    let halfWidth = width / 2;
    let halfHeight = height / 2;
    const pathStr = `
      M${halfWidth},0
      A${halfWidth},${halfHeight} 0 0,1 ${halfWidth},${height} 
      M${halfWidth},${height} 
      A${halfWidth},${halfHeight} 0 0,1 ${halfWidth},${0} 
    `;
    return this.createPath(pathStr);
  }
};
var shapeList = [
  CONSTANTS.SHAPE.RECTANGLE,
  CONSTANTS.SHAPE.DIAMOND,
  CONSTANTS.SHAPE.PARALLELOGRAM,
  CONSTANTS.SHAPE.ROUNDED_RECTANGLE,
  CONSTANTS.SHAPE.OCTAGONAL_RECTANGLE,
  CONSTANTS.SHAPE.OUTER_TRIANGULAR_RECTANGLE,
  CONSTANTS.SHAPE.INNER_TRIANGULAR_RECTANGLE,
  CONSTANTS.SHAPE.ELLIPSE,
  CONSTANTS.SHAPE.CIRCLE
];

// node_modules/simple-mind-map/src/core/render/node/nodeGeneralization.js
function formatGetGeneralization() {
  const data = this.getData("generalization");
  return Array.isArray(data) ? data : data ? [data] : [];
}
function checkHasGeneralization() {
  return this.formatGetGeneralization().length > 0;
}
function checkHasSelfGeneralization() {
  const list = this.formatGetGeneralization();
  return !!list.find((item) => {
    return !item.range || item.range.length <= 0;
  });
}
function getGeneralizationNodeIndex(node) {
  return this._generalizationList.findIndex((item) => {
    return item.generalizationNode.uid === node.uid;
  });
}
function createGeneralizationNode() {
  if (this.isGeneralization || !this.checkHasGeneralization()) {
    return;
  }
  let maxWidth = 0;
  let maxHeight = 0;
  const list = this.formatGetGeneralization();
  list.forEach((item, index) => {
    let cur = this._generalizationList[index];
    if (!cur) {
      cur = this._generalizationList[index] = {};
    }
    cur.node = this;
    cur.range = item.range;
    if (!cur.generalizationLine) {
      cur.generalizationLine = this.lineDraw.path();
    }
    if (!cur.generalizationNode) {
      cur.generalizationNode = new Node_default({
        data: {
          inserting: item.inserting,
          data: item
        },
        uid: createUid(),
        renderer: this.renderer,
        mindMap: this.mindMap,
        isGeneralization: true
      });
    }
    delete item.inserting;
    cur.generalizationNode.generalizationBelongNode = this;
    if (cur.generalizationNode.width > maxWidth)
      maxWidth = cur.generalizationNode.width;
    if (cur.generalizationNode.height > maxHeight)
      maxHeight = cur.generalizationNode.height;
    if (item.isActive) {
      this.renderer.addNodeToActiveList(cur.generalizationNode);
    }
  });
  this._generalizationNodeWidth = maxWidth;
  this._generalizationNodeHeight = maxHeight;
}
function updateGeneralization() {
  if (this.isGeneralization) return;
  this.removeGeneralization();
  this.createGeneralizationNode();
}
function renderGeneralization(forceRender) {
  if (this.isGeneralization) return;
  this.updateGeneralizationData();
  const list = this.formatGetGeneralization();
  if (list.length <= 0 || this.getData("expand") === false) {
    this.removeGeneralization();
    return;
  }
  if (list.length !== this._generalizationList.length) {
    this.removeGeneralization();
  }
  this.createGeneralizationNode();
  this.renderer.layout.renderGeneralization(this._generalizationList);
  this._generalizationList.forEach((item) => {
    this.style.generalizationLine(item.generalizationLine);
    item.generalizationNode.render(() => {
    }, forceRender);
  });
}
function updateGeneralizationData() {
  const childrenLength = this.nodeData.children.length;
  const list = this.formatGetGeneralization();
  const newList = [];
  list.forEach((item) => {
    if (!item.range) {
      newList.push(item);
      return;
    }
    if (item.range.length > 0 && item.range[0] <= childrenLength - 1 && item.range[1] <= childrenLength - 1) {
      newList.push(item);
    }
  });
  if (newList.length !== list.length) {
    this.setData({
      generalization: newList
    });
  }
}
function removeGeneralization() {
  if (this.isGeneralization) return;
  this._generalizationList.forEach((item) => {
    item.generalizationNode.style.onRemove();
    if (item.generalizationLine) {
      item.generalizationLine.remove();
      item.generalizationLine = null;
    }
    if (item.generalizationNode) {
      this.renderer.removeNodeFromActiveList(item.generalizationNode);
      item.generalizationNode.remove();
      item.generalizationNode = null;
    }
  });
  this._generalizationList = [];
  if (this.generalizationBelongNode) {
    this.nodeDraw.find(".generalization_" + this.generalizationBelongNode.uid).remove();
  }
}
function hideGeneralization() {
  if (this.isGeneralization) return;
  this._generalizationList.forEach((item) => {
    if (item.generalizationLine) item.generalizationLine.hide();
    if (item.generalizationNode) item.generalizationNode.hide();
  });
}
function showGeneralization() {
  if (this.isGeneralization) return;
  this._generalizationList.forEach((item) => {
    if (item.generalizationLine) item.generalizationLine.show();
    if (item.generalizationNode) item.generalizationNode.show();
  });
}
function setGeneralizationOpacity(val) {
  this._generalizationList.forEach((item) => {
    item.generalizationLine.opacity(val);
    item.generalizationNode.group.opacity(val);
  });
}
function handleGeneralizationMouseenter() {
  const belongNode = this.generalizationBelongNode;
  const list = belongNode.formatGetGeneralization();
  const index = belongNode.getGeneralizationNodeIndex(this);
  const generalizationData = list[index];
  if (Array.isArray(generalizationData.range) && generalizationData.range.length > 0) {
    this.mindMap.renderer.highlightNode(belongNode, generalizationData.range);
  } else {
    this.mindMap.renderer.highlightNode(belongNode);
  }
}
function handleGeneralizationMouseleave() {
  this.mindMap.renderer.closeHighlightNode();
}
var nodeGeneralization_default = {
  formatGetGeneralization,
  checkHasGeneralization,
  checkHasSelfGeneralization,
  getGeneralizationNodeIndex,
  createGeneralizationNode,
  updateGeneralization,
  updateGeneralizationData,
  renderGeneralization,
  removeGeneralization,
  hideGeneralization,
  showGeneralization,
  setGeneralizationOpacity,
  handleGeneralizationMouseenter,
  handleGeneralizationMouseleave
};

// node_modules/simple-mind-map/src/svg/btns.js
var open = `<svg t="1618141562310" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13476" width="200" height="200"><path d="M475.136 327.168v147.968h-147.968v74.24h147.968v147.968h74.24v-147.968h147.968v-74.24h-147.968v-147.968h-74.24z m36.864-222.208c225.28 0 407.04 181.76 407.04 407.04s-181.76 407.04-407.04 407.04-407.04-181.76-407.04-407.04 181.76-407.04 407.04-407.04z m0-74.24c-265.216 0-480.768 215.552-480.768 480.768s215.552 480.768 480.768 480.768 480.768-215.552 480.768-480.768-215.552-480.768-480.768-480.768z" p-id="13477"></path></svg>`;
var close = `<svg t="1618141589243" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13611" width="200" height="200"><path d="M512 105.472c225.28 0 407.04 181.76 407.04 407.04s-181.76 407.04-407.04 407.04-407.04-181.76-407.04-407.04 181.76-407.04 407.04-407.04z m0-74.24c-265.216 0-480.768 215.552-480.768 480.768s215.552 480.768 480.768 480.768 480.768-215.552 480.768-480.768-215.552-480.768-480.768-480.768z" p-id="13612"></path><path d="M252.928 474.624h518.144v74.24h-518.144z" p-id="13613"></path></svg>`;
var remove = `<svg width="14px" height="14px" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13611" width="200" height="200"><path fill="#ffffff" d="M512 105.472c225.28 0 407.04 181.76 407.04 407.04s-181.76 407.04-407.04 407.04-407.04-181.76-407.04-407.04 181.76-407.04 407.04-407.04z m0-74.24c-265.216 0-480.768 215.552-480.768 480.768s215.552 480.768 480.768 480.768 480.768-215.552 480.768-480.768-215.552-480.768-480.768-480.768z" p-id="13612"></path><path fill="#ffffff" d="M252.928 474.624h518.144v74.24h-518.144z" p-id="13613"></path></svg>`;
var imgAdjust = `<svg width="12px" height="12px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path fill="#ffffff" d="M1008.128 614.4a25.6 25.6 0 0 0-27.648 5.632l-142.848 142.848L259.072 186.88 401.92 43.52A25.6 25.6 0 0 0 384 0h-358.4a25.6 25.6 0 0 0-25.6 25.6v358.4a25.6 25.6 0 0 0 43.52 17.92l143.36-142.848 578.048 578.048-142.848 142.848a25.6 25.6 0 0 0 17.92 43.52h358.4a25.6 25.6 0 0 0 25.6-25.6v-358.4a25.6 25.6 0 0 0-15.872-25.088z"  /></svg>`;
var btns_default = {
  open,
  close,
  remove,
  imgAdjust
};

// node_modules/simple-mind-map/src/core/render/node/nodeExpandBtn.js
function createExpandNodeContent() {
  if (this._openExpandNode) {
    return;
  }
  let { close: close2, open: open2 } = this.mindMap.opt.expandBtnIcon || {};
  if (this.mindMap.opt.isShowExpandNum) {
    this._openExpandNode = new Text();
    this._openExpandNode.attr({
      "text-anchor": "middle",
      "dominant-baseline": "middle",
      x: this.expandBtnSize / 2,
      y: 2
    });
  } else {
    this._openExpandNode = SVG(open2 || btns_default.open).size(
      this.expandBtnSize,
      this.expandBtnSize
    );
    this._openExpandNode.x(0).y(-this.expandBtnSize / 2);
  }
  this._closeExpandNode = SVG(close2 || btns_default.close).size(
    this.expandBtnSize,
    this.expandBtnSize
  );
  this._closeExpandNode.x(0).y(-this.expandBtnSize / 2);
  this._fillExpandNode = new Circle().size(this.expandBtnSize);
  this._fillExpandNode.x(0).y(-this.expandBtnSize / 2);
  this.style.iconBtn(
    this._openExpandNode,
    this._closeExpandNode,
    this._fillExpandNode
  );
}
function sumNode(data = []) {
  return data.reduce(
    (total, cur) => total + this.sumNode(cur.children || []),
    data.length
  );
}
function updateExpandBtnNode() {
  let { expand } = this.getData();
  if (expand === this._lastExpandBtnType) return;
  if (this._expandBtn) {
    this._expandBtn.clear();
  }
  this.createExpandNodeContent();
  let node;
  if (expand === false) {
    node = this._openExpandNode;
    this._lastExpandBtnType = false;
  } else {
    node = this._closeExpandNode;
    this._lastExpandBtnType = true;
  }
  if (this._expandBtn) {
    let { isShowExpandNum, expandBtnStyle, expandBtnNumHandler } = this.mindMap.opt;
    if (isShowExpandNum) {
      if (!expand) {
        this._fillExpandNode.stroke({
          color: expandBtnStyle.strokeColor
        });
        let count = this.sumNode(this.nodeData.children);
        count = expandBtnNumHandler(count);
        node.text(String(count));
      } else {
        this._fillExpandNode.stroke("none");
      }
    }
    this._expandBtn.add(this._fillExpandNode).add(node);
  }
}
function updateExpandBtnPos() {
  if (!this._expandBtn) {
    return;
  }
  this.renderer.layout.renderExpandBtn(this, this._expandBtn);
}
function renderExpandBtn() {
  if (!this.nodeData.children || this.nodeData.children.length <= 0 || this.isRoot) {
    return;
  }
  if (this._expandBtn) {
    this.group.add(this._expandBtn);
  } else {
    this._expandBtn = new G();
    this._expandBtn.on("mouseover", (e) => {
      e.stopPropagation();
      this._expandBtn.css({
        cursor: "pointer"
      });
    });
    this._expandBtn.on("mouseout", (e) => {
      e.stopPropagation();
      this._expandBtn.css({
        cursor: "auto"
      });
    });
    this._expandBtn.on("click", (e) => {
      e.stopPropagation();
      this.mindMap.execCommand("SET_NODE_EXPAND", this, !this.getData("expand"));
      this.mindMap.emit("expand_btn_click", this);
    });
    this._expandBtn.on("dblclick", (e) => {
      e.stopPropagation();
    });
    this._expandBtn.addClass("smm-expand-btn");
    this.group.add(this._expandBtn);
  }
  this._showExpandBtn = true;
  this.updateExpandBtnNode();
  this.updateExpandBtnPos();
}
function removeExpandBtn() {
  if (this._expandBtn && this._showExpandBtn) {
    this._expandBtn.remove();
    this._showExpandBtn = false;
  }
}
function showExpandBtn() {
  const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
  if (alwaysShowExpandBtn || notShowExpandBtn) return;
  setTimeout(() => {
    this.renderExpandBtn();
  }, 0);
}
function hideExpandBtn() {
  const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
  if (alwaysShowExpandBtn || this._isMouseenter || notShowExpandBtn) return;
  let { isActive, expand } = this.getData();
  if (!isActive && expand) {
    setTimeout(() => {
      this.removeExpandBtn();
    }, 0);
  }
}
var nodeExpandBtn_default = {
  createExpandNodeContent,
  updateExpandBtnNode,
  updateExpandBtnPos,
  renderExpandBtn,
  removeExpandBtn,
  showExpandBtn,
  hideExpandBtn,
  sumNode
};

// node_modules/simple-mind-map/src/core/render/node/nodeCommandWraps.js
function setData(data = {}) {
  this.mindMap.execCommand("SET_NODE_DATA", this, data);
}
function setText(text, richText, resetRichText) {
  this.mindMap.execCommand("SET_NODE_TEXT", this, text, richText, resetRichText);
}
function setImage(imgData) {
  this.mindMap.execCommand("SET_NODE_IMAGE", this, imgData);
}
function setIcon(icons) {
  this.mindMap.execCommand("SET_NODE_ICON", this, icons);
}
function setHyperlink(link, title) {
  this.mindMap.execCommand("SET_NODE_HYPERLINK", this, link, title);
}
function setNote(note2) {
  this.mindMap.execCommand("SET_NODE_NOTE", this, note2);
}
function setAttachment(url, name) {
  this.mindMap.execCommand("SET_NODE_ATTACHMENT", this, url, name);
}
function setTag(tag) {
  this.mindMap.execCommand("SET_NODE_TAG", this, tag);
}
function setShape(shape) {
  this.mindMap.execCommand("SET_NODE_SHAPE", this, shape);
}
function setStyle(prop, value) {
  this.mindMap.execCommand("SET_NODE_STYLE", this, prop, value);
}
function setStyles(style) {
  this.mindMap.execCommand("SET_NODE_STYLES", this, style);
}
var nodeCommandWraps_default = {
  setData,
  setText,
  setImage,
  setIcon,
  setHyperlink,
  setNote,
  setAttachment,
  setTag,
  setShape,
  setStyle,
  setStyles
};

// node_modules/simple-mind-map/src/svg/icons.js
var hyperlink = '<svg t="1624174958075" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7982" ><path d="M435.484444 251.733333v68.892445L295.822222 320.682667a168.504889 168.504889 0 0 0-2.844444 336.952889h142.506666v68.892444H295.822222a237.397333 237.397333 0 0 1 0-474.794667h139.662222z m248.945778 0a237.397333 237.397333 0 0 1 0 474.851556H544.654222v-69.006222l139.776 0.056889a168.504889 168.504889 0 0 0 2.844445-336.952889H544.597333V251.676444h139.776z m-25.827555 203.946667a34.474667 34.474667 0 0 1 0 68.892444H321.649778a34.474667 34.474667 0 0 1 0-68.892444h336.952889z" p-id="7983"></path></svg>';
var note = '<svg t="1624195132675" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8792" ><path d="M152.768 985.984 152.768 49.856l434.56 0 66.816 0 234.048 267.392 0 66.816 0 601.92L152.768 985.984 152.768 985.984zM654.144 193.088l0 124.16 108.736 0L654.144 193.088 654.144 193.088zM821.312 384.064l-167.168 0L587.328 384.064 587.328 317.312 587.328 116.736 219.584 116.736 219.584 919.04l601.728 0L821.312 384.064 821.312 384.064zM386.688 517.888 319.808 517.888 319.808 450.944l66.816 0L386.624 517.888 386.688 517.888zM386.688 651.584 319.808 651.584 319.808 584.704l66.816 0L386.624 651.584 386.688 651.584zM386.688 785.344 319.808 785.344l0-66.88 66.816 0L386.624 785.344 386.688 785.344zM721.024 517.888 453.632 517.888 453.632 450.944l267.392 0L721.024 517.888 721.024 517.888zM654.144 651.584 453.632 651.584 453.632 584.704l200.512 0L654.144 651.584 654.144 651.584zM620.672 785.344l-167.04 0 0-66.88 167.04 0L620.672 785.344 620.672 785.344z" p-id="8793"></path></svg>';
var attachment = '<svg t="1711935375590" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3864" xmlns:xlink="http://www.w3.org/1999/xlink" width="128" height="128"><path d="M516.373333 375.978667l136.576-136.576a147.797333 147.797333 0 0 1 208.853334-0.021334 147.690667 147.690667 0 0 1-0.042667 208.832l-204.8 204.778667v0.021333l-153.621333 153.6c-85.973333 85.973333-225.28 85.973333-311.253334 0.021334-85.994667-85.973333-85.973333-225.216 0.149334-311.36L431.146667 256.362667a21.333333 21.333333 0 0 0-30.165334-30.165334L162.069333 465.066667c-102.805333 102.826667-102.826667 269.056-0.149333 371.733333 102.613333 102.613333 268.970667 102.613333 371.584 0l153.6-153.642667h0.021333l0.021334-0.021333 204.778666-204.778667c74.325333-74.325333 74.346667-194.858667 0.021334-269.184-74.24-74.24-194.88-74.24-269.162667 0.042667l-136.576 136.554667-187.626667 187.626666a117.845333 117.845333 0 0 0-0.106666 166.826667 118.037333 118.037333 0 0 0 166.826666-0.106667l255.850667-255.829333a21.333333 21.333333 0 0 0-30.165333-30.165333L435.136 669.973333a75.370667 75.370667 0 0 1-106.496 0.106667 75.178667 75.178667 0 0 1 0.128-106.496l187.605333-187.605333z" p-id="3865"></path></svg>';
var nodeIconList = [
  {
    name: "优先级图标",
    type: "priority",
    list: [
      {
        name: "1",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.794667 0 511.957333 0 229.205333 229.248 0 512.042667 0 794.752 0 1024 229.205333 1024 511.957333 1024 794.794667 794.752 1024 512.042667 1024z" fill="#E93B30"></path><path d="M580.309333 256h-75.52c-10.666667 29.824-30.165333 55.765333-58.709333 78.165333-28.416 22.314667-54.869333 37.418667-79.146667 45.397334v84.608a320 320 0 0 0 120.234667-70.698667v352.085333H580.266667V256z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "2",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M511.957333 1024C229.248 1024 0 794.752 0 512S229.248 0 511.957333 0C794.752 0 1024 229.248 1024 512s-229.248 512-512.042667 512z" fill="#FA8D2E"></path><path d="M667.946667 658.602667h-185.301334c4.864-8.533333 11.178667-17.066667 19.072-25.984 7.808-8.874667 26.453333-26.837333 55.936-53.888 29.525333-27.008 49.877333-47.786667 61.226667-62.165334 16.981333-21.717333 29.44-42.453333 37.290667-62.293333 7.808-19.84 11.776-40.746667 11.776-62.677333 0-38.570667-13.738667-70.741333-41.088-96.725334C599.466667 268.928 561.706667 256 513.834667 256c-43.690667 0-80.128 11.136-109.354667 33.578667-29.098667 22.4-46.506667 59.306667-52.010667 110.805333l93.184 9.301333c1.792-27.349333 8.405333-46.890667 19.754667-58.624 11.434667-11.776 26.837333-17.664 46.165333-17.664 19.541333 0 34.858667 5.589333 45.909334 16.768 11.136 11.264 16.682667 27.221333 16.682666 48.042667 0 18.858667-6.4 37.930667-19.242666 57.258667-9.472 14.037333-35.157333 40.533333-77.098667 79.872-52.096 48.554667-87.04 87.509333-104.704 116.821333A226.688 226.688 0 0 0 341.333333 745.429333h326.613334v-86.826666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "3",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#2E66FA"></path><path d="M627.754667 731.733333c-29.354667 25.088-66.901333 37.632-112.725334 37.632-44.928 0-81.792-11.52-110.592-34.773333-33.066667-26.538667-49.877333-64.469333-50.304-114.133333h92.16c0.426667 21.76 7.552 38.314667 21.333334 49.664 12.288 10.88 28.117333 16.341333 47.402666 16.341333 20.309333 0 36.778667-6.101333 49.322667-18.432 12.544-12.330667 18.773333-29.568 18.773333-51.797333 0-21.290667-6.229333-38.186667-18.773333-50.773334-12.544-12.501333-29.866667-18.773333-52.138667-18.773333h-13.525333v-80.042667H512c42.112 0 63.274667-21.034667 63.274667-63.146666 0-20.309333-5.888-36.096-17.706667-47.445334a60.757333 60.757333 0 0 0-43.818667-17.066666c-17.493333 0-32 5.504-43.434666 16.298666-11.562667 10.88-17.792 25.728-18.773334 44.714667H359.68c0.981333-43.946667 16.042667-78.976 45.397333-104.96 29.354667-25.941333 65.706667-39.04 109.226667-39.04 44.928 0 81.792 13.525333 110.592 40.490667 28.8 26.922667 43.306667 61.610667 43.306667 104.149333 0 48.213333-19.413333 82.688-58.154667 103.552 43.52 23.125333 65.28 61.44 65.28 114.858667 0 48.128-15.957333 85.76-47.573333 112.682666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "4",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.794667 0 512.042667 0 229.205333 229.248 0 512.042667 0 794.752 0 1024 229.205333 1024 512.042667 1024 794.794667 794.752 1024 512.042667 1024z" fill="#6D768D"></path><path d="M600.96 256v309.802667h60.117333v81.536h-60.16v98.218666h-90.154666v-98.218666H311.466667v-81.237334L522.666667 256h78.293333zM510.72 399.104l-112.042667 166.698667h112.042667V399.104z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "5",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.794667 0 512.042667 0 229.205333 229.248 0 512.042667 0 794.752 0 1024 229.205333 1024 512.042667 1024 794.794667 794.752 1024 512.042667 1024z" fill="#6D768D"></path><path d="M470.912 343.552h175.786667V256H400.256l-47.786667 253.952 75.434667 10.837333c21.205333-23.552 45.269333-35.413333 72.021333-35.413333 21.546667 0 38.997333 7.509333 52.437334 22.4 13.312 15.018667 20.053333 37.418667 20.053333 67.328 0 31.872-6.741333 55.765333-20.181333 71.552-13.397333 15.872-29.866667 23.765333-49.237334 23.765333-17.066667 0-32.085333-6.186667-45.013333-18.432-13.013333-12.373333-20.821333-29.013333-23.466667-50.133333L341.333333 611.498667c5.546667 40.874667 22.485333 73.429333 50.730667 97.621333 28.330667 24.32 64.938667 36.437333 109.866667 36.437333 56.149333 0 100.053333-21.546667 131.754666-64.554666a176.64 176.64 0 0 0 34.816-107.52c0-48.042667-14.378667-87.210667-43.221333-117.333334-28.8-30.208-63.957333-45.312-105.514667-45.312-21.674667 0-42.922667 5.248-63.829333 15.616l14.976-82.901333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "6",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 1024C229.248 1024 0 794.794667 0 512.042667 0 229.205333 229.248 0 512 0c282.88 0 512 229.205333 512 512.042667C1024 794.794667 794.88 1024 512 1024z" fill="#6D768D"></path><path d="M519.210667 256c36.992 0 67.626667 10.368 91.776 31.189333 24.192 20.821333 39.68 51.029333 46.293333 90.709334l-90.197333 9.984c-2.176-18.56-7.978667-32.298667-17.28-41.173334-9.258667-8.874667-21.418667-13.226667-36.224-13.226666-19.754667 0-36.437333 8.789333-50.048 26.453333-13.696 17.664-22.314667 54.613333-25.856 110.549333 23.296-27.52 52.138667-41.258667 86.656-41.258666 38.997333 0 72.362667 14.805333 100.181333 44.544 27.733333 29.696 41.685333 68.010667 41.685333 114.858666 0 49.877333-14.634667 89.856-43.818666 119.936-29.226667 30.208-66.730667 45.226667-112.554667 45.226667-49.066667 0-89.429333-19.072-121.130667-57.344C357.12 658.218667 341.333333 595.541333 341.333333 508.416c0-89.344 16.469333-153.813333 49.493334-193.194667C423.722667 275.754667 466.56 256 519.168 256z m-9.472 241.834667c-17.962667 0-33.066667 6.997333-45.525334 21.12-12.330667 14.037333-18.56 34.858667-18.56 62.293333 0 30.421333 6.912 53.76 20.906667 70.4 13.952 16.469333 29.866667 24.746667 47.786667 24.746667 17.28 0 31.701333-6.826667 43.178666-20.309334 11.52-13.525333 17.237333-35.669333 17.237334-66.56 0-31.658667-6.186667-54.869333-18.517334-69.546666a58.197333 58.197333 0 0 0-46.506666-22.144z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "7",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.752 0 512S229.248 0 512.042667 0C794.752 0 1024 229.248 1024 512s-229.248 512-511.957333 512z" fill="#6D768D"></path><path d="M673.024 273.066667H354.133333v86.869333h212.224a691.2 691.2 0 0 0-104.746666 187.989333c-26.026667 70.101333-39.978667 138.88-41.429334 206.293334h89.6c-0.298667-42.922667 6.698667-91.776 21.034667-146.474667a654.72 654.72 0 0 1 62.08-154.965333c27.136-48.554667 53.888-85.76 80.128-111.701334V273.066667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "8",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 1024C229.248 1024 0 794.752 0 512S229.248 0 512 0s512 229.248 512 512-229.248 512-512 512z" fill="#6D768D"></path><path d="M512.426667 256c46.208 0 82.048 11.861333 107.605333 35.541333 25.6 23.68 38.314667 53.674667 38.314667 89.898667 0 22.613333-5.802667 42.666667-17.578667 60.330667a111.445333 111.445333 0 0 1-49.450667 40.277333c26.965333 10.837333 47.36 26.752 61.312 47.658667 13.994667 20.906667 21.034667 45.013333 21.034667 72.362666 0 45.098667-14.336 81.834667-42.965333 109.952-28.586667 28.245333-66.602667 42.368-114.090667 42.368-44.245333 0-81.066667-11.648-110.464-34.986666-34.645333-27.52-52.010667-65.28-52.010667-113.365334 0-26.368 6.528-50.645333 19.626667-72.746666 13.056-22.144 33.578667-39.210667 61.696-51.242667-24.064-10.154667-41.557333-24.192-52.48-41.941333a109.824 109.824 0 0 1-16.512-58.666667c0-36.224 12.757333-66.218667 37.973333-89.898667 25.386667-23.68 61.354667-35.541333 108.032-35.541333z m1.28 265.429333c-22.784 0-39.722667 7.978667-50.901334 23.893334-11.136 15.786667-16.64 33.066667-16.64 51.498666 0 25.984 6.485333 46.208 19.712 60.714667 13.098667 14.506667 29.525333 21.802667 49.152 21.802667 19.242667 0 35.157333-6.997333 47.786667-20.992 12.629333-13.909333 18.858667-34.048 18.858667-60.416 0-23.082667-6.314667-41.557333-19.2-55.466667a63.274667 63.274667 0 0 0-48.725334-21.034667z m-0.341334-191.488c-17.792 0-32 5.333333-42.581333 16-10.538667 10.666667-15.872 24.746667-15.872 42.325334 0 18.645333 5.248 33.152 15.701333 43.648 10.453333 10.453333 24.362667 15.658667 41.770667 15.658666 17.664 0 31.658667-5.290667 42.24-15.872 10.538667-10.581333 15.872-25.173333 15.872-43.818666 0-17.493333-5.248-31.573333-15.701333-42.154667s-24.277333-15.786667-41.429334-15.786667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "9",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 1024C229.248 1024 0 794.794667 0 512.042667 0 229.333333 229.248 0 512 0c282.88 0 512 229.333333 512 512.042667C1024 794.794667 794.88 1024 512 1024z" fill="#6D768D"></path><path d="M497.28 256c49.365333 0 89.856 19.157333 121.429333 57.429333 31.701333 38.229333 47.488 101.205333 47.488 188.842667 0 89.173333-16.384 153.386667-49.365333 192.853333-32.853333 39.594667-75.605333 59.264-128.426667 59.264-37.888 0-68.608-10.154667-91.989333-30.506666s-38.4-50.816-45.013333-91.306667l90.112-9.984c2.261333 18.474667 8.021333 32.085333 17.28 41.088 9.173333 8.874667 21.418667 13.312 36.608 13.312 19.2 0 35.541333-8.874667 48.981333-26.752 13.44-17.749333 22.016-54.613333 25.770667-110.549333-23.466667 27.264-52.821333 40.874667-88.064 40.874666-38.314667 0-71.253333-14.72-99.114667-44.330666C355.242667 506.709333 341.333333 468.224 341.333333 420.864c0-49.493333 14.592-89.258667 43.946667-119.466667C414.549333 271.104 451.925333 256 497.237333 256z m-4.352 77.482667c-17.237333 0-31.658667 6.826667-43.008 20.437333-11.477333 13.653333-17.194667 35.84-17.194667 66.816 0 31.402667 6.229333 54.485333 18.645334 69.205333 12.458667 14.72 27.946667 22.101333 46.592 22.101334 18.005333 0 33.066667-7.082667 45.44-21.205334 12.330667-14.208 18.432-35.029333 18.432-62.506666 0-29.994667-6.912-53.376-20.821334-69.973334-13.824-16.597333-29.866667-24.874667-48.085333-24.874666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "10",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.794667 0 511.957333 0 229.205333 229.248 0 512.042667 0 794.752 0 1024 229.205333 1024 511.957333 1024 794.794667 794.752 1024 512.042667 1024z" fill="#6D768D"></path><path d="M619.946667 273.066667c46.976 0 83.754667 16.042667 110.250666 48.042666 31.573333 37.973333 47.36 100.864 47.36 188.672 0 87.722667-15.829333 150.698667-47.658666 189.056-26.325333 31.616-62.976 47.36-109.952 47.36-47.274667 0-85.418667-17.237333-114.346667-51.968-28.885333-34.602667-43.392-96.426667-43.392-185.386666 0-87.168 15.872-150.016 47.701333-188.416 26.282667-31.488 62.933333-47.36 110.037334-47.36z m-207.488 12.8v452.266666H325.504V411.690667A299.904 299.904 0 0 1 213.333333 476.373333V398.933333c22.656-7.296 47.36-21.12 73.856-41.514666 26.624-20.522667 44.842667-44.288 54.784-71.552h70.485334z m207.488 60.842666c-11.306667 0-21.461333 3.413333-30.336 10.24-8.874667 6.826667-15.786667 19.157333-20.693334 36.864-6.4 22.997333-9.642667 61.653333-9.642666 115.968 0 54.442667 2.944 91.733333 8.661333 112.128 5.802667 20.352 13.098667 33.877333 21.845333 40.618667 8.789333 6.741333 18.858667 10.154667 30.165334 10.154667 11.349333 0 21.376-3.498667 30.250666-10.325334 8.874667-6.826667 15.786667-19.157333 20.693334-36.778666 6.4-22.826667 9.642667-61.354667 9.642666-115.797334 0-54.314667-2.858667-91.648-8.661333-112.042666-5.802667-20.352-13.013333-33.962667-21.76-40.789334a47.616 47.616 0 0 0-30.165333-10.24z" fill="#FFFFFF"></path></svg>`
      }
    ]
  },
  {
    name: "进度图标",
    type: "progress",
    list: [
      {
        name: "1",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 928c-229.76 0-416-186.24-416-416S282.24 96 512 96V512l294.144-294.144A414.72 414.72 0 0 1 928 512c0 229.76-186.24 416-416 416z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "2",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 928c-229.76 0-416-186.24-416-416S282.24 96 512 96V512h416c0 229.76-186.24 416-416 416z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "3",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 928c-229.76 0-416-186.24-416-416S282.24 96 512 96V512l294.144 294.144A414.72 414.72 0 0 1 512 928z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "4",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 928c-229.76 0-416-186.24-416-416S282.24 96 512 96v832z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "5",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 512l-294.144 294.144A414.72 414.72 0 0 1 96 512c0-229.76 186.24-416 416-416V512z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "6",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 512H96c0-229.76 186.24-416 416-416V512z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "7",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 512L217.856 217.856A414.72 414.72 0 0 1 512 96V512z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "8",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M0 512c0 282.752 229.248 512 512 512s512-229.248 512-512S794.752 0 512 0 0 229.248 0 512z" fill="#12BB37"></path><path d="M716.629333 341.333333h-51.328a35.072 35.072 0 0 0-28.330666 14.293334l-171.989334 233.984-77.909333-106.026667a35.2 35.2 0 0 0-28.330667-14.293333H307.413333c-7.082667 0-11.264 7.936-7.082666 13.653333l136.32 185.472a35.2 35.2 0 0 0 56.533333 0l230.4-313.429333a8.533333 8.533333 0 0 0-6.954667-13.653334z" fill="#FFFFFF"></path></svg>`
      }
    ]
  },
  {
    name: "表情图标",
    type: "expression",
    list: [
      {
        name: "1",
        icon: `<svg t="1624457751393" class="icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="12255"><path d="M1.097856 1.097642h1021.804717v1021.804716H1.097856z" fill="#F09495" p-id="12256"></path><path d="M1024.000214 1024H0.000214V0h1024v1024z m-1021.804716-2.195284h1019.609433V2.195284H2.195498v1019.609432z" fill="#FFFFFF" p-id="12257"></path><path d="M234.695985 335.179887m-27.341259 0a27.341259 27.341259 0 1 0 54.682518 0 27.341259 27.341259 0 1 0-54.682518 0Z" fill="#040000" p-id="12258"></path><path d="M234.695985 363.519002c-15.666342 0-28.339115-12.772559-28.339115-28.339115 0-15.666342 12.772559-28.339115 28.339115-28.339115s28.339115 12.772559 28.339115 28.339115c0.099786 15.666342-12.672773 28.339115-28.339115 28.339115z m0-54.582732c-14.468914 0-26.243617 11.774703-26.243617 26.243617s11.774703 26.243617 26.243617 26.243617 26.243617-11.774703 26.243617-26.243617-11.774703-26.243617-26.243617-26.243617z" fill="#FFFFFF" p-id="12259"></path><path d="M776.232528 335.179887m-27.341259 0a27.341259 27.341259 0 1 0 54.682518 0 27.341259 27.341259 0 1 0-54.682518 0Z" fill="#040000" p-id="12260"></path><path d="M776.232528 363.519002c-15.666342 0-28.339115-12.772559-28.339115-28.339115 0-15.666342 12.772559-28.339115 28.339115-28.339115 15.666342 0 28.339115 12.772559 28.339115 28.339115 0 15.666342-12.772559 28.339115-28.339115 28.339115z m0-54.582732c-14.468914 0-26.243617 11.774703-26.243617 26.243617s11.774703 26.243617 26.243617 26.243617 26.243617-11.774703 26.243617-26.243617c-0.099786-14.468914-11.874488-26.243617-26.243617-26.243617z" fill="#FFFFFF" p-id="12261"></path><path d="M512.000214 671.656987c-52.58702 0-105.872539-17.961411-105.872539-52.387449S459.413194 566.882089 512.000214 566.882089s105.872539 17.961411 105.87254 52.387449S564.587234 671.656987 512.000214 671.656987z m0-74.240499c-21.952836 0-43.207172 3.592282-58.2748 9.77899-13.870201 5.68778-17.06334 11.275775-17.06334 12.07406s3.19314 6.386279 17.06334 12.07406c15.067628 6.186708 36.321965 9.77899 58.2748 9.77899s43.207172-3.592282 58.274801-9.77899c13.870201-5.68778 17.06334-11.275775 17.06334-12.07406s-3.19314-6.386279-17.06334-12.07406c-15.067628-6.286494-36.321965-9.77899-58.274801-9.77899z" fill="#040000" p-id="12262"></path></svg>`
      },
      {
        name: "2",
        icon: `<svg t="1624457767572" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1048"><path d="M0 0h1024v1024H0z" fill="#E6A6C9" p-id="1049"></path><path d="M315.1 368.1c-23.9 0-43.3-19.4-43.3-43.3s19.4-43.3 43.3-43.3 43.3 19.4 43.3 43.3-19.4 43.3-43.3 43.3z m0-74.7c-17.3 0-31.3 14.1-31.3 31.3 0 17.3 14.1 31.3 31.3 31.3 17.3 0 31.3-14.1 31.3-31.3 0-17.2-14-31.3-31.3-31.3zM738.7 368.1c-23.9 0-43.3-19.4-43.3-43.3s19.4-43.3 43.3-43.3 43.3 19.4 43.3 43.3-19.4 43.3-43.3 43.3z m0-74.7c-17.3 0-31.3 14.1-31.3 31.3 0 17.3 14.1 31.3 31.3 31.3 17.3 0 31.3-14.1 31.3-31.3 0-17.2-14-31.3-31.3-31.3zM293.5 698.8l-14.5-1.3c0.1-0.6 1.5-14.6 15.1-27.9 17.2-16.7 45-24.8 82.7-24 4.9-0.1 10.9-10.5 16.1-19.6 8.4-14.7 19-33.1 37.9-34.3 19.4-1.2 42.2 16.4 71.5 55.4 9.9 5.2 16.5 11.2 21.8 16.1 8.4 7.7 13.1 11.9 25.1 10.8 14.9-1.4 38.9-11.1 77.5-31.4 26.8-28.4 56.4-41.4 83.5-36.6 27.9 4.9 50.6 27.6 67.5 67.5l-13.4 5.7c-14.7-34.5-34.3-54.9-56.7-58.8-22.3-3.9-47.6 7.8-71.2 33.1l-0.8 0.9-1.1 0.6c-85.6 45.1-99.4 38-120.2 19.1-5.5-5-11.2-10.2-20.1-14.7l-1.5-0.8-1-1.4c-32.2-43.2-50.4-51.6-60-51-11.1 0.7-18.8 14-26.2 27-7.6 13.2-15.4 26.9-28.8 26.9h-0.2c-78.4-1.6-83 38.3-83 38.7z" fill="#040000" p-id="1050"></path></svg>`
      },
      {
        name: "3",
        icon: `<svg t="1624457776082" class="icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1204" ><path d="M1.1 1.097642h1021.804716v1021.804716H1.1z" fill="#F7E983" p-id="1205"></path><path d="M1024.002358 1024H0.002358V0h1024v1024z m-1021.804716-2.195284h1019.609433V2.195284H2.197642v1019.609432z" fill="#FFFFFF" p-id="1206"></path><path d="M329.174412 344.491728a38.118106 10.277919 57.6 1 0 17.355867-11.014369 38.118106 10.277919 57.6 1 0-17.355867 11.014369Z" fill="#040000" p-id="1207"></path><path d="M644.769475 355.956059a11.175989 36.321965 30 1 0 36.321965-62.911488 11.175989 36.321965 30 1 0-36.321965 62.911488Z" fill="#040000" p-id="1208"></path><path d="M569.678445 671.158059c-26.343403 0-51.190021-5.288638-70.049503-14.967843-20.755408-10.577275-32.230754-25.445332-32.230755-41.710388 0-16.265056 11.475346-31.133112 32.230755-41.710387 18.859482-9.579419 43.805886-14.967843 70.049503-14.967843s51.190021 5.288638 70.049503 14.967843c20.755408 10.577275 32.230754 25.445332 32.230754 41.710387 0 16.265056-11.475346 31.133112-32.230754 41.710388-18.859482 9.679205-43.805886 14.967843-70.049503 14.967843z m0-95.095693c-49.693237 0-84.318846 20.356266-84.318846 38.517248s34.625609 38.517248 84.318846 38.517248 84.318846-20.356266 84.318846-38.517248-34.725395-38.517248-84.318846-38.517248z" fill="#040000" p-id="1209"></path></svg>`
      },
      {
        name: "4",
        icon: `<svg t="1624457781889" class="icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1363" ><path d="M1.1 1.097642h1021.804716v1021.804716H1.1z" fill="#A6D9E2" p-id="1364"></path><path d="M1024.002358 1024H0.002358V0h1024v1024z m-1021.804716-2.195284h1019.609433V2.195284H2.197642v1019.609432z" fill="#FFFFFF" p-id="1365"></path><path d="M376.194134 348.950302m-23.44962 0a23.44962 23.44962 0 1 0 46.89924 0 23.44962 23.44962 0 1 0-46.89924 0Z" fill="#040000" p-id="1366"></path><path d="M629.150672 348.950302m-24.647047 0a24.647047 24.647047 0 1 0 49.294095 0 24.647047 24.647047 0 1 0-49.294095 0Z" fill="#040000" p-id="1367"></path><path d="M397.847613 603.503411c13.471058 8.282206 28.738258 14.468914 43.7061 19.458195 29.835899 9.978562 62.266225 14.169558 93.299551 7.483921 21.054765-4.490353 40.213604-14.369129 56.778016-28.039758 6.785422-5.587995-2.893783-15.167414-9.579419-9.579419-46.999026 38.916391-112.258819 31.033327-163.847983 6.086922-4.590138-2.195284-9.080491-4.490353-13.371272-7.184564-7.583707-4.590138-14.468914 7.184564-6.984993 11.774703z" fill="#040000" p-id="1368"></path><path d="M627.753674 534.052621c-31.033327 24.048334-58.474371 68.253362-37.419607 106.970182 10.577275 19.35841 29.835899 32.629897 48.795167 42.708244 7.982849 4.190996 15.067628-7.883064 7.084779-12.07406-25.245761-13.271487-53.485091-35.324108-49.094524-66.557006 2.793997-20.156695 15.766127-37.319821 29.736114-51.190022 3.392711-3.392711 6.984993-6.785422 10.776847-9.77899 2.993569-2.295069 2.394855-7.483921 0-9.878776-2.893783-3.19314-6.885208-2.49464-9.878776-0.199572z" fill="#040000" p-id="1369"></path></svg>`
      },
      {
        name: "5",
        icon: `<svg t="1624457787809" class="icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1523" ><path d="M1.1 1.097642h1021.804716v1021.804716H1.1z" fill="#AD6F59" p-id="1524"></path><path d="M1024.002358 1024H0.002358V0h1024v1024z m-1021.804716-2.195284h1019.609433V2.195284H2.197642v1019.609432z" fill="#FFFFFF" p-id="1525"></path><path d="M411.829832 330.730879a38.118106 10.277919 57.6 1 0 17.355867-11.014368 38.118106 10.277919 57.6 1 0-17.355867 11.014368Z" fill="#040000" p-id="1526"></path><path d="M480.669675 609.989476c11.774703-25.844475 27.740401-51.788735 44.60417-73.342429 13.770415-17.462483 29.237186-33.92711 47.897096-44.803742 17.262912-10.078347 35.324108-13.67063 54.283376-6.58585 11.974274 4.390567 23.948548 14.468914 33.128825 24.547261 14.369129 15.865913 25.145975 34.625609 34.725394 53.684662 4.290782 8.581563 17.262912 0.997856 12.972131-7.583707-15.167414-30.334828-35.224323-63.763009-66.157864-80.327421-21.054765-11.37556-44.504385-11.475346-66.157864-1.895927-21.054765 9.280062-38.617034 25.644904-53.485091 42.907815-14.468914 16.863769-27.041902 35.324108-38.217891 54.582733-5.887351 10.178133-11.674917 20.555837-16.464627 31.232898-1.696355 3.692068-0.997856 7.982849 2.694212 10.277918 3.19314 1.895927 8.581563 0.898071 10.178133-2.694211z" fill="#040000" p-id="1527"></path><path d="M663.863649 338.091735a14.468914 33.727538 30 1 0 33.727538-58.417811 14.468914 33.727538 30 1 0-33.727538 58.417811Z" fill="#040000" p-id="1528"></path></svg>`
      },
      {
        name: "6",
        icon: `<svg t="1624457794933" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1680" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#83CEE3" p-id="1681"></path><path d="M369 375.8m-34.6 0a34.6 34.6 0 1 0 69.2 0 34.6 34.6 0 1 0-69.2 0Z" fill="#040000" p-id="1682"></path><path d="M369 411.7c-19.8 0-36-16.1-36-36s16.1-36 36-36 36 16.1 36 36-16.1 36-36 36z m0-69.1c-18.3 0-33.2 14.9-33.2 33.2S350.7 409 369 409s33.2-14.9 33.2-33.2-14.9-33.2-33.2-33.2z" fill="#FFFFFF" p-id="1683"></path><path d="M672.2 333.6c-15.1 7.6-30.2 15.6-44.3 25-5.9 3.9-17 10.4-14.6 19.1 1.8 6.5 12 11.2 17.3 14.3 15.7 9.3 32.1 17.6 48.3 25.9 8.6 4.4 16.2-8.5 7.6-13-14.1-7.3-28.3-14.5-42.1-22.3-3.9-2.2-7.9-4.5-11.7-6.9-1.2-0.8-2.4-1.5-3.5-2.4-0.6-0.4-1.1-0.8-1.6-1.2 2.2 1.7-0.3-0.3-0.3-0.3-0.9 0.1-1.5-3.2-0.2 0.5 0.9 2.4 1.1 3.8 0.3 5.8 0.6-1.5-0.9 0.8-0.1 0 0.5-0.5 1-1.1 1.6-1.6 0.5-0.5 1-0.9 1.6-1.3 0.6-0.5 0 0 1.2-0.9 1.7-1.3 3.5-2.5 5.3-3.6 8.4-5.5 17.2-10.4 26-15.2 5.6-3 11.2-6 16.8-8.9 8.6-4.4 1-17.3-7.6-13zM578.2 720.9c-12.5-96.7-33.3-154.7-55.6-155.6-8.8 3.9-22.3 17.5-37.7 60.1-10.8 29.8-18.4 62.2-23 81.6-1.2 5.1-2.1 9.1-2.9 11.8l-9.3-2.4c0.7-2.6 1.6-6.6 2.8-11.6 14.9-63 36-136.8 67.5-148.8l0.8-0.3h0.8c18.2-0.4 33.2 19.5 45.8 60.8 10.2 33.3 16.7 74.6 20.5 103.3l-9.7 1.1z" fill="#040000" p-id="1684"></path></svg>`
      },
      {
        name: "7",
        icon: `<svg t="1624457802025" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1838" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#8CC66D" p-id="1839"></path><path d="M375.778679 404.47473a14.5 33.8 30 1 0 33.8-58.543317 14.5 33.8 30 1 0-33.8 58.543317Z" fill="#040000" p-id="1840"></path><path d="M627.220263 374.211388a43.1 11.6 57.6 1 0 19.588408-12.431182 43.1 11.6 57.6 1 0-19.588408 12.431182Z" fill="#040000" p-id="1841"></path><path d="M451.1 548.5c17.6-9.3 63.9-30 105.3-16.2 17 20.3 32.7 98.8 28.8 138.1-27.5 10.2-82.5 10.2-106.1 5.8-8.3-10.5-32.7-81.8-35.3-114.6-0.4-5.5 2.5-10.6 7.3-13.1z" fill="#040000" p-id="1842"></path></svg>`
      },
      {
        name: "8",
        icon: `<svg t="1624457816632" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1996" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#5A74B8" p-id="1997"></path><path d="M357.7 400m-34.6 0a34.6 34.6 0 1 0 69.2 0 34.6 34.6 0 1 0-69.2 0Z" fill="#040000" p-id="1998"></path><path d="M357.7 436c-19.8 0-36-16.1-36-36s16.1-36 36-36 36 16.1 36 36-16.2 36-36 36z m0-69.2c-18.3 0-33.2 14.9-33.2 33.2s14.9 33.2 33.2 33.2 33.2-14.9 33.2-33.2-14.9-33.2-33.2-33.2z" fill="#FFFFFF" p-id="1999"></path><path d="M676 400m-34.6 0a34.6 34.6 0 1 0 69.2 0 34.6 34.6 0 1 0-69.2 0Z" fill="#040000" p-id="2000"></path><path d="M676 436c-19.8 0-36-16.1-36-36s16.1-36 36-36 36 16.1 36 36-16.2 36-36 36z m0-69.2c-18.3 0-33.2 14.9-33.2 33.2s14.9 33.2 33.2 33.2c18.3 0 33.2-14.9 33.2-33.2s-14.9-33.2-33.2-33.2z" fill="#FFFFFF" p-id="2001"></path><path d="M347.6 684.1c0.3-0.9 0.6-1.7 0.9-2.6 0.2-0.5 1.4-3.2 0.3-0.8 0.6-1.4 1.3-2.9 2-4.3 3.2-6.3 6-10.7 10.9-15.3 4.3-4 10.8-7.5 17.1-6.1 3.9 0.9 7.9 4.9 11.1 7.2 3.1 2.2 6.3 4.5 9.7 6.2 7.5 3.8 15.3 4.4 23.4 1.9 4.7-1.5 9.2-3.6 13.6-5.9 5-2.6 10.7-5 14.2-9.5 4.5-5.7 6.1-8.5 11.4-14.1 1-1 2-2 3.1-3 0.2-0.2 2.2-1.7 0.6-0.5 0.6-0.4 1.2-0.9 1.8-1.3 1-0.6 2.1-1.3 3.2-1.7-2 0.8 0.2 0 0.6-0.1 2.3-0.7-0.3-0.2 1.2-0.3 2.8-0.1 3.6 0 5.5 1 3.8 1.9 6.6 4.7 9.5 7.8 4.5 5 7.5 11.1 11.7 16.2 1.8 2.2 3.7 4.3 5.4 6.5 8.1 10.3 17.7 22.2 32.2 22 8.8-0.1 16.6-5.2 22.6-11.2 4.2-4.1 7.7-8.9 11-13.7 2.9-4.2 4.6-9.9 6.2-13.5 3.2-7.1 7.2-13.1 13-18.1 4.8-4.2 11.1-6.5 16.7-5.3 10.5 2.4 17.2 12.1 23.1 20.2 4.7 6.5 9.8 13 16 18.2 7.8 6.4 17.1 11.4 27.5 11.1 14.1-0.4 25.5-9.5 34.2-19.9 3-3.6 3.6-8.8 0-12.4-3.1-3.1-9.4-3.7-12.4 0-6.3 7.6-14.7 15.9-24.9 14.7-2.2-0.3-5.3-1.5-7.9-3.1-3.5-2.1-6.1-4.4-9.1-7.5-4.9-5.1-6.8-8.1-10.9-13.8-7.3-10.1-16.1-19.6-28.2-23.7-18.5-6.3-35.7 5.6-46 20.1-2.4 3.3-4.4 6.9-6.1 10.6-1.8 3.9-2.7 8.5-5.2 11.9-3.1 4.4-6.2 8.8-10.2 12.5-3 2.8-5.7 4.4-8.6 5.1-0.4 0.1-1.7 0.1 0.1 0h-2.2c2.1 0.1 0 0-0.5-0.1-0.7-0.2-1.4-0.4-2-0.6 1.8 0.7-1.8-1.1-2.4-1.5l-1.2-0.9c1.5 1.2-0.9-0.9-1.2-1.1-4.7-4.3-8.4-9.5-12.3-14.4-10.9-13.6-20.9-34-41-34.9-14.2-0.6-24.5 10.6-32.4 20.8-1.2 1.6-2.5 3.2-3.7 4.8-1.5 1.9 1.1-1.4-0.4 0.5-0.4 0.5-0.8 1.2-1.3 1.6-1.7 1.4-4.6 2.6-6.6 3.6-2.9 1.6-5.9 3.2-9 4.5-1.6 0.7-3.4 1.2-5.1 1.7-2.2 0.6-0.7 0.5-2.8 0.4-2.8 0-3.9-0.4-6.6-1.9-3.9-2.2-7.5-4.9-11.1-7.5-5.6-4-10-6.9-17-7.5-10.5-0.9-20.3 3.2-28.2 9.9-9.4 8.1-16.4 20.2-20.1 32-3.6 11.2 13.3 15.8 16.8 5.1z" fill="#040000" p-id="2002"></path></svg>`
      },
      {
        name: "9",
        icon: `<svg t="1624457826949" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2156" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#F0884F" p-id="2157"></path><path d="M287.2 382c6.4 2.3 11.6-3.7 15.4-7.9 5.1-5.5 10.2-11 16-15.9 0.8-0.7 1.7-1.4 2.5-2.1 1.2-0.9-1.7 1.3 0.2-0.2l1.2-0.9c2.1-1.5 4.3-2.9 6.5-4.3 2-1.2 4-2.2 6.1-3.2 0.6-0.3 1.2-0.6 1.9-0.9-0.3 0.2-1.5 0.6 0.2-0.1 1.3-0.5 2.6-1 4-1.5 11.2-3.7 21.8-4 33.4-1.1 19.5 4.9 36.4 17 51.2 30.2 8.6 7.7 21.4-5 12.7-12.7-25.2-22.6-57.1-42.1-92.2-36.2-20.4 3.4-37.7 16.1-51.6 30.9-2.3 2.4-4.5 5-6.8 7.4-0.7 0.7-1.9 1.5-2.4 2.4-0.5 0.8 2.3-1.5 0.8-0.7 1.3-0.7 3.9-1.4 5.8-0.7-11.1-3.7-15.8 13.7-4.9 17.5zM598 382c6.4 2.3 11.6-3.7 15.4-7.9 5.1-5.5 10.2-11 16-15.9 0.8-0.7 1.7-1.4 2.5-2.1 1.2-0.9-1.7 1.3 0.2-0.2l1.2-0.9c2.1-1.5 4.3-2.9 6.5-4.3 2-1.2 4-2.2 6.1-3.2 0.6-0.3 1.2-0.6 1.9-0.9-0.3 0.2-1.5 0.6 0.2-0.1 1.3-0.5 2.6-1 4-1.5 11.2-3.7 21.8-4 33.4-1.1 19.5 4.9 36.4 17 51.2 30.2 8.6 7.7 21.4-5 12.7-12.7-25.2-22.6-57.1-42.1-92.2-36.2-20.4 3.4-37.7 16.1-51.6 30.9-2.3 2.4-4.5 5-6.8 7.4-0.7 0.7-1.9 1.5-2.4 2.4-0.5 0.8 2.3-1.5 0.8-0.7 1.3-0.7 3.9-1.4 5.8-0.7-11.1-3.7-15.8 13.7-4.9 17.5zM505.9 527.1c3.4 0.7 6.8 1.7 10.2 2.8 6.7 2.2 10.4 3.5 16.6 7.7 1.6 1.1-0.5-0.5 0.6 0.5 0.6 0.5 1.1 1.1 1.7 1.6 1.5 1.4-0.1-0.4 0.5 0.6 0.4 0.6 0.7 1.2 1 1.8-1-2 0.1 0 0 0.5 0.1-2-0.1 0-0.1 0-0.1 0.8 0 0.7 0.1-0.5-0.1 0.4-0.1 0.7-0.3 1.1-0.6 1 0.7-0.9-0.4 1-1.6 2.5-4.6 5.4-8.1 7.8-6.8 4.6-14.4 8.2-22 11.4-7 3-7.4 11.9 0 14.8 7.4 2.8 15 5.3 22.4 8.1 3.1 1.1 4.2 1.5 6.9 2.9 1.1 0.6 2.1 1.2 3.2 1.8 1.2 0.8-0.7-0.5 0.1 0 0.4 0.3 0.8 0.7 1.1 1.1 0.6 0.8-1.1-1.2-0.2-0.2 0.8 0.9-0.3-1.4-0.1-0.2 0.1 0.9 0.2-1.9 0-0.9-0.1 0.5-0.8 1.8 0 0.2-0.2 0.5-0.5 1-0.8 1.4-0.3 0.3-0.9 1.3-0.3 0.5-0.5 0.7-1.1 1.3-1.7 1.9-6.9 7.3-15.9 12.8-24.4 18.1-8.3 5.3-0.6 18.5 7.7 13.2 9.9-6.3 20.9-12.8 28.6-21.8 4.8-5.5 8.1-12.9 4.2-19.9-3.4-6-10.5-8.9-16.6-11.4-8.6-3.5-17.5-6.2-26.2-9.5v14.8c14.4-6.1 47.2-18.8 41.2-40.3-3.5-12.9-19.4-18.9-30.8-22.6-3.4-1.1-6.9-2.1-10.5-2.9-9.1-2.2-13.3 12.5-3.6 14.6z" fill="#040000" p-id="2158"></path></svg>`
      },
      {
        name: "10",
        icon: `<svg t="1624457835383" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2312" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#F6F180" p-id="2313"></path><path d="M342.9 400.6m-29.5 0a29.5 29.5 0 1 0 59 0 29.5 29.5 0 1 0-59 0Z" fill="#040000" p-id="2314"></path><path d="M342.9 431.3c-16.9 0-30.7-13.8-30.7-30.7s13.8-30.7 30.7-30.7 30.7 13.8 30.7 30.7-13.7 30.7-30.7 30.7z m0-59c-15.6 0-28.3 12.7-28.3 28.3s12.7 28.3 28.3 28.3 28.3-12.7 28.3-28.3-12.6-28.3-28.3-28.3z" fill="#FFFFFF" p-id="2315"></path><path d="M702 400.6m-29.5 0a29.5 29.5 0 1 0 59 0 29.5 29.5 0 1 0-59 0Z" fill="#040000" p-id="2316"></path><path d="M702 431.3c-16.9 0-30.7-13.8-30.7-30.7s13.8-30.7 30.7-30.7 30.7 13.8 30.7 30.7-13.8 30.7-30.7 30.7z m0-59c-15.6 0-28.3 12.7-28.3 28.3s12.7 28.3 28.3 28.3 28.3-12.7 28.3-28.3-12.7-28.3-28.3-28.3z" fill="#FFFFFF" p-id="2317"></path><path d="M358.7 519.9c20 22 45.5 40.4 71.3 54.8 51.2 28.5 111.7 39.9 168 19.5 44.3-16.1 80.7-47.8 110.2-83.9 3-3.7 3.6-8.9 0-12.5-3.1-3.1-9.5-3.7-12.5 0-25.5 31.4-56.2 59.7-93.7 76-27.1 11.7-56.6 15.7-85.8 12.2-24.7-2.9-49.5-11.8-71.5-23.4-18.7-9.8-36.6-22.2-51.1-34.3-7.8-6.5-15.5-13.3-22.4-20.9-7.7-8.5-20.1 4.1-12.5 12.5z" p-id="2318"></path></svg>`
      },
      {
        name: "11",
        icon: `<svg t="1624457841751" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2472" ><path d="M48.2 844.9c-68.5-210.6 186-782.1 409.1-795.4 6.3-0.4 12.5 0.2 18.6 1.6C665.1 94.6 985.4 515 987.1 821.3c0.1 20-12.9 37.9-22.4 43.1-162.7 89.8-605.8 179.7-884.4 30.9-15-7.9-24.2-26.1-32.1-50.4z" fill="#F0884F" p-id="2473"></path><path d="M401 352.1m-52.4 0a52.4 52.4 0 1 0 104.8 0 52.4 52.4 0 1 0-104.8 0Z" fill="#FFFFFF" p-id="2474"></path><path d="M408.7 329m-29.3 0a29.3 29.3 0 1 0 58.6 0 29.3 29.3 0 1 0-58.6 0Z" fill="#040000" p-id="2475"></path><path d="M527.5 352.1m-52.4 0a52.4 52.4 0 1 0 104.8 0 52.4 52.4 0 1 0-104.8 0Z" fill="#FFFFFF" p-id="2476"></path><path d="M527.5 329m-29.3 0a29.3 29.3 0 1 0 58.6 0 29.3 29.3 0 1 0-58.6 0Z" fill="#040000" p-id="2477"></path><path d="M450.7 517c1.1-8.2 3.2-16.4 6.1-24.1 0.1-0.3 1-2.5 0.5-1.4s0.3-0.7 0.5-1c0.7-1.4 1.4-2.8 2.2-4.1 0.4-0.8 2.8-3.9 1.3-2.1 0.8-1 1.7-1.9 2.6-2.8 1-1-1.5 1 0.1 0 0.5-0.3 1-0.6 1.5-0.8-1.3 0.7-1.2 0.3 0 0.1 1.9-0.3-1.8 0.3 0.1 0 1.2-0.2 1.5 0.3 0-0.1 0.6 0.2 1.3 0.3 1.9 0.5 0.3 0.1-1.3-0.7 0.2 0.1 0.8 0.5 1.6 0.9 2.4 1.4 1.4 1 0-0.1 1.4 1.1 0.9 0.8 1.8 1.7 2.6 2.6 1.8 1.9 3.5 3.9 5 6.1 5.1 7.1 9.3 14.8 13.2 22.6 3.5 6.9 13.7 4.7 15.8-2.1 2.6-8.7 4.8-17.4 7.4-26.1 0.9-3.2 1.9-6.4 3.2-9.4-0.7 1.6 0.8-1.6 1.2-2.2l0.9-1.5c0.7-1.2-1.4 0.7 0.1-0.1 1.7-0.9-1.2 0.3-0.3 0.1 0.8-0.2 1-1.2 0.3-0.3-0.6 0.8 0.6 0-0.5 0.2-2 0.3 2.4 0.5-1.1 0 0.5 0.1 1.2 0.2 1.6 0.4-1.1-0.8-0.8-0.4 0.2 0.2 0.7 0.4 3.4 2.3 2.7 1.8 8.9 7.1 15.9 16.9 22.5 26 2.8 3.8 7.5 5.6 11.8 3.1 3.7-2.2 5.9-8 3.1-11.8-8.2-11.1-16.6-23-27.7-31.4-6.3-4.7-14.5-7.6-21.7-3-6.7 4.2-9.6 12.5-11.9 19.6-3.2 9.9-5.5 20-8.6 29.9 5.3-0.7 10.5-1.4 15.8-2.1-7.8-15.5-24.8-50.1-48-41.7-14.1 5.1-19.7 23-22.9 36.2-0.9 3.8-1.8 7.7-2.3 11.6-0.6 4.6 1.1 9.3 6 10.6 4.2 1 10.2-1.5 10.8-6.1z" fill="#040000" p-id="2478"></path></svg>`
      },
      {
        name: "12",
        icon: `<svg t="1624457847424" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2632" ><path d="M485.538528 993.072489a362.00362 481.804818 3.149 1 0 52.933731-962.15464 362.00362 481.804818 3.149 1 0-52.933731 962.15464Z" fill="#AADCF0" p-id="2633"></path><path d="M688.2 334.1c-15.1 7.6-30.2 15.6-44.3 25-5.9 3.9-17 10.4-14.6 19.1 1.8 6.5 12 11.2 17.3 14.3 15.7 9.3 32.1 17.6 48.3 25.9 8.6 4.4 16.2-8.5 7.6-13-14.1-7.3-28.3-14.5-42.1-22.3-3.9-2.2-7.9-4.5-11.7-6.9-1.2-0.8-2.4-1.5-3.5-2.4-0.6-0.4-1.1-0.8-1.6-1.2 2.2 1.7-0.3-0.3-0.3-0.3-0.9 0.1-1.5-3.2-0.2 0.5 0.9 2.4 1.1 3.8 0.3 5.8 0.6-1.5-0.9 0.8-0.1 0 0.5-0.5 1-1.1 1.6-1.6 0.5-0.5 1-0.9 1.6-1.3 0.6-0.5 0 0 1.2-0.9 1.7-1.3 3.5-2.5 5.3-3.6 8.4-5.5 17.2-10.4 26-15.2 5.6-3 11.2-6 16.8-8.9 8.6-4.4 1-17.4-7.6-13zM375.8 347c13.4 6.8 26.7 14 39.5 21.9 1.8 1.2 3.7 2.3 5.5 3.5 0.9 0.6 1.7 1.2 2.6 1.8 0.9 0.6 1.9 1.4 1.6 1.1 1.1 0.9 2.1 1.9 3.1 2.8 1.2 1 0-0.3 0.1 0 0-0.2-0.8-2.4-0.3-4.1 1.5-5.5 2.3-2.7 0.8-2-0.4 0.2-0.9 0.8-1.3 1.1 1.7-1.4-1.6 1.1-2.3 1.6-3.4 2.3-6.9 4.4-10.4 6.4-14.9 8.6-30.3 16.4-45.6 24.3-8.6 4.4-1 17.4 7.6 13 15-7.7 30.1-15.4 44.8-23.8 6.2-3.6 13.8-7.3 18.7-12.7 7.6-8.3-3.8-16.6-9.9-20.9-8.7-6.1-18-11.3-27.3-16.4-6.5-3.6-13-7.1-19.6-10.4-8.6-4.5-16.3 8.5-7.6 12.8zM412.8 570.9c13.5 7.7 28.5 13.3 43.3 17.9 29.8 9.2 61.7 13.1 92.6 7.3 20.6-3.9 40-12.5 56.6-25.2 2.8-2.2 4.3-5.6 2.3-9-1.6-2.8-6.2-4.5-9-2.3-48.3 36.9-113.3 30-165.6 6.7-4.6-2.1-9.2-4.2-13.7-6.7-7.3-4.2-13.9 7.2-6.5 11.3z" fill="#040000" p-id="2634"></path><path d="M644.6 505.2c-30.1 21.5-60.6 62.5-39.1 99.8 10.7 18.6 30.3 30.9 49.1 40.1 7.8 3.8 14.6-7.9 6.8-11.7-23.6-11.5-53.7-31.4-49.4-60.9 2.8-18.9 15.8-34.6 29.5-47.2 2.5-2.3 5.1-4.6 7.8-6.7 0.5-0.4 0.9-0.7 1.4-1.1-0.4 0.3-1.2 0.9-0.1 0.1l0.9-0.6c6.9-5.1 0.2-16.8-6.9-11.8z" fill="#040000" p-id="2635"></path></svg>`
      },
      {
        name: "13",
        icon: `<svg t="1624457855182" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2789" ><path d="M235.1 76.9c75.6-26.5 297.3-90.1 514.2-16.6 16.3 5.5 29.8 17.4 37.1 33 57.5 122.4 127.1 602.1 62.1 785.6a62.58 62.58 0 0 1-32.5 35.8c-109.5 51.8-428.1 136.7-609.3 37.2-14.4-7.9-25-21.3-29.7-37.1-41.9-140.6-37-627.7 19.1-798 6.1-18.7 20.5-33.4 39-39.9z" fill="#F9DABD" p-id="2790"></path><path d="M392.2 360.2m-35.2 0a35.2 35.2 0 1 0 70.4 0 35.2 35.2 0 1 0-70.4 0Z" fill="#040000" p-id="2791"></path><path d="M618.6 360.2m-35.2 0a35.2 35.2 0 1 0 70.4 0 35.2 35.2 0 1 0-70.4 0Z" fill="#040000" p-id="2792"></path><path d="M512 562.6c-36 0-65.3-29.3-65.3-65.3S476 432 512 432s65.3 29.3 65.3 65.3-29.3 65.3-65.3 65.3z m0-122.9c-31.7 0-57.6 25.8-57.6 57.6s25.8 57.6 57.6 57.6c31.7 0 57.6-25.8 57.6-57.6s-25.9-57.6-57.6-57.6z" fill="#040000" p-id="2793"></path></svg>`
      },
      {
        name: "14",
        icon: `<svg t="1624457863444" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2947" ><path d="M178.1 971.5c38.1 15.9 98.7 26.6 171.3-12.3 3.7-2 8.4-1.6 11.6 1.1 43.3 35.9 123.3 80.8 236 10.9 3.8-2.4 8.7-2.4 12.6-0.2 41.8 23.9 191.6 58.2 246.6 14.2 4.4-3.5 9.1-6.6 14.5-8.5C1065 909.5 678.2-652 194.3 351c-37.5 77.8-38.4 94.1-71.9 211.3-27.6 96.3-29.1 231.3 1.4 348.1 7.2 27.3 27.3 49.9 54.3 61.1z" fill="#ABAAAA" p-id="2948"></path><path d="M468.9 349H418c-6.1 0-11.1-5-11.1-11.1V336c0-6.1 5-11.1 11.1-11.1h50.9c6.1 0 11.1 5 11.1 11.1v1.9c0 6.1-5 11.1-11.1 11.1zM643 471.9H390c-6.6 0-12-5.4-12-12s5.4-12 12-12h253c6.6 0 12 5.4 12 12s-5.4 12-12 12zM609 349h-61.2c-6 0-11-4.9-11-11v-2.1c0-6 4.9-11 11-11H609c6 0 11 4.9 11 11v2.1c0 6.1-4.9 11-11 11z" fill="#040000" p-id="2949"></path></svg>`
      },
      {
        name: "15",
        icon: `<svg t="1624457870536" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3103" ><path d="M673.1 318.7c3.7-17.5 5.6-35.7 5.6-54.4 0-137.9-105.5-249.7-235.6-249.7S207.4 126.4 207.4 264.3c0 55.4 17.1 106.7 45.9 148.1-55.2 63.3-88.6 145.9-88.6 236.3 0 199.2 162.1 360.6 362.1 360.6 200 0 362.1-161.5 362.1-360.6 0.1-147.3-88.7-274-215.8-330z" fill="#4F8A54" p-id="3104"></path><path d="M392 246.2m-47.1 0a47.1 47.1 0 1 0 94.2 0 47.1 47.1 0 1 0-94.2 0Z" fill="#FFFFFF" p-id="3105"></path><path d="M386 252.8m-26.4 0a26.4 26.4 0 1 0 52.8 0 26.4 26.4 0 1 0-52.8 0Z" fill="#040000" p-id="3106"></path><path d="M505.6 246.2m-47.1 0a47.1 47.1 0 1 0 94.2 0 47.1 47.1 0 1 0-94.2 0Z" fill="#FFFFFF" p-id="3107"></path><path d="M501.4 252.8m-26.4 0a26.4 26.4 0 1 0 52.8 0 26.4 26.4 0 1 0-52.8 0Z" fill="#040000" p-id="3108"></path><path d="M474.3 364.8h-50.9c-6.1 0-11.1-5-11.1-11.1v-1.9c0-6.1 5-11.1 11.1-11.1h50.9c6.1 0 11.1 5 11.1 11.1v1.9c0 6.2-5 11.1-11.1 11.1z" fill="#040000" p-id="3109"></path></svg>`
      },
      {
        name: "16",
        icon: `<svg t="1624457876371" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3263" ><path d="M246.4 227.6c-166.9 101.1-461.9 344 87 564.1 1.5 0.6 2.9 1.1 4.4 1.6 80.7 27.7 392.8 165.4 641-198.1 40-58.6 38.5-136.2-3.7-193.3C892 289.5 727 201.1 429.1 182.7c-64.1-4-127.8 11.6-182.7 44.9z" fill="#CF92BE" p-id="3264"></path><path d="M617.1 393.4c-17.4 8.8-34.9 18.1-51.2 28.9-6.9 4.6-20.3 12.3-17.4 22.6 1.2 4.3 5.6 7 9 9.5 3.7 2.7 7.6 5 11.5 7.3 18.2 10.8 37.1 20.3 55.9 30 10 5.1 18.9-10 8.8-15.1-16.4-8.4-32.9-16.9-49-26-4.5-2.6-9.1-5.2-13.5-8l-4.5-3c-0.7-0.5-1.3-1-2-1.5 1.6 1.2 0.7 0.4-0.2-0.2-1.3-0.9-0.3-0.9-0.5-0.3 0.2 0.2 0.4 0.5 0.6 0.7 1 1.9 1.3 3.7 0.8 5.7 0.1-0.6 0.7-1.4-0.6 1.3 0.7-1.5-0.1 0-0.2 0.1 0.6-0.6 1.2-1.3 1.9-1.9l1.8-1.5c1.8-1.6-0.6 0.3 1.2-0.9 2-1.5 4.1-2.9 6.2-4.3 10-6.5 20.4-12.4 30.9-18 6.5-3.5 13.1-7 19.7-10.4 9.6-5 0.8-20.1-9.2-15zM323.1 408.5c15.9 8.1 31.7 16.5 46.8 26 2.2 1.4 4.3 2.8 6.5 4.2 1 0.7 1.9 1.3 2.8 2 0.5 0.3 1 0.7 1.4 1.1-1.1-0.9-0.3-0.3 0.3 0.3 1.1 1 2.2 2.2 3.3 3.1 1.4 1.1-1-1.7-0.1-0.1-0.6-1.1-0.9-4.1 0.3-6.7 2.2-4.8 0.7 0.1 0-0.5 0 0-1.1 0.9-1.3 1 2.3-1.9 0 0-0.5 0.4-0.8 0.5-1.5 1.1-2.3 1.6-4 2.7-8.1 5.1-12.3 7.5-17.3 10-35.1 19.1-52.8 28.2-10 5.1-1.2 20.2 8.8 15.1 17.5-9 35-17.9 52-27.7 7.3-4.2 15.9-8.6 21.8-14.7 9.3-9.7-4.3-19.7-11.5-24.7-10.1-7.1-20.9-13.1-31.7-19-7.6-4.2-15.2-8.2-22.9-12.1-9.7-5.2-18.6 9.9-8.6 15zM513 592.1c-12.2 0-24.6-1.4-36.3-4.3-8-2-13.9-8.2-15.4-16.2s1.7-15.8 8.4-20.5c23.2-16.3 60.5-31.9 106.2-13 6.4 2.6 11 8.3 12.3 15.1 1.3 6.7-0.8 13.6-5.7 18.3-13.5 13.1-40.9 20.6-69.5 20.6z m-37.4-32.5c-3.4 2.4-4.9 6.2-4.2 10.2 0.8 4.1 3.6 7.1 7.7 8.1 39.1 9.7 81.2 0.7 96.1-13.7 2.4-2.3 3.4-5.6 2.7-8.9-0.7-3.4-2.9-6.2-6.1-7.5-41.2-17.2-75.1-3.1-96.2 11.8z" fill="#040000" p-id="3265"></path></svg>`
      },
      {
        name: "17",
        icon: `<svg t="1624457881793" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3419" ><path d="M1008.6 465.7c0-124.9-95.5-226.2-213.4-226.2-12 0-23.8 1.1-35.2 3.1v-3.1c0-124.9-95.5-226.2-213.4-226.2S333.4 114.6 333.4 239.5c0 2.4 0 4.8 0.1 7.2-17.1-4.7-35-7.2-53.4-7.2-117.8 0-213.4 101.3-213.4 226.2 0 92.1 51.9 171.3 126.3 206.6-13.7 29.9-21.4 63.4-21.4 98.8 0 124.9 95.5 226.2 213.4 226.2 68.8 0 130-34.5 169-88.1 39 53.6 100.2 88.1 169 88.1 117.8 0 213.4-101.3 213.4-226.2 0-41.2-10.4-79.9-28.6-113.1 60.5-39.9 100.8-111.1 100.8-192.3z" fill="#8CC66D" p-id="3420"></path><path d="M437.8 400.7m-24.7 0a24.7 24.7 0 1 0 49.4 0 24.7 24.7 0 1 0-49.4 0Z" fill="#040000" p-id="3421"></path><path d="M649.7 400.7m-24.7 0a24.7 24.7 0 1 0 49.4 0 24.7 24.7 0 1 0-49.4 0Z" fill="#040000" p-id="3422"></path><path d="M527.3 625.9c6.3-14.2 13.1-28.3 17.9-43 6.2-19 8.3-38.6 10.5-58.3l2.1-19.2c0.7-6.2-9-6.1-9.7 0-1.7 16.3-2.8 32.8-5.7 48.9-4.2 23.7-13.8 45-23.5 66.7-2.5 5.6 5.9 10.5 8.4 4.9z" fill="#252525" p-id="3423"></path><path d="M447.7 522.3c20.3-0.1 40.6-0.2 61-0.4l96.6-0.6c7.5 0 14.9-0.1 22.4-0.1 16.6-0.1 16.7-25.9 0-25.8-20.3 0.1-40.6 0.2-61 0.4l-96.6 0.6c-7.5 0-14.9 0.1-22.4 0.1-16.6 0.1-16.7 25.9 0 25.8z" fill="#040000" p-id="3424"></path><path d="M495.4 508.2c-10.3 3.8-9.2 20.9-9.2 29.5 0.1 16 2.1 32.3 6.1 47.8 3.5 13.7 8.7 29.9 20.6 38.7 12.9 9.5 27.6 2.1 37.6-7.9 10.2-10.3 17.8-23 24.7-35.6 11.6-21.3 20.9-43.8 29.7-66.4 3-7.8-9.5-11.1-12.5-3.4-7.4 19.1-15.3 38.1-24.7 56.4-5.9 11.5-12.2 23-20.3 33.1-2.8 3.5-5.8 6.9-9.2 9.8-1.9 1.7-1.4 1.3-3.3 2.5-1.3 0.8-2.6 1.6-3.9 2.2-0.7 0.3 1-0.2-0.8 0.3-0.6 0.2-1.2 0.3-1.8 0.5-1.1 0.3-1.2 0.2-0.5 0.1-0.6 0-1.3 0-1.9 0.1-2.2 0.1 0.6 0.5-1.8-0.2l-1.8-0.6c1.5 0.5 0.2 0.1-0.5-0.3-0.8-0.5-2.9-2.1-1.7-1.1-1-0.9-2-1.7-2.8-2.7-0.4-0.5-0.9-1-1.3-1.5 0.4 0.5 0.1 0.2-0.5-0.7-0.8-1.3-1.7-2.5-2.4-3.9-0.7-1.3-1.4-2.5-2-3.8-0.4-0.8-0.8-1.6-1.1-2.4-0.1-0.2-0.5-1.1 0 0l-0.6-1.5a86.8 86.8 0 0 1-3.3-9.8c-4.4-14.9-6.2-27.9-6.8-42.8-0.3-6.6-0.3-13.1 0.4-19.7 0.2-1.5-0.3 1.5 0.1-0.5l0.3-1.8c0.2-0.9 0.5-1.8 0.7-2.8 0.4-1.9-0.7 1.1 0.3-0.7 0.5-1-1.3 1.2-0.3 0.5-0.3 0.3-1.1 0.8-2 1.1 7.7-2.9 4.3-15.4-3.5-12.5z" fill="#040000" p-id="3425"></path></svg>`
      },
      {
        name: "18",
        icon: `<svg t="1624457899440" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3579" ><path d="M75.4 739.8c-78.7-134.4-194-455.7 401.4-579.6 9.8-2 19.2-6.2 29.2-7.5C656.8 133 947.3 205 1000.1 578.4c42.6 223.8 29.7 392.1-822 233.6-43.1-8-80.6-34.4-102.7-72.2z" fill="#F09495" p-id="3580"></path><path d="M704.6 875.4c-129 0-301.8-20.5-526.6-62.3-43.5-8.1-81.2-34.6-103.5-72.7-19.3-32.9-44.8-84.3-57.1-142.5-13.9-65.1-8.8-125.3 15.1-179.2 54.3-122.3 203.7-209.6 444-259.6 4.1-0.9 8.3-2.1 12.3-3.4 5.5-1.7 11.1-3.4 16.9-4.2 29-3.8 75.7-5.9 133.8 5.7 54.5 10.9 105.3 31 150.8 59.9C843.7 251 888.2 296 922.7 351c39.7 63.1 66.1 139.6 78.5 227.3 8.1 42.4 15.2 87.3 12.5 127.9-2.8 42.6-16.4 75.5-41.5 100.7-42.5 42.7-120.3 65-237.8 68.1-9.6 0.2-19.6 0.4-29.8 0.4zM76.3 739.3c22 37.6 59.2 63.7 102.1 71.7 242.5 45.1 424.4 65.3 556.1 61.9 116.9-3.1 194.1-25.2 236.3-67.5 55.4-55.6 44.4-142.5 28.3-226.7C976 415.8 903.4 291.5 789.2 219c-124-78.7-248.1-69.9-283.2-65.3-5.6 0.7-11.2 2.4-16.6 4.1-4.1 1.2-8.3 2.5-12.5 3.4C237.3 211.1 88.5 298 34.5 419.6c-54.6 122.8 2.8 253 41.8 319.7z" fill="#FFFFFF" p-id="3581"></path><path d="M424.1 442.5m-24.7 0a24.7 24.7 0 1 0 49.4 0 24.7 24.7 0 1 0-49.4 0Z" fill="#040000" p-id="3582"></path><path d="M635.9 442.5m-24.7 0a24.7 24.7 0 1 0 49.4 0 24.7 24.7 0 1 0-49.4 0Z" fill="#040000" p-id="3583"></path><path d="M426.2 543.3c17.1 7.9 36.6 26 25.5 46.1-6.9 12.5-19.8 21.2-31.7 28.4-4.5 2.7-0.4 9.8 4.1 7.1 17.4-10.5 41.6-27.6 39-51.1-1.6-14-12.4-24.8-23.5-32.3-3-2-6.1-3.9-9.3-5.4-4.8-2.1-8.9 5-4.1 7.2zM629.5 535.4c-21.8 11.7-40.6 37-25.7 61.3 8.2 13.4 22.2 22.7 35.7 30.3 4.7 2.7 8.9-4.6 4.2-7.2-15.5-8.7-39.9-23.9-36.9-45.2 1.6-11.4 10.7-20.7 19.6-27.2 2.4-1.7 4.8-3.4 7.4-4.8 4.7-2.5 0.4-9.8-4.3-7.2z" fill="#040000" p-id="3584"></path><path d="M457.2 584.6c25.6 25.6 66.7 41 101.8 28.3 18.2-6.6 33.2-19.1 45.5-33.8 4.2-5.1-3-12.4-7.3-7.3-18.5 22-43.3 38.1-73 35-18.6-1.9-36.2-10.8-50.9-22-2.9-2.2-6.1-4.8-8.8-7.5-4.7-4.7-12 2.6-7.3 7.3z" fill="#040000" p-id="3585"></path></svg>`
      },
      {
        name: "19",
        icon: `<svg t="1624457904464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3739" ><path d="M915.9 510.5c8.4-19 13.1-39.8 13.1-61.7 0-90-78.9-162.9-176.2-162.9-3.2 0-6.3 0.1-9.5 0.2v-0.2c0-94.8-116.2-171.6-259.6-171.6S224 191.2 224 286v2c-96.2 0-174.1 72-174.1 160.9 0 38 14.3 73 38.2 100.5-41.8 29.4-68.8 75.9-68.8 128.2 0 88.9 78 160.9 174.1 160.9 17.1 0 33.6-2.3 49.3-6.5 28.9 46.1 88.7 77.7 157.6 77.7 49.4 0 94-16.2 126-42.3 32 26.1 76.6 42.3 126 42.3 77.3 0 143-39.7 166.7-95 3.1 0.2 6.3 0.2 9.5 0.2 97.3 0 176.2-72.9 176.2-162.9 0-60.6-35.7-113.4-88.8-141.5z" fill="#5A74B8" p-id="3740"></path><path d="M357.6 449.5a46.6 73.2 0 1 0 93.2 0 46.6 73.2 0 1 0-93.2 0Z" fill="#FEFEFD" p-id="3741"></path><path d="M357.5 449.5a25.1 39.4 0 1 0 50.2 0 25.1 39.4 0 1 0-50.2 0Z" fill="#040000" p-id="3742"></path><path d="M531.3 449.5a46.6 73.2 0 1 0 93.2 0 46.6 73.2 0 1 0-93.2 0Z" fill="#FEFEFD" p-id="3743"></path><path d="M531.2 449.5a25.1 39.4 0 1 0 50.2 0 25.1 39.4 0 1 0-50.2 0Z" fill="#040000" p-id="3744"></path><path d="M426.7 574.6c20.9 29.9 59.7 52.2 96.2 38.6 19.2-7.2 34.7-21.2 47.6-36.9 2.8-3.5 3.4-8.3 0-11.7-2.9-2.9-8.9-3.5-11.7 0-16.5 20.2-40.9 40.9-68.1 35.5-17.3-3.4-31-13.2-42.9-25.9-2-2.2-3.9-4.4-5.8-6.7-1.6-1.9 1.1 1.5-0.4-0.6-0.2-0.2-0.3-0.5-0.5-0.7-6.2-8.7-20.6-0.4-14.4 8.4z" fill="#040000" p-id="3745"></path></svg>`
      },
      {
        name: "20",
        icon: `<svg t="1624457910321" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3899" ><path d="M792.8 301.4c-8.2 0-16.2 0.4-24.2 1.3-12.3-81.8-129.2-145.9-271.8-145.9-137.1 0-250.5 59.3-269.9 136.6C105.3 295.5 7.4 391.2 7.4 508.9c0 119.1 100.2 215.6 223.7 215.6 5.3 0 10.6-0.2 15.8-0.5 14.4 80.5 130.4 143.2 271.3 143.2 135.9 0 248.6-58.3 269.4-134.6 1.7 0 3.4 0.1 5.1 0.1 123.6 0 223.7-96.5 223.7-215.6s-100-215.7-223.6-215.7z" fill="#F6CD50" p-id="3900"></path><path d="M435.9 431.5m-52.2 0a52.2 52.2 0 1 0 104.4 0 52.2 52.2 0 1 0-104.4 0Z" fill="#FAFAFA" p-id="3901"></path><path d="M588.1 431.5m-52.2 0a52.2 52.2 0 1 0 104.4 0 52.2 52.2 0 1 0-104.4 0Z" fill="#FAFAFA" p-id="3902"></path><path d="M435.9 431.5m-27.8 0a27.8 27.8 0 1 0 55.6 0 27.8 27.8 0 1 0-55.6 0Z" fill="#040000" p-id="3903"></path><path d="M601.9 407.4c-5.7 2.9-11.3 5.9-16.9 9-6.8 3.8-15.3 7.8-20.5 13.8-5.6 6.5 1.6 11.1 6.7 14.4 11.2 7.1 23.3 13 35.1 19 5.7 2.9 10.8-5.7 5.1-8.6-10.9-5.6-21.9-11.1-32.4-17.4-2.4-1.4-4.6-3.1-7-4.6 1 0.6-0.4-0.4-0.4-0.4-1.9-0.3-0.5 4.2 0.5 4.1-0.1 0-0.6 0.3 0.3-0.3 0.5-0.3 1-0.9 1.5-1.3 9.7-7.9 21.9-13.5 33.1-19.2 5.7-2.7 0.6-11.4-5.1-8.5zM406.6 547.6c11.5 14.4 27 26.7 42.7 36.3 32.2 19.8 71.2 27.2 107.6 15.4 29.5-9.6 54.6-29.1 75.5-51.6 10.8-11.6-6.6-29.1-17.5-17.5-9.4 10.1-19.5 19.7-30.8 27.7-4.6 3.2-9.3 6.2-14.2 8.9-5 2.8-9.9 5.1-14.1 6.7-4.6 1.7-9.3 3.2-14.1 4.4-2.2 0.5-4.4 1-6.6 1.4-1 0.2-2 0.3-2.9 0.5 2.6-0.4-2.1 0.2-2.5 0.3-4.1 0.4-8.3 0.5-12.5 0.4-2.2-0.1-4.4-0.2-6.6-0.4-1.1-0.1-2.2-0.2-3.2-0.3-1.5-0.2-1.4-0.2 0.1 0l-2.1-0.3c-7.8-1.3-15.4-3.4-22.8-6.2-0.9-0.4-1.8-0.7-2.8-1.1-3.1-1.2 2.3 1.1-0.7-0.3-1.5-0.7-2.9-1.3-4.4-2-3.7-1.8-7.2-3.7-10.8-5.8-5.7-3.4-11.1-7.1-16.4-11.1 3 2.3-1.1-0.9-1.8-1.5-1.1-0.9-2.1-1.7-3.1-2.6-2.1-1.8-4.2-3.7-6.3-5.6-4.4-4.1-8.7-8.4-12.4-13.1-4.2-5.2-13.1-4.3-17.5 0-5 5.1-4 12.2 0.2 17.4z" fill="#040000" p-id="3904"></path></svg>`
      }
    ]
  },
  {
    name: "标记图标",
    type: "sign",
    list: [
      {
        name: "1",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M809.728 429.696a18.901333 18.901333 0 0 0-15.274667-12.885333l-183.466666-26.624-81.92-166.272a18.901333 18.901333 0 0 0-34.005334 0l-81.92 166.272-183.594666 26.624a19.029333 19.029333 0 0 0-10.496 32.298666l132.693333 129.536-31.274667 182.741334a18.816 18.816 0 0 0 27.477334 19.84l164.138666-86.186667 164.096 86.058667a18.773333 18.773333 0 1 0 27.434667-19.84l-31.36-182.741334 132.693333-129.408a18.901333 18.901333 0 0 0 4.778667-19.413333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "2",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M644.565333 306.901333c32.128 0 65.834667-5.76 101.077334-17.237333a17.066667 17.066667 0 0 1 22.357333 16.213333v328.32c-1.109333 0.768 10.325333 27.093333-99.370667 19.84-109.653333-7.210667-181.76-45.098667-246.869333-45.098666-65.152 0-49.322667 2.688-74.154667 8.405333v168.064a24.746667 24.746667 0 0 1-24.490666 25.258667 22.528 22.528 0 0 1-17.28-7.253334 24.149333 24.149333 0 0 1-7.168-18.005333V281.258667C299.776 280.490667 328.106667 256 421.76 256s164.437333 50.901333 222.805333 50.901333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "3",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M524.074667 225.408l274.517333 274.517333a17.066667 17.066667 0 0 1 0 24.149334l-274.517333 274.517333a17.066667 17.066667 0 0 1-24.149334 0l-274.517333-274.517333a17.066667 17.066667 0 0 1 0-24.149334l274.517333-274.517333a17.066667 17.066667 0 0 1 24.149334 0z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "4",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M317.866667 300.8h388.266666c9.386667 0 17.066667 7.68 17.066667 17.066667v388.266666a17.066667 17.066667 0 0 1-17.066667 17.066667h-388.266666a17.066667 17.066667 0 0 1-17.066667-17.066667v-388.266666c0-9.386667 7.68-17.066667 17.066667-17.066667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "5",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M498.346667 279.082667L248.789333 701.44a15.829333 15.829333 0 0 0 13.653334 23.893333h499.114666a15.829333 15.829333 0 0 0 13.653334-23.893333l-249.6-422.357333a15.829333 15.829333 0 0 0-27.264 0z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "6",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M497.749333 798.549333l-31.445333-28.501333C313.941333 631.722667 213.333333 540.501333 213.333333 428.8a160.981333 160.981333 0 0 1 162.730667-162.730667c51.498667 0 100.906667 23.978667 133.12 61.696a177.536 177.536 0 0 1 133.162667-61.696 160.981333 160.981333 0 0 1 162.730666 162.730667c0 111.701333-100.608 202.965333-252.970666 341.333333l-31.445334 28.458667a17.066667 17.066667 0 0 1-22.912 0z" fill="#FFFFFF"></path><path d="M634.538667 487.808L555.050667 426.24 507.306667 256a201.002667 201.002667 0 0 0-23.594667 20.394667l-0.256-0.256L525.653333 426.666667l-133.290666 59.946666a14.08 14.08 0 0 0-8.021334 15.957334l28.757334 126.378666a14.208 14.208 0 0 0 27.733333-6.229333l-26.24-115.114667 126.037333-56.704 76.416 59.136a14.250667 14.250667 0 0 0 19.968-2.474666 14.08 14.08 0 0 0-2.474666-19.797334z" fill="#6D768D"></path></svg>`
      },
      {
        name: "7",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M497.749333 798.549333l-31.445333-28.501333C313.941333 631.722667 213.333333 540.501333 213.333333 428.8a160.981333 160.981333 0 0 1 162.730667-162.730667c51.498667 0 100.906667 23.978667 133.12 61.696a177.536 177.536 0 0 1 133.162667-61.696 160.981333 160.981333 0 0 1 162.730666 162.730667c0 111.701333-100.608 202.965333-252.970666 341.333333l-31.445334 28.458667a17.066667 17.066667 0 0 1-22.912 0z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "8",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M374.656 273.194667c5.973333 4.48 12.117333 9.6 18.346667 15.36 6.272 5.717333 11.904 12.373333 16.896 19.84 2.517333 4.010667 5.504 8.490667 9.002666 13.482666a529.493333 529.493333 0 0 1 20.266667 32.213334h155.221333a169.813333 169.813333 0 0 0 9.770667-15.744c2.474667-4.48 5.248-8.96 8.234667-13.482667a460.842667 460.842667 0 0 1 23.253333-31.829333c4.992-6.229333 12.245333-12.373333 21.76-18.346667a34.261333 34.261333 0 0 0 10.112-9.728 31.274667 31.274667 0 0 0 5.248-11.989333 18.56 18.56 0 0 0-1.536-11.605334 17.664 17.664 0 0 0-10.112-8.618666c-4.48-1.493333-8.362667-2.005333-11.605333-1.493334a46.933333 46.933333 0 0 0-9.770667 2.602667c-3.242667 1.28-6.613333 2.645333-10.112 4.138667a32.426667 32.426667 0 0 1-12.757333 2.261333 26.026667 26.026667 0 0 1-12.373334-2.645333 45.653333 45.653333 0 0 1-8.96-6.357334l-8.661333-7.850666a30.336 30.336 0 0 0-11.989333-6.4c-9.984-3.968-18.005333-4.693333-24.021334-2.218667-5.973333 2.474667-11.946667 6.485333-17.962666 11.946667a88.618667 88.618667 0 0 1-11.989334 10.496 7.338667 7.338667 0 0 1-3.754666 1.493333 46.165333 46.165333 0 0 1-8.277334-5.205333 71.808 71.808 0 0 1-7.125333-4.906667 37.973333 37.973333 0 0 1-6.4-6.357333c-3.968-3.968-9.941333-6.613333-17.92-7.850667a31.061333 31.061333 0 0 0-21.76 4.138667c-8.533333 5.461333-14.506667 10.069333-18.048 13.824a29.354667 29.354667 0 0 1-15.744 7.893333 23.978667 23.978667 0 0 1-13.098667-0.768 987.733333 987.733333 0 0 0-14.634666-4.48 80.725333 80.725333 0 0 0-14.250667-2.986667 16.768 16.768 0 0 0-11.989333 2.986667c-6.997333 5.461333-9.258667 12.074667-6.741334 19.84a34.56 34.56 0 0 0 13.482667 18.346667z" fill="#FFFFFF"></path><path d="M780.757333 545.152a219.306667 219.306667 0 0 0-19.882666-65.536 224.981333 224.981333 0 0 0-33.365334-49.792 430.336 430.336 0 0 0-37.12-37.12c-14.506667-11.946667-27.264-23.296-38.272-34.048a544.512 544.512 0 0 1-27.733333-28.842667 305.28 305.28 0 0 1-22.485333-26.197333h-168.746667c-6.485333 8.490667-13.994667 17.493333-22.485333 26.965333a360.96 360.96 0 0 1-26.24 28.074667c-10.538667 10.24-22.272 21.12-35.285334 32.597333a305.493333 305.493333 0 0 0-41.6 44.16 250.026667 250.026667 0 0 0-49.493333 117.589334 216.106667 216.106667 0 0 0 1.877333 70.4 220.586667 220.586667 0 0 0 75.349334 126.549333c21.248 18.005333 47.146667 32.597333 77.653333 43.818667 30.464 11.264 65.493333 16.853333 104.96 16.853333 38.528 0 72.874667-4.864 103.125333-14.592a265.045333 265.045333 0 0 0 78.378667-39.338667c21.973333-16.469333 39.594667-35.797333 52.864-58.026666 13.226667-22.186667 22.101333-45.824 26.624-70.784 4.992-30.421333 5.632-58.026667 1.877333-82.773334z" fill="#FFFFFF"></path><path d="M593.322667 647.509333a20.48 20.48 0 0 1-11.861334 3.2h-50.133333v14.165334c0 4.266667-1.792 8.362667-5.376 12.373333a15.914667 15.914667 0 0 1-13.952 5.333333 24.917333 24.917333 0 0 1-14.336-3.882666c-3.84-2.602667-5.973333-7.210667-6.4-13.824v-14.165334h-48.725333a17.792 17.792 0 0 1-11.818667-3.882666 10.24 10.24 0 0 1-3.968-9.6c0-4.266667 1.578667-7.68 4.693333-10.24a16.768 16.768 0 0 1 11.093334-3.925334h48.682666v-24.789333h-48.682666a15.573333 15.573333 0 0 1-11.52-4.266667 13.525333 13.525333 0 0 1-4.266667-9.941333 15.36 15.36 0 0 1 4.693333-10.624 14.72 14.72 0 0 1 11.093334-4.949333h48.682666l0.725334-14.890667a1053.568 1053.568 0 0 1-40.832-42.538667l-10.752-9.898666a41.216 41.216 0 0 1-6.442667-11.690667c-1.92-4.992-0.938667-10.069333 2.858667-15.274667a13.653333 13.653333 0 0 1 15.786666-3.84c6.186667 2.090667 11.221333 4.821333 15.018667 8.106667 1.92 2.389333 5.248 5.888 10.026667 10.666667l15.061333 14.848 19.328 19.157333 22.186667-20.565333a987.605333 987.605333 0 0 1 29.397333-25.514667 21.162667 21.162667 0 0 1 14.293333-5.674667c5.290667 0 9.557333 2.133333 12.928 6.4 6.186667 7.082667 3.84 15.36-7.168 24.789334a179.072 179.072 0 0 0-12.885333 12.373333c-5.76 5.973333-11.52 11.733333-17.194667 17.408-6.698667 7.082667-14.08 14.378667-22.186666 21.973333v13.44h46.506666c6.698667 0 11.605333 1.536 14.72 4.608a14.165333 14.165333 0 0 1 4.650667 10.282667c0 4.266667-1.450667 7.936-4.309333 11.008-2.858667 3.029333-7.637333 4.352-14.336 3.84l-46.506667 0.768-0.768 24.064h45.866667c13.354667 0 20.053333 4.992 20.053333 14.933333 0.469333 4.693333-0.853333 8.106667-3.925333 10.24z" fill="#6D768D"></path></svg>`
      },
      {
        name: "9",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M512 213.333333l234.666667 341.333334h-128v213.333333h-213.333334v-213.333333h-128L512 213.333333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "10",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M533.333333 810.666667L298.666667 469.333333h128V256h213.333333v213.333333h128l-234.666667 341.333334z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "11",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M213.333333 533.333333L554.666667 298.666667v128h213.333333v213.333333h-213.333333v128l-341.333334-234.666667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "12",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M810.666667 533.333333L469.333333 768v-128H256v-213.333333h213.333333V298.666667l341.333334 234.666666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "13",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M0 512c0 282.752 229.248 512 512 512s512-229.248 512-512S794.752 0 512 0 0 229.248 0 512z" fill="#6D768D"></path><path d="M571.349333 508.586667l162.389334-162.346667a44.330667 44.330667 0 1 0-62.72-62.72l-162.389334 162.389333-162.517333-162.389333a44.330667 44.330667 0 1 0-62.72 62.72l162.389333 162.389333-162.389333 162.474667a44.330667 44.330667 0 1 0 62.72 62.72l162.389333-162.346667 162.389334 162.389334a44.330667 44.330667 0 1 0 62.72-62.72l-162.261334-162.56z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "14",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C233.386667 0 0 225.877333 0 512s225.877333 512 512 512 512-225.877333 512-512S790.613333 0 512 0z" fill="#6D768D"></path><path d="M726.144 311.210667l-277.333333 305.066666-124.8-124.8c-13.866667-13.866667-41.6-13.866667-55.466667 0-13.866667 13.866667-13.866667 41.6 0 55.466667l159.445333 152.533333c13.866667 13.866667 41.6 13.866667 55.466667 0l305.066667-332.8c13.866667-13.866667 13.866667-41.6 0-55.466666-20.778667-13.866667-48.512-13.866667-62.378667 0z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "15",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M541.952 755.626667a40.618667 40.618667 0 0 1-29.824 12.373333 41.344 41.344 0 0 1-30.122667-12.373333 40.106667 40.106667 0 0 1-12.672-30.122667c0-11.605333 4.096-21.845333 12.672-30.122667a40.405333 40.405333 0 0 1 30.122667-12.714666c11.605333 0 21.546667 4.138667 29.824 12.714666a40.32 40.32 0 0 1 12.714667 30.122667c0 11.861333-4.096 21.76-12.714667 30.122667zM450.986667 241.28A77.866667 77.866667 0 0 1 512.256 213.333333c24.874667 0 45.354667 8.917333 61.354667 27.946667 15.488 18.432 23.722667 41.685333 23.722666 69.674667 0 23.765333-33.152 200.533333-44.672 329.045333h-80.128C463.146667 511.402667 426.666667 334.677333 426.666667 310.954667c0-27.392 8.277333-50.645333 24.32-69.674667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "16",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.794667 0 512 0z" fill="#6D768D"></path><path d="M490.666667 682.666667a64 64 0 1 1 0 128 64 64 0 0 1 0-128z m13.994666-490.752c61.397333 0 112.341333 14.634667 153.002667 43.946666 40.533333 29.269333 60.885333 72.618667 60.885333 130.133334 0 35.242667-12.373333 64.938667-29.952 89.045333-10.282667 14.677333-33.664 33.408-62.890666 56.192l-32.426667 22.357333c-15.701333 12.202667-29.696 26.453333-34.858667 42.666667-1.706667 5.546667-3.072 14.677333-3.968 24.533333-0.426667 4.949333-4.864 15.018667-15.232 15.018667h-83.328c-13.568 0-15.957333-10.581333-15.744-15.786667 1.493333-34.005333 4.608-64.213333 18.474667-80.469333 28.074667-32.896 91.904-73.813333 91.904-73.813333a104.106667 104.106667 0 0 0 23.552-24.021334c10.837333-14.933333 19.797333-31.317333 19.797333-49.237333 0-20.565333-6.016-39.338667-18.090666-56.32-12.032-16.938667-34.090667-25.386667-66.005334-25.386667-31.445333 0-53.76 10.410667-66.901333 31.274667-9.685333 15.445333-15.786667 29.610667-18.346667 45.013333-0.853333 5.461333-4.394667 16.981333-16.042666 16.981334H327.210667c-17.322667 0-21.12-11.221333-20.650667-16.64 6.272-68.138667 32.896-114.688 80-144.597334 32-20.565333 71.381333-30.890667 118.101333-30.890666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "17",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M336.256 410.026667H253.312a40.021333 40.021333 0 0 0-39.850667 43.264l23.296 278.101333c1.706667 20.693333 19.072 36.608 39.850667 36.608h59.648c11.050667 0 20.010667-8.96 20.010667-19.968v-318.037333a19.968 19.968 0 0 0-20.010667-19.968z m434.432 0h-178.944C653.312 182.314667 548.949333 170.666667 548.949333 170.666667c-44.288 0-35.114667 34.986667-38.442666 40.832 0 84.48-68.010667 155.093333-101.034667 184.362666a39.552 39.552 0 0 0-13.226667 29.653334v322.56c0 11.008 8.96 19.925333 20.010667 19.925333h233.728c30.378667 0 58.154667-17.152 71.68-44.373333 18.176-36.736 40.448-90.112 54.656-133.973334 13.781333-42.410667 26.24-94.976 33.578667-131.968a39.850667 39.850667 0 0 0-39.253334-47.658666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "18",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M796.16 413.909333c-31.146667-0.298667-115.626667-0.085333-146.858667-0.085333h-158.464c8.533333-7.68 15.914667-14.506667 23.594667-20.906667 29.781333-24.874667 25.813333-71.082667-14.208-88.874666-22.954667-10.24-44.970667-5.632-64 11.52-34.944 31.274667-69.632 62.677333-104.277333 93.994666a15.488 15.488 0 0 1-11.178667 4.437334c-11.221333-0.085333-26.88-0.128-46.933333-0.170667a17.066667 17.066667 0 0 0-17.109334 17.066667L256 719.701333a17.066667 17.066667 0 0 0 17.066667 17.152l49.578666-0.085333c3.968 0 7.466667 0.768 10.88 2.602667 15.829333 8.832 31.701333 17.493333 47.616 26.24a18.133333 18.133333 0 0 0 9.301334 2.346666h168.405333c6.186667 0 11.946667-0.981333 17.834667-2.56 29.44-7.253333 40.021333-30.293333 38.528-52.565333-0.768-9.728-4.266667-18.346667-9.984-26.24 19.626667-5.76 35.114667-16.213333 42.112-36.096 7.125333-20.394667 1.621333-38.4-12.672-53.333333 28.16-19.754667 34.858667-44.672 18.645333-75.648h140.458667c6.570667 0 13.013333-0.597333 19.370666-2.645334 31.957333-9.813333 48.810667-42.88 35.626667-71.552-10.154667-22.186667-28.629333-33.152-52.608-33.450666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "19",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M270.506667 413.909333c31.146667-0.298667 115.626667-0.085333 146.858666-0.085333h158.464c-8.533333-7.68-15.914667-14.506667-23.594666-20.906667-29.781333-24.874667-25.813333-71.082667 14.208-88.874666 22.954667-10.24 44.970667-5.632 64 11.52 34.944 31.274667 69.632 62.677333 104.277333 93.994666 3.413333 2.986667 6.528 4.437333 11.178667 4.437334 11.221333-0.085333 26.88-0.128 46.933333-0.170667a17.066667 17.066667 0 0 1 17.109333 17.066667l0.682667 288.853333a17.066667 17.066667 0 0 1-17.066667 17.152l-49.578666-0.085333a22.101333 22.101333 0 0 0-10.88 2.602666c-15.829333 8.832-31.701333 17.493333-47.616 26.24a18.133333 18.133333 0 0 1-9.301334 2.346667h-168.405333a68.693333 68.693333 0 0 1-17.834667-2.56c-29.44-7.253333-40.021333-30.293333-38.528-52.565333 0.768-9.728 4.266667-18.346667 9.984-26.24-19.626667-5.76-35.114667-16.213333-42.112-36.096-7.125333-20.394667-1.621333-38.4 12.672-53.333334-28.16-19.754667-34.858667-44.672-18.645333-75.648H272.853333c-6.570667 0-13.013333-0.597333-19.370666-2.645333-31.957333-9.813333-48.810667-42.88-35.626667-71.552 10.154667-22.186667 28.629333-33.152 52.608-33.450667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "20",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M667.733333 480.128H400v-111.36a97.706667 97.706667 0 0 1 97.621333-97.621333 97.706667 97.706667 0 0 1 97.578667 97.621333 28.885333 28.885333 0 0 0 57.813333 0A155.605333 155.605333 0 0 0 497.621333 213.333333a155.605333 155.605333 0 0 0-155.392 155.434667v111.36h-14.677333A28.885333 28.885333 0 0 0 298.666667 509.013333v292.010667a28.885333 28.885333 0 0 0 28.885333 28.885333h340.138667a28.885333 28.885333 0 0 0 28.928-28.885333V509.013333a28.885333 28.885333 0 0 0-28.928-28.885333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "21",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M400.042667 437.461333v-111.36a97.706667 97.706667 0 0 1 97.621333-97.621333 97.706667 97.706667 0 0 1 97.578667 97.621333 28.885333 28.885333 0 0 0 57.813333 0A155.605333 155.605333 0 0 0 497.621333 170.666667a155.605333 155.605333 0 0 0-155.392 155.434666v111.36h-14.677333A28.885333 28.885333 0 0 0 298.666667 466.346667v292.010666a28.885333 28.885333 0 0 0 28.885333 28.885334h340.138667a28.885333 28.885333 0 0 0 28.928-28.885334V466.346667a28.885333 28.885333 0 0 0-28.928-28.885334H400.042667z" fill="#FFFFFF"></path><path d="M595.242667 437.461333v-111.36a97.706667 97.706667 0 0 0-97.621334-97.621333 97.706667 97.706667 0 0 0-97.578666 97.621333 28.885333 28.885333 0 0 1-57.813334 0A155.605333 155.605333 0 0 1 497.621333 170.666667a155.605333 155.605333 0 0 1 155.434667 155.434666v111.36h14.634667c16 0 28.928 12.928 28.928 28.885334v292.010666a28.885333 28.885333 0 0 1-28.928 28.885334H327.552A28.885333 28.885333 0 0 1 298.666667 758.357333V466.346667c0-15.957333 12.928-28.885333 28.885333-28.885334h267.690667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "22",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M511.999787 512.000213m-511.999787 0a511.999787 511.999787 0 1 0 1023.999573 0 511.999787 511.999787 0 1 0-1023.999573 0Z" fill="#6D768D"></path><path d="M381.354508 364.586941c0 54.015977 29.013321 103.935957 75.946635 130.986613a152.53327 152.53327 0 0 0 151.935936 0 151.12527 151.12527 0 0 0 75.946636-130.986613A151.594604 151.594604 0 0 0 533.333111 213.333671a151.594604 151.594604 0 0 0-151.89327 151.25327zM660.479725 498.901552a185.258589 185.258589 0 0 1-127.146614 50.346646c-49.066646 0-93.866628-19.199992-127.06128-50.346646C317.141201 544.853533 255.999893 637.440161 255.999893 744.106783c0 13.183995 10.709329 23.850657 23.978657 23.850657h506.709122a23.893323 23.893323 0 0 0 23.978657-23.893323c0-106.538622-61.098641-199.25325-150.186604-245.205232z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "23",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M445.610667 401.578667a129.322667 129.322667 0 1 0 258.645333 0 129.322667 129.322667 0 0 0-258.645333 0z m237.568 114.901333a157.354667 157.354667 0 0 1-216.362667 0 236.373333 236.373333 0 0 0-127.957333 209.706667c0 11.264 9.130667 20.394667 20.394666 20.394666h431.402667a20.394667 20.394667 0 0 0 20.394667-20.394666 236.373333 236.373333 0 0 0-127.872-209.706667zM409.813333 401.578667c0-40.362667 14.592-77.397333 38.698667-106.112a112.725333 112.725333 0 0 0-29.013333-3.925334 112.64 112.64 0 0 0-112.426667 112.469334 112.64 112.64 0 0 0 144.853333 107.648 164.693333 164.693333 0 0 1-42.112-110.08z m-18.602666 136.704a136.533333 136.533333 0 0 1-65.706667-34.474667 205.44 205.44 0 0 0-111.232 182.4c0 9.813333 7.936 17.706667 17.706667 17.706667H303.36a273.621333 273.621333 0 0 1 87.893333-165.632z" fill="#FFFFFF"></path></svg>`
      }
    ]
  }
];
var getNodeIconListIcon = (name, extendIconList = []) => {
  let arr = name.split("_");
  const iconList = mergerIconList([...nodeIconList, ...extendIconList]);
  let typeData = iconList.find((item) => {
    return item.type === arr[0];
  });
  if (typeData) {
    let typeName = typeData.list.find((item) => {
      return item.name === arr[1];
    });
    if (typeName) {
      return typeName.icon;
    }
    return "";
  } else {
    return "";
  }
};
var icons_default = {
  hyperlink,
  note,
  attachment,
  nodeIconList,
  getNodeIconListIcon
};

// node_modules/simple-mind-map/src/core/render/node/nodeCreateContents.js
var defaultTagStyle = {
  radius: 3,
  // 标签矩形的圆角大小
  fontSize: 12,
  // 字号，建议文字高度不要大于height
  fill: "",
  // 标签矩形的背景颜色
  height: 20,
  // 标签矩形的高度
  paddingX: 8
  // 水平内边距，如果设置了width，将忽略该配置
  //width: 30 // 标签矩形的宽度，如果不设置，默认以文字的宽度+paddingX*2为宽度
};
function createImgNode() {
  const img = this.getData("image");
  if (!img) {
    return;
  }
  const imgSize = this.getImgShowSize();
  const node = new Image2().load(img).size(...imgSize);
  const { defaultNodeImage } = this.mindMap.opt;
  if (defaultNodeImage) {
    const imgEl = new Image();
    imgEl.onerror = () => {
      node.load(defaultNodeImage);
    };
    imgEl.src = img;
  }
  if (this.getData("imageTitle")) {
    node.attr("title", this.getData("imageTitle"));
  }
  node.on("dblclick", (e) => {
    this.mindMap.emit("node_img_dblclick", this, e);
  });
  node.on("mouseenter", (e) => {
    this.mindMap.emit("node_img_mouseenter", this, node, e);
  });
  node.on("mouseleave", (e) => {
    this.mindMap.emit("node_img_mouseleave", this, node, e);
  });
  node.on("mousemove", (e) => {
    this.mindMap.emit("node_img_mousemove", this, node, e);
  });
  return {
    node,
    width: imgSize[0],
    height: imgSize[1]
  };
}
function getImgShowSize() {
  const { custom, width, height } = this.getData("imageSize");
  if (custom) return [width, height];
  return resizeImgSize(
    width,
    height,
    this.mindMap.themeConfig.imgMaxWidth,
    this.mindMap.themeConfig.imgMaxHeight
  );
}
function createIconNode() {
  let _data = this.getData();
  if (!_data.icon || _data.icon.length <= 0) {
    return [];
  }
  let iconSize = this.mindMap.themeConfig.iconSize;
  return _data.icon.map((item) => {
    let src = icons_default.getNodeIconListIcon(
      item,
      this.mindMap.opt.iconList || []
    );
    let node = null;
    if (/^<svg/.test(src)) {
      node = SVG(src);
    } else {
      node = new Image2().load(src);
    }
    node.size(iconSize, iconSize);
    node.on("click", (e) => {
      this.mindMap.emit("node_icon_click", this, item, e, node);
    });
    node.on("mouseenter", (e) => {
      this.mindMap.emit("node_icon_mouseenter", this, item, e, node);
    });
    node.on("mouseleave", (e) => {
      this.mindMap.emit("node_icon_mouseleave", this, item, e, node);
    });
    return {
      node,
      width: iconSize,
      height: iconSize
    };
  });
}
function createRichTextNode() {
  const { textAutoWrapWidth } = this.mindMap.opt;
  let g = new G();
  let recoverText = false;
  if (this.getData("resetRichText")) {
    delete this.nodeData.data.resetRichText;
    recoverText = true;
  }
  if ([CONSTANTS.CHANGE_THEME].includes(this.mindMap.renderer.renderSource)) {
    if (!this.hasCustomStyle()) {
      recoverText = true;
    }
  }
  let text = this.getData("text");
  if (recoverText && !isUndef(text)) {
    let isRichText = checkIsRichText(text);
    let style = this.style.createStyleText();
    if (isRichText) {
      text = removeHtmlStyle(text);
      let _text = text;
      text = addHtmlStyle(text, "span", style);
      if (text === _text) {
        text = addHtmlStyle(text, "strong", style);
      }
    } else {
      text = `<p><span style="${style}">${text}</span></p>`;
    }
    this.setData({
      text
    });
  }
  let html = `<div>${this.getData("text")}</div>`;
  if (!this.mindMap.commonCaches.measureRichtextNodeTextSizeEl) {
    this.mindMap.commonCaches.measureRichtextNodeTextSizeEl = document.createElement("div");
    this.mindMap.commonCaches.measureRichtextNodeTextSizeEl.style.position = "fixed";
    this.mindMap.commonCaches.measureRichtextNodeTextSizeEl.style.left = "-999999px";
    this.mindMap.el.appendChild(
      this.mindMap.commonCaches.measureRichtextNodeTextSizeEl
    );
  }
  let div = this.mindMap.commonCaches.measureRichtextNodeTextSizeEl;
  div.innerHTML = html;
  let el = div.children[0];
  el.classList.add("smm-richtext-node-wrap");
  addXmlns(el);
  el.style.maxWidth = textAutoWrapWidth + "px";
  let { width, height } = el.getBoundingClientRect();
  if (height <= 0) {
    div.innerHTML = "<p>abc123我和你</p>";
    let elTmp = div.children[0];
    elTmp.classList.add("smm-richtext-node-wrap");
    height = elTmp.getBoundingClientRect().height;
    div.innerHTML = html;
  }
  width = Math.min(Math.ceil(width) + 1, textAutoWrapWidth);
  height = Math.ceil(height);
  g.attr("data-width", width);
  g.attr("data-height", height);
  const foreignObject = createForeignObjectNode({
    el: div.children[0],
    width,
    height
  });
  g.add(foreignObject);
  return {
    node: g,
    nodeContent: foreignObject,
    width,
    height
  };
}
function createTextNode() {
  if (this.getData("richText")) {
    return this.createRichTextNode();
  }
  if (this.getData("resetRichText")) {
    delete this.nodeData.data.resetRichText;
  }
  let g = new G();
  let fontSize = this.getStyle("fontSize", false);
  let lineHeight = this.getStyle("lineHeight", false);
  let textStyle = this.style.getTextFontStyle();
  let textArr = [];
  if (!isUndef(this.getData("text"))) {
    textArr = String(this.getData("text")).split(/\n/gim);
  }
  let maxWidth = this.mindMap.opt.textAutoWrapWidth;
  let isMultiLine = false;
  textArr.forEach((item, index) => {
    let arr = item.split("");
    let lines = [];
    let line = [];
    while (arr.length) {
      let str = arr.shift();
      let text = [...line, str].join("");
      if (measureText(text, textStyle).width <= maxWidth) {
        line.push(str);
      } else {
        lines.push(line.join(""));
        line = [str];
      }
    }
    if (line.length > 0) {
      lines.push(line.join(""));
    }
    if (lines.length > 1) {
      isMultiLine = true;
    }
    textArr[index] = lines.join("\n");
  });
  textArr = textArr.join("\n").split(/\n/gim);
  textArr.forEach((item, index) => {
    let node = new Text().text(item);
    this.style.text(node);
    node.y(fontSize * lineHeight * index);
    g.add(node);
  });
  let { width, height } = g.bbox();
  width = Math.min(Math.ceil(width), maxWidth);
  height = Math.ceil(height);
  g.attr("data-width", width);
  g.attr("data-height", height);
  g.attr("data-ismultiLine", isMultiLine || textArr.length > 1);
  return {
    node: g,
    width,
    height
  };
}
function createHyperlinkNode() {
  let { hyperlink: hyperlink2, hyperlinkTitle } = this.getData();
  if (!hyperlink2) {
    return;
  }
  const { customHyperlinkJump } = this.mindMap.opt;
  let iconSize = this.mindMap.themeConfig.iconSize;
  let node = new SVG().size(iconSize, iconSize);
  let a = new A().to(hyperlink2).target("_blank");
  a.node.addEventListener("click", (e) => {
    if (typeof customHyperlinkJump === "function") {
      e.preventDefault();
      customHyperlinkJump(hyperlink2, this);
    }
  });
  if (hyperlinkTitle) {
    node.add(SVG(`<title>${hyperlinkTitle}</title>`));
  }
  a.rect(iconSize, iconSize).fill({ color: "transparent" });
  let iconNode = SVG(icons_default.hyperlink).size(iconSize, iconSize);
  this.style.iconNode(iconNode);
  a.add(iconNode);
  node.add(a);
  return {
    node,
    width: iconSize,
    height: iconSize
  };
}
function createTagNode() {
  const tagData = this.getData("tag");
  if (!tagData || tagData.length <= 0) {
    return [];
  }
  let { maxTag, tagsColorMap } = this.mindMap.opt;
  tagsColorMap = tagsColorMap || {};
  const nodes = [];
  tagData.slice(0, maxTag).forEach((item, index) => {
    let str = "";
    let style = {
      ...defaultTagStyle
    };
    if (typeof item === "string") {
      str = item;
    } else {
      str = item.text;
      style = { ...defaultTagStyle, ...item.style };
    }
    const hasCustomWidth = typeof style.width !== "undefined";
    const tag = new G();
    tag.on("click", () => {
      this.mindMap.emit("node_tag_click", this, item, index, tag);
    });
    const text = new Text().text(str);
    this.style.tagText(text, style);
    const { width: textWidth, height: textHeight } = text.bbox();
    const rectWidth = hasCustomWidth ? style.width : textWidth + style.paddingX * 2;
    const maxWidth = hasCustomWidth ? Math.max(rectWidth, textWidth) : rectWidth;
    const maxHeight = Math.max(style.height, textHeight);
    if (hasCustomWidth) {
      text.x((maxWidth - textWidth) / 2);
    } else {
      text.x(hasCustomWidth ? 0 : style.paddingX);
    }
    text.cy(-maxHeight / 2);
    const rect = new Rect().size(rectWidth, style.height).cy(-maxHeight / 2);
    if (hasCustomWidth) {
      rect.x((maxWidth - rectWidth) / 2);
    }
    this.style.tagRect(rect, {
      ...style,
      fill: style.fill || // 优先节点自身配置
      tagsColorMap[text.node.textContent] || // 否则尝试从实例化选项tagsColorMap映射中获取颜色
      generateColorByContent(text.node.textContent)
      // 否则按照标签内容生成
    });
    tag.add(rect).add(text);
    nodes.push({
      node: tag,
      width: maxWidth,
      height: maxHeight
    });
  });
  return nodes;
}
function createNoteNode() {
  if (!this.getData("note")) {
    return null;
  }
  let iconSize = this.mindMap.themeConfig.iconSize;
  let node = new SVG().attr("cursor", "pointer").addClass("smm-node-note").size(iconSize, iconSize);
  node.add(new Rect().size(iconSize, iconSize).fill({ color: "transparent" }));
  let iconNode = SVG(icons_default.note).size(iconSize, iconSize);
  this.style.iconNode(iconNode);
  node.add(iconNode);
  if (!this.mindMap.opt.customNoteContentShow) {
    if (!this.noteEl) {
      this.noteEl = document.createElement("div");
      this.noteEl.style.cssText = `
          position: fixed;
          padding: 10px;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgb(0 0 0 / 10%);
          display: none;
          background-color: #fff;
          z-index: ${this.mindMap.opt.nodeNoteTooltipZIndex}
      `;
      const targetNode = this.mindMap.opt.customInnerElsAppendTo || document.body;
      targetNode.appendChild(this.noteEl);
    }
    this.noteEl.innerText = this.getData("note");
  }
  node.on("mouseover", () => {
    const { left, top } = this.getNoteContentPosition();
    if (!this.mindMap.opt.customNoteContentShow) {
      this.noteEl.style.left = left + "px";
      this.noteEl.style.top = top + "px";
      this.noteEl.style.display = "block";
    } else {
      this.mindMap.opt.customNoteContentShow.show(
        this.getData("note"),
        left,
        top,
        this
      );
    }
  });
  node.on("mouseout", () => {
    if (!this.mindMap.opt.customNoteContentShow) {
      this.noteEl.style.display = "none";
    } else {
      this.mindMap.opt.customNoteContentShow.hide();
    }
  });
  node.on("click", (e) => {
    this.mindMap.emit("node_note_click", this, e, node);
  });
  return {
    node,
    width: iconSize,
    height: iconSize
  };
}
function createAttachmentNode() {
  const { attachmentUrl, attachmentName } = this.getData();
  if (!attachmentUrl) {
    return;
  }
  const iconSize = this.mindMap.themeConfig.iconSize;
  const node = new SVG().attr("cursor", "pointer").size(iconSize, iconSize);
  if (attachmentName) {
    node.add(SVG(`<title>${attachmentName}</title>`));
  }
  node.add(new Rect().size(iconSize, iconSize).fill({ color: "transparent" }));
  const iconNode = SVG(icons_default.attachment).size(iconSize, iconSize);
  this.style.iconNode(iconNode);
  node.add(iconNode);
  node.on("click", (e) => {
    this.mindMap.emit("node_attachmentClick", this, e, node);
  });
  node.on("contextmenu", (e) => {
    this.mindMap.emit("node_attachmentContextmenu", this, e, node);
  });
  return {
    node,
    width: iconSize,
    height: iconSize
  };
}
function getNoteContentPosition() {
  const iconSize = this.mindMap.themeConfig.iconSize;
  const { scaleY } = this.mindMap.view.getTransformData().transform;
  const iconSizeAddScale = iconSize * scaleY;
  let { left, top } = this._noteData.node.node.getBoundingClientRect();
  top += iconSizeAddScale;
  return {
    left,
    top
  };
}
function measureCustomNodeContentSize(content) {
  if (!this.mindMap.commonCaches.measureCustomNodeContentSizeEl) {
    this.mindMap.commonCaches.measureCustomNodeContentSizeEl = document.createElement("div");
    this.mindMap.commonCaches.measureCustomNodeContentSizeEl.style.cssText = `
      position: fixed;
      left: -99999px;
      top: -99999px;
    `;
    this.mindMap.el.appendChild(
      this.mindMap.commonCaches.measureCustomNodeContentSizeEl
    );
  }
  this.mindMap.commonCaches.measureCustomNodeContentSizeEl.innerHTML = "";
  this.mindMap.commonCaches.measureCustomNodeContentSizeEl.appendChild(content);
  let rect = this.mindMap.commonCaches.measureCustomNodeContentSizeEl.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height
  };
}
function isUseCustomNodeContent() {
  return !!this._customNodeContent;
}
var nodeCreateContents_default = {
  createImgNode,
  getImgShowSize,
  createIconNode,
  createRichTextNode,
  createTextNode,
  createHyperlinkNode,
  createTagNode,
  createNoteNode,
  createAttachmentNode,
  getNoteContentPosition,
  measureCustomNodeContentSize,
  isUseCustomNodeContent
};

// node_modules/simple-mind-map/src/core/render/node/nodeExpandBtnPlaceholderRect.js
function renderExpandBtnPlaceholderRect() {
  if (!this.nodeData.children || this.nodeData.children.length <= 0 || this.isRoot) {
    return;
  }
  const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
  if (!alwaysShowExpandBtn && !notShowExpandBtn) {
    let { width, height } = this;
    if (!this._unVisibleRectRegionNode) {
      this._unVisibleRectRegionNode = new Rect();
      this._unVisibleRectRegionNode.fill({
        color: "transparent"
      });
    }
    this.group.add(this._unVisibleRectRegionNode);
    this.renderer.layout.renderExpandBtnRect(
      this._unVisibleRectRegionNode,
      this.expandBtnSize,
      width,
      height,
      this
    );
  }
}
function clearExpandBtnPlaceholderRect() {
  if (!this._unVisibleRectRegionNode) {
    return;
  }
  this._unVisibleRectRegionNode.remove();
  this._unVisibleRectRegionNode = null;
}
function updateExpandBtnPlaceholderRect() {
  if (this.needRerenderExpandBtnPlaceholderRect) {
    this.needRerenderExpandBtnPlaceholderRect = false;
    this.renderExpandBtnPlaceholderRect();
  }
  if (this.nodeData.children && this.nodeData.children.length > 0) {
    if (!this._unVisibleRectRegionNode) {
      this.renderExpandBtnPlaceholderRect();
    }
  } else {
    if (this._unVisibleRectRegionNode) {
      this.clearExpandBtnPlaceholderRect();
    }
  }
}
var nodeExpandBtnPlaceholderRect_default = {
  renderExpandBtnPlaceholderRect,
  clearExpandBtnPlaceholderRect,
  updateExpandBtnPlaceholderRect
};

// node_modules/simple-mind-map/src/core/render/node/nodeCooperate.js
function createUserListNode() {
  if (!this.mindMap.cooperate) return;
  this._userListGroup = new G();
  this.group.add(this._userListGroup);
}
function createTextAvatar(item) {
  const { avatarSize, fontSize } = this.mindMap.opt.cooperateStyle;
  const g = new G();
  const str = item.isMore ? item.name : String(item.name)[0];
  const circle = new Circle().size(avatarSize, avatarSize);
  circle.fill({
    color: item.color || generateColorByContent(str)
  });
  const text = new Text().text(str).fill({
    color: "#fff"
  }).css({
    "font-size": fontSize
  }).dx(-fontSize / 2).dy((avatarSize - fontSize) / 2);
  g.add(circle).add(text);
  return g;
}
function createImageAvatar(item) {
  const { avatarSize } = this.mindMap.opt.cooperateStyle;
  return new Image2().load(item.avatar).size(avatarSize, avatarSize);
}
function updateUserListNode() {
  if (!this._userListGroup) return;
  const { avatarSize } = this.mindMap.opt.cooperateStyle;
  this._userListGroup.clear();
  const length = this.userList.length;
  const maxShowCount = Math.floor(this.width / avatarSize);
  const list = [];
  if (length > maxShowCount) {
    list.push(...this.userList.slice(0, maxShowCount - 1), {
      isMore: true,
      name: "+" + (length - maxShowCount + 1)
    });
  } else {
    list.push(...this.userList);
  }
  list.forEach((item, index) => {
    let node = null;
    if (item.avatar) {
      node = this.createImageAvatar(item);
    } else {
      node = this.createTextAvatar(item);
    }
    node.on("click", (e) => {
      this.mindMap.emit("node_cooperate_avatar_click", item, this, node, e);
    });
    node.on("mouseenter", (e) => {
      this.mindMap.emit("node_cooperate_avatar_mouseenter", item, this, node, e);
    });
    node.on("mouseleave", (e) => {
      this.mindMap.emit("node_cooperate_avatar_mouseleave", item, this, node, e);
    });
    node.x(index * avatarSize).cy(-avatarSize / 2);
    this._userListGroup.add(node);
  });
}
function addUser(userInfo) {
  if (this.userList.find((item) => {
    return item.id == userInfo.id;
  }))
    return;
  this.userList.push(userInfo);
  this.updateUserListNode();
}
function removeUser(userInfo) {
  const index = this.userList.findIndex((item) => {
    return item.id == userInfo.id;
  });
  if (index === -1) return;
  this.userList.splice(index, 1);
  this.updateUserListNode();
}
function emptyUser() {
  this.userList = [];
  this.updateUserListNode();
}
var nodeCooperate_default = {
  createUserListNode,
  updateUserListNode,
  createTextAvatar,
  createImageAvatar,
  addUser,
  removeUser,
  emptyUser
};

// node_modules/simple-mind-map/src/core/render/node/Node.js
var Node = class _Node {
  //  构造函数
  constructor(opt = {}) {
    this.opt = opt;
    this.nodeData = this.handleData(opt.data || {});
    this.uid = opt.uid;
    this.mindMap = opt.mindMap;
    this.renderer = opt.renderer;
    this.draw = this.mindMap.draw;
    this.nodeDraw = this.mindMap.nodeDraw;
    this.lineDraw = this.mindMap.lineDraw;
    this.style = new Style_default(this);
    this.shapeInstance = new Shape(this);
    this.shapePadding = {
      paddingX: 0,
      paddingY: 0
    };
    this.isRoot = opt.isRoot === void 0 ? false : opt.isRoot;
    this.isGeneralization = opt.isGeneralization === void 0 ? false : opt.isGeneralization;
    this.generalizationBelongNode = null;
    this.layerIndex = opt.layerIndex === void 0 ? 0 : opt.layerIndex;
    this.width = opt.width || 0;
    this.height = opt.height || 0;
    this._left = opt.left || 0;
    this._top = opt.top || 0;
    this.customLeft = opt.data.data.customLeft || void 0;
    this.customTop = opt.data.data.customTop || void 0;
    this.isDrag = false;
    this.parent = opt.parent || null;
    this.children = opt.children || [];
    this.userList = [];
    this.group = null;
    this.shapeNode = null;
    this.hoverNode = null;
    this._customNodeContent = null;
    this._imgData = null;
    this._iconData = null;
    this._textData = null;
    this._hyperlinkData = null;
    this._tagData = null;
    this._noteData = null;
    this.noteEl = null;
    this.noteContentIsShow = false;
    this._attachmentData = null;
    this._numberData = null;
    this._prefixData = null;
    this._postfixData = null;
    this._expandBtn = null;
    this._lastExpandBtnType = null;
    this._showExpandBtn = false;
    this._openExpandNode = null;
    this._closeExpandNode = null;
    this._fillExpandNode = null;
    this._userListGroup = null;
    this._lines = [];
    this._generalizationList = [];
    this._unVisibleRectRegionNode = null;
    this._isMouseenter = false;
    this._rectInfo = {
      imgContentWidth: 0,
      imgContentHeight: 0,
      textContentWidth: 0,
      textContentHeight: 0
    };
    this._generalizationNodeWidth = 0;
    this._generalizationNodeHeight = 0;
    this.number = opt.number || "";
    this.textContentItemMargin = this.mindMap.opt.textContentMargin;
    this.blockContentMargin = this.mindMap.opt.imgTextMargin;
    this.expandBtnSize = this.mindMap.opt.expandBtnSize;
    this.isMultipleChoice = false;
    this.needLayout = false;
    this.isHide = false;
    const proto = Object.getPrototypeOf(this);
    if (!proto.bindEvent) {
      Object.keys(nodeGeneralization_default).forEach((item) => {
        proto[item] = nodeGeneralization_default[item];
      });
      Object.keys(nodeExpandBtn_default).forEach((item) => {
        proto[item] = nodeExpandBtn_default[item];
      });
      Object.keys(nodeExpandBtnPlaceholderRect_default).forEach((item) => {
        proto[item] = nodeExpandBtnPlaceholderRect_default[item];
      });
      Object.keys(nodeCommandWraps_default).forEach((item) => {
        proto[item] = nodeCommandWraps_default[item];
      });
      Object.keys(nodeCreateContents_default).forEach((item) => {
        proto[item] = nodeCreateContents_default[item];
      });
      if (this.mindMap.cooperate) {
        Object.keys(nodeCooperate_default).forEach((item) => {
          proto[item] = nodeCooperate_default[item];
        });
      }
      proto.bindEvent = true;
    }
    this.getSize();
  }
  // 支持自定义位置
  get left() {
    return this.customLeft || this._left;
  }
  set left(val) {
    this._left = val;
  }
  get top() {
    return this.customTop || this._top;
  }
  set top(val) {
    this._top = val;
  }
  //  复位部分布局时会重新设置的数据
  reset() {
    this.children = [];
    this.parent = null;
    this.isRoot = false;
    this.layerIndex = 0;
    this.left = 0;
    this.top = 0;
  }
  // 节点被删除时需要复位的数据
  resetWhenDelete() {
    this._isMouseenter = false;
  }
  //  处理数据
  handleData(data) {
    data.data.expand = data.data.expand === false ? false : true;
    data.data.isActive = data.data.isActive === true ? true : false;
    data.children = data.children || [];
    return data;
  }
  //  创建节点的各个内容对象数据
  createNodeData() {
    let {
      isUseCustomNodeContent: isUseCustomNodeContent2,
      customCreateNodeContent,
      createNodePrefixContent,
      createNodePostfixContent
    } = this.mindMap.opt;
    if (isUseCustomNodeContent2 && customCreateNodeContent) {
      this._customNodeContent = customCreateNodeContent(this);
    }
    if (this._customNodeContent) {
      addXmlns(this._customNodeContent);
      return;
    }
    this._imgData = this.createImgNode();
    this._iconData = this.createIconNode();
    this._textData = this.createTextNode();
    this._hyperlinkData = this.createHyperlinkNode();
    this._tagData = this.createTagNode();
    this._noteData = this.createNoteNode();
    this._attachmentData = this.createAttachmentNode();
    if (this.mindMap.numbers) {
      this._numberData = this.mindMap.numbers.createNumberContent(this);
    }
    this._prefixData = createNodePrefixContent ? createNodePrefixContent(this) : null;
    if (this._prefixData && this._prefixData.el) {
      addXmlns(this._prefixData.el);
    }
    this._postfixData = createNodePostfixContent ? createNodePostfixContent(this) : null;
    if (this._postfixData && this._postfixData.el) {
      addXmlns(this._postfixData.el);
    }
  }
  //  计算节点的宽高
  getSize() {
    this.customLeft = this.getData("customLeft") || void 0;
    this.customTop = this.getData("customTop") || void 0;
    this.createNodeData();
    let { width, height } = this.getNodeRect();
    let changed = this.width !== width || this.height !== height;
    this.width = width;
    this.height = height;
    return changed;
  }
  //  计算节点尺寸信息
  getNodeRect() {
    if (this.isUseCustomNodeContent()) {
      let rect = this.measureCustomNodeContentSize(this._customNodeContent);
      return {
        width: rect.width,
        height: rect.height
      };
    }
    const { tagPosition } = this.mindMap.opt;
    const tagIsBottom = tagPosition === CONSTANTS.TAG_POSITION.BOTTOM;
    let imgContentWidth = 0;
    let imgContentHeight = 0;
    let textContentWidth = 0;
    let textContentHeight = 0;
    let tagContentWidth = 0;
    let tagContentHeight = 0;
    if (this._imgData) {
      this._rectInfo.imgContentWidth = imgContentWidth = this._imgData.width;
      this._rectInfo.imgContentHeight = imgContentHeight = this._imgData.height;
    }
    if (this._numberData) {
      textContentWidth += this._numberData.width;
      textContentHeight = Math.max(textContentHeight, this._numberData.height);
    }
    if (this._prefixData) {
      textContentWidth += this._prefixData.width;
      textContentHeight = Math.max(textContentHeight, this._prefixData.height);
    }
    if (this._iconData.length > 0) {
      textContentWidth += this._iconData.reduce((sum, cur) => {
        textContentHeight = Math.max(textContentHeight, cur.height);
        return sum += cur.width + this.textContentItemMargin;
      }, 0);
    }
    if (this._textData) {
      textContentWidth += this._textData.width;
      textContentHeight = Math.max(textContentHeight, this._textData.height);
    }
    if (this._hyperlinkData) {
      textContentWidth += this._hyperlinkData.width;
      textContentHeight = Math.max(
        textContentHeight,
        this._hyperlinkData.height
      );
    }
    if (this._tagData.length > 0) {
      let maxTagHeight = 0;
      const totalTagWidth = this._tagData.reduce((sum, cur) => {
        maxTagHeight = Math.max(maxTagHeight, cur.height);
        return sum += cur.width + this.textContentItemMargin;
      }, 0);
      if (tagIsBottom) {
        tagContentWidth = totalTagWidth;
        tagContentHeight = maxTagHeight;
      } else {
        textContentWidth += totalTagWidth;
        textContentHeight = Math.max(textContentHeight, maxTagHeight);
      }
    }
    if (this._noteData) {
      textContentWidth += this._noteData.width;
      textContentHeight = Math.max(textContentHeight, this._noteData.height);
    }
    if (this._attachmentData) {
      textContentWidth += this._attachmentData.width;
      textContentHeight = Math.max(
        textContentHeight,
        this._attachmentData.height
      );
    }
    if (this._postfixData) {
      textContentWidth += this._postfixData.width;
      textContentHeight = Math.max(textContentHeight, this._postfixData.height);
    }
    this._rectInfo.textContentWidth = textContentWidth;
    this._rectInfo.textContentHeight = textContentHeight;
    let margin = imgContentHeight > 0 && textContentHeight > 0 ? this.blockContentMargin : 0;
    let { paddingX, paddingY } = this.getPaddingVale();
    let _width = Math.max(imgContentWidth, textContentWidth);
    let _height = imgContentHeight + textContentHeight;
    if (tagIsBottom && tagContentHeight > 0 && textContentHeight > 0) {
      margin += this.blockContentMargin;
      _width = Math.max(_width, tagContentWidth);
      _height += tagContentHeight;
    }
    let { paddingX: shapePaddingX, paddingY: shapePaddingY } = this.shapeInstance.getShapePadding(_width, _height, paddingX, paddingY);
    this.shapePadding.paddingX = shapePaddingX;
    this.shapePadding.paddingY = shapePaddingY;
    const borderWidth = this.getBorderWidth();
    return {
      width: _width + paddingX * 2 + shapePaddingX * 2 + borderWidth,
      height: _height + paddingY * 2 + margin + shapePaddingY * 2 + borderWidth
    };
  }
  //  定位节点内容
  layout() {
    if (!this.group) return;
    this.group.clear();
    const { hoverRectPadding, tagPosition } = this.mindMap.opt;
    let { width, height, textContentItemMargin } = this;
    let { paddingY } = this.getPaddingVale();
    const halfBorderWidth = this.getBorderWidth() / 2;
    paddingY += this.shapePadding.paddingY + halfBorderWidth;
    this.shapeNode = this.shapeInstance.createShape();
    this.shapeNode.addClass("smm-node-shape");
    this.shapeNode.translate(halfBorderWidth, halfBorderWidth);
    this.style.shape(this.shapeNode);
    this.group.add(this.shapeNode);
    this.renderExpandBtnPlaceholderRect();
    if (this.createUserListNode) this.createUserListNode();
    if (this.isGeneralization && this.generalizationBelongNode) {
      this.group.addClass("generalization_" + this.generalizationBelongNode.uid);
    }
    const addHoverNode = () => {
      this.hoverNode = new Rect().size(width + hoverRectPadding * 2, height + hoverRectPadding * 2).x(-hoverRectPadding).y(-hoverRectPadding);
      this.hoverNode.addClass("smm-hover-node");
      this.style.hoverNode(this.hoverNode, width, height);
      this.group.add(this.hoverNode);
    };
    if (this.isUseCustomNodeContent()) {
      const foreignObject = createForeignObjectNode({
        el: this._customNodeContent,
        width,
        height
      });
      this.group.add(foreignObject);
      addHoverNode();
      return;
    }
    const tagIsBottom = tagPosition === CONSTANTS.TAG_POSITION.BOTTOM;
    const { textContentHeight } = this._rectInfo;
    let imgHeight = 0;
    if (this._imgData) {
      imgHeight = this._imgData.height;
      this.group.add(this._imgData.node);
      this._imgData.node.cx(width / 2).y(paddingY);
    }
    let textContentNested = new G();
    let textContentOffsetX = 0;
    if (this._numberData) {
      this._numberData.node.x(textContentOffsetX).y((textContentHeight - this._numberData.height) / 2);
      textContentNested.add(this._numberData.node);
      textContentOffsetX += this._numberData.width + textContentItemMargin;
    }
    if (this._prefixData) {
      const foreignObject = createForeignObjectNode({
        el: this._prefixData.el,
        width: this._prefixData.width,
        height: this._prefixData.height
      });
      foreignObject.x(textContentOffsetX).y((textContentHeight - this._prefixData.height) / 2);
      textContentNested.add(foreignObject);
      textContentOffsetX += this._prefixData.width + textContentItemMargin;
    }
    let iconNested = new G();
    if (this._iconData && this._iconData.length > 0) {
      let iconLeft = 0;
      this._iconData.forEach((item) => {
        item.node.x(textContentOffsetX + iconLeft).y((textContentHeight - item.height) / 2);
        iconNested.add(item.node);
        iconLeft += item.width + textContentItemMargin;
      });
      textContentNested.add(iconNested);
      textContentOffsetX += iconLeft;
    }
    if (this._textData) {
      const oldX = this._textData.node.attr("data-offsetx") || 0;
      this._textData.node.attr("data-offsetx", textContentOffsetX);
      (this._textData.nodeContent || this._textData.node).x(-oldX).x(textContentOffsetX).y((textContentHeight - this._textData.height) / 2);
      textContentNested.add(this._textData.node);
      textContentOffsetX += this._textData.width + textContentItemMargin;
    }
    if (this._hyperlinkData) {
      this._hyperlinkData.node.x(textContentOffsetX).y((textContentHeight - this._hyperlinkData.height) / 2);
      textContentNested.add(this._hyperlinkData.node);
      textContentOffsetX += this._hyperlinkData.width + textContentItemMargin;
    }
    let tagNested = new G();
    if (this._tagData && this._tagData.length > 0) {
      if (tagIsBottom) {
        let tagLeft = 0;
        this._tagData.forEach((item) => {
          item.node.x(tagLeft).y(0);
          tagNested.add(item.node);
          tagLeft += item.width + textContentItemMargin;
        });
        tagNested.cx(width / 2).y(
          paddingY + // 内边距
          imgHeight + // 图片高度
          textContentHeight + // 文本区域高度
          (imgHeight > 0 && textContentHeight > 0 ? this.blockContentMargin : 0) + // 图片和文本之间的间距
          this.blockContentMargin
          // 标签和文本之间的间距
        );
        this.group.add(tagNested);
      } else {
        let tagLeft = 0;
        this._tagData.forEach((item) => {
          item.node.x(textContentOffsetX + tagLeft).y((textContentHeight - item.height) / 2);
          tagNested.add(item.node);
          tagLeft += item.width + textContentItemMargin;
        });
        textContentNested.add(tagNested);
        textContentOffsetX += tagLeft;
      }
    }
    if (this._noteData) {
      this._noteData.node.x(textContentOffsetX).y((textContentHeight - this._noteData.height) / 2);
      textContentNested.add(this._noteData.node);
      textContentOffsetX += this._noteData.width;
    }
    if (this._attachmentData) {
      this._attachmentData.node.x(textContentOffsetX).y((textContentHeight - this._attachmentData.height) / 2);
      textContentNested.add(this._attachmentData.node);
      textContentOffsetX += this._attachmentData.width;
    }
    if (this._postfixData) {
      const foreignObject = createForeignObjectNode({
        el: this._postfixData.el,
        width: this._postfixData.width,
        height: this._postfixData.height
      });
      foreignObject.x(textContentOffsetX).y((textContentHeight - this._postfixData.height) / 2);
      textContentNested.add(foreignObject);
      textContentOffsetX += this._postfixData.width;
    }
    this.group.add(textContentNested);
    textContentNested.translate(
      width / 2 - textContentNested.bbox().width / 2,
      paddingY + // 内边距
      imgHeight + // 图片高度
      (imgHeight > 0 && textContentHeight > 0 ? this.blockContentMargin : 0)
      // 和图片的间距
    );
    addHoverNode();
    this.mindMap.emit("node_layout_end", this);
  }
  // 给节点绑定事件
  bindGroupEvent() {
    this.group.on("click", (e) => {
      this.mindMap.emit("node_click", this, e);
      if (this.isMultipleChoice) {
        e.stopPropagation();
        this.isMultipleChoice = false;
        return;
      }
      if (this.mindMap.opt.onlyOneEnableActiveNodeOnCooperate && this.userList.length > 0) {
        return;
      }
      this.active(e);
    });
    this.group.on("mousedown", (e) => {
      e.preventDefault();
      const {
        readonly,
        enableCtrlKeyNodeSelection,
        useLeftKeySelectionRightKeyDrag
      } = this.mindMap.opt;
      if (!readonly) {
        if (this.isRoot) {
          if (e.which === 3 && !useLeftKeySelectionRightKeyDrag) {
            e.stopPropagation();
          }
        } else {
          if (e.which !== 2) {
            e.stopPropagation();
          }
        }
      }
      if (!readonly && (e.ctrlKey || e.metaKey) && enableCtrlKeyNodeSelection) {
        this.isMultipleChoice = true;
        let isActive = this.getData("isActive");
        if (!isActive)
          this.mindMap.emit(
            "before_node_active",
            this,
            this.renderer.activeNodeList
          );
        this.mindMap.renderer[isActive ? "removeNodeFromActiveList" : "addNodeToActiveList"](this, true);
        this.renderer.emitNodeActiveEvent(isActive ? null : this);
      }
      this.mindMap.emit("node_mousedown", this, e);
    });
    this.group.on("mouseup", (e) => {
      if (!this.isRoot && e.which !== 2 && !this.mindMap.opt.readonly) {
        e.stopPropagation();
      }
      this.mindMap.emit("node_mouseup", this, e);
    });
    this.group.on("mouseenter", (e) => {
      if (this.isDrag) return;
      this._isMouseenter = true;
      this.showExpandBtn();
      if (this.isGeneralization) {
        this.handleGeneralizationMouseenter();
      }
      this.mindMap.emit("node_mouseenter", this, e);
    });
    this.group.on("mouseleave", (e) => {
      if (!this._isMouseenter) return;
      this._isMouseenter = false;
      this.hideExpandBtn();
      if (this.isGeneralization) {
        this.handleGeneralizationMouseleave();
      }
      this.mindMap.emit("node_mouseleave", this, e);
    });
    this.group.on("dblclick", (e) => {
      const { readonly, onlyOneEnableActiveNodeOnCooperate } = this.mindMap.opt;
      if (readonly || e.ctrlKey || e.metaKey) {
        return;
      }
      e.stopPropagation();
      if (onlyOneEnableActiveNodeOnCooperate && this.userList.length > 0) {
        return;
      }
      this.mindMap.emit("node_dblclick", this, e);
    });
    this.group.on("contextmenu", (e) => {
      const { readonly, useLeftKeySelectionRightKeyDrag } = this.mindMap.opt;
      if (readonly || e.ctrlKey) {
        return;
      }
      e.stopPropagation();
      e.preventDefault();
      if (this.mindMap.select && !useLeftKeySelectionRightKeyDrag && this.mindMap.select.hasSelectRange()) {
        return;
      }
      if (!(this.getData("isActive") && this.renderer.activeNodeList.length === 1)) {
        this.renderer.clearActiveNodeList();
        this.active(e);
      }
      this.mindMap.emit("node_contextmenu", e, this);
    });
  }
  //  激活节点
  active(e) {
    if (this.mindMap.opt.readonly) {
      return;
    }
    e && e.stopPropagation();
    if (this.getData("isActive")) {
      return;
    }
    this.mindMap.emit("before_node_active", this, this.renderer.activeNodeList);
    this.renderer.clearActiveNodeList();
    this.renderer.addNodeToActiveList(this, true);
    this.renderer.emitNodeActiveEvent(this);
  }
  // 取消激活该节点
  deactivate() {
    this.mindMap.renderer.removeNodeFromActiveList(this);
    this.mindMap.renderer.emitNodeActiveEvent();
  }
  //  更新节点
  update(forceRender) {
    if (!this.group) {
      return;
    }
    this.updateNodeActiveClass();
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!notShowExpandBtn) {
      const childrenLength = this.nodeData.children.length;
      if (alwaysShowExpandBtn) {
        if (this._expandBtn && childrenLength <= 0) {
          this.removeExpandBtn();
        } else {
          this.renderExpandBtn();
        }
      } else {
        let { isActive, expand } = this.getData();
        if (childrenLength <= 0) {
          this.removeExpandBtn();
        } else if (expand && !isActive && !this._isMouseenter) {
          this.hideExpandBtn();
        } else {
          this.showExpandBtn();
        }
      }
    }
    this.renderGeneralization(forceRender);
    if (this.updateUserListNode) this.updateUserListNode();
    let t = this.group.transform();
    if (this.left === t.translateX && this.top === t.translateY) return;
    this.group.translate(this.left - t.translateX, this.top - t.translateY);
  }
  // 获取节点相当于画布的位置
  getNodePosInClient(_left, _top) {
    let drawTransform = this.mindMap.draw.transform();
    let { scaleX, scaleY, translateX, translateY } = drawTransform;
    let left = _left * scaleX + translateX;
    let top = _top * scaleY + translateY;
    return {
      left,
      top
    };
  }
  // 判断节点是否可见
  checkIsInClient(padding = 0) {
    const { left: nx, top: ny } = this.getNodePosInClient(this.left, this.top);
    return nx + this.width > 0 - padding && ny + this.height > 0 - padding && nx < this.mindMap.width + padding && ny < this.mindMap.height + padding;
  }
  // 重新渲染节点，即重新创建节点内容、计算节点大小、计算节点内容布局、更新展开收起按钮，概要及位置
  reRender() {
    let sizeChange = this.getSize();
    this.layout();
    this.update();
    return sizeChange;
  }
  // 更新节点激活状态
  updateNodeActiveClass() {
    if (!this.group) return;
    const isActive = this.getData("isActive");
    this.group[isActive ? "addClass" : "removeClass"]("active");
  }
  // 根据是否激活更新节点
  updateNodeByActive(active) {
    if (this.group) {
      if (active) {
        this.showExpandBtn();
      } else {
        this.hideExpandBtn();
      }
      this.updateNodeActiveClass();
    }
  }
  // 递归渲染
  // forceRender：强制渲染，无论是否处于画布可视区域
  // async：异步渲染
  render(callback = () => {
  }, forceRender = false, async = false) {
    this.renderLine();
    const { openPerformance, performanceConfig } = this.mindMap.opt;
    if (forceRender || !openPerformance || this.checkIsInClient(performanceConfig.padding) || this.isRoot) {
      if (!this.group) {
        this.group = new G();
        this.group.addClass("smm-node");
        this.group.css({
          cursor: "default"
        });
        this.bindGroupEvent();
        this.nodeDraw.add(this.group);
        this.layout();
        this.update(forceRender);
      } else {
        if (!this.nodeDraw.has(this.group)) {
          this.nodeDraw.add(this.group);
        }
        if (this.needLayout) {
          this.needLayout = false;
          this.layout();
        }
        this.updateExpandBtnPlaceholderRect();
        this.update(forceRender);
      }
    } else if (openPerformance && performanceConfig.removeNodeWhenOutCanvas) {
      this.removeSelf();
    }
    if (this.children && this.children.length && this.getData("expand") !== false) {
      let index = 0;
      this.children.forEach((item) => {
        const renderChild = () => {
          item.render(
            () => {
              index++;
              if (index >= this.children.length) {
                callback();
              }
            },
            forceRender,
            async
          );
        };
        if (async) {
          setTimeout(renderChild, 0);
        } else {
          renderChild();
        }
      });
    } else {
      callback();
    }
    if (this.nodeData.inserting) {
      delete this.nodeData.inserting;
      this.active();
      this.mindMap.emit("node_dblclick", this, null, true);
    }
  }
  // 删除自身，只是从画布删除，节点容器还在，后续还可以重新插回画布
  removeSelf() {
    if (!this.group) return;
    this.group.remove();
    this.removeGeneralization();
  }
  //  递归删除，只是从画布删除，节点容器还在，后续还可以重新插回画布
  remove() {
    if (!this.group) return;
    this.group.remove();
    this.removeGeneralization();
    this.removeLine();
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.remove();
      });
    }
  }
  // 销毁节点，不但会从画布删除，而且原节点直接置空，后续无法再插回画布
  destroy() {
    this.removeLine();
    if (this.parent) {
      this.parent.removeLine();
    }
    if (!this.group) return;
    if (this.emptyUser) {
      this.emptyUser();
    }
    this.resetWhenDelete();
    this.group.remove();
    this.removeGeneralization();
    this.group = null;
    this.style.onRemove();
  }
  //  隐藏节点
  hide() {
    this.group.hide();
    this.hideGeneralization();
    if (this.parent) {
      let index = this.parent.children.indexOf(this);
      this.parent._lines[index] && this.parent._lines[index].hide();
      this._lines.forEach((item) => {
        item.hide();
      });
    }
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.hide();
      });
    }
  }
  //  显示节点
  show() {
    if (!this.group) {
      return;
    }
    this.group.show();
    this.showGeneralization();
    if (this.parent) {
      let index = this.parent.children.indexOf(this);
      this.parent._lines[index] && this.parent._lines[index].show();
      this._lines.forEach((item) => {
        item.show();
      });
    }
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.show();
      });
    }
  }
  // 设置节点透明度
  // 包括连接线和下级节点
  setOpacity(val) {
    this.group.opacity(val);
    this._lines.forEach((line) => {
      line.opacity(val);
    });
    this.children.forEach((item) => {
      item.setOpacity(val);
    });
    this.setGeneralizationOpacity(val);
  }
  // 隐藏子节点
  hideChildren() {
    this._lines.forEach((item) => {
      item.hide();
    });
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.hide();
      });
    }
  }
  // 显示子节点
  showChildren() {
    this._lines.forEach((item) => {
      item.show();
    });
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.show();
      });
    }
  }
  // 被拖拽中
  startDrag() {
    this.isDrag = true;
    this.group.addClass("smm-node-dragging");
  }
  // 拖拽结束
  endDrag() {
    this.isDrag = false;
    this.group.removeClass("smm-node-dragging");
  }
  //  连线
  renderLine(deep = false) {
    if (this.getData("expand") === false) {
      return;
    }
    let childrenLen = this.nodeData.children.length;
    if (this.mindMap.opt.layout === CONSTANTS.LAYOUT.FISHBONE && (this.isRoot || this.layerIndex === 1)) {
      childrenLen = 0;
    }
    if (childrenLen > this._lines.length) {
      new Array(childrenLen - this._lines.length).fill(0).forEach(() => {
        this._lines.push(this.lineDraw.path());
      });
    } else if (childrenLen < this._lines.length) {
      this._lines.slice(childrenLen).forEach((line) => {
        line.remove();
      });
      this._lines = this._lines.slice(0, childrenLen);
    }
    this.renderer.layout.renderLine(
      this,
      this._lines,
      (...args) => {
        this.styleLine(...args);
      },
      this.style.getStyle("lineStyle", true)
    );
    if (deep && this.children && this.children.length > 0) {
      this.children.forEach((item) => {
        item.renderLine(deep);
      });
    }
  }
  //  获取节点形状
  getShape() {
    return this.mindMap.themeConfig.nodeUseLineStyle ? CONSTANTS.SHAPE.RECTANGLE : this.style.getStyle("shape", false, false);
  }
  //  检查节点是否存在自定义数据
  hasCustomPosition() {
    return this.customLeft !== void 0 && this.customTop !== void 0;
  }
  //  检查节点是否存在自定义位置的祖先节点，包含自身
  ancestorHasCustomPosition() {
    let node = this;
    while (node) {
      if (node.hasCustomPosition()) {
        return true;
      }
      node = node.parent;
    }
    return false;
  }
  //  检查是否存在有概要的祖先节点
  ancestorHasGeneralization() {
    let node = this.parent;
    while (node) {
      if (node.checkHasGeneralization()) {
        return true;
      }
      node = node.parent;
    }
    return false;
  }
  //  添加子节点
  addChildren(node) {
    this.children.push(node);
  }
  //  设置连线样式
  styleLine(line, childNode, enableMarker) {
    const width = childNode.getSelfInhertStyle("lineWidth") || childNode.getStyle("lineWidth", true);
    const color = childNode.getSelfInhertStyle("lineColor") || this.getRainbowLineColor(childNode) || childNode.getStyle("lineColor", true);
    const dasharray = childNode.getSelfInhertStyle("lineDasharray") || childNode.getStyle("lineDasharray", true);
    this.style.line(
      line,
      {
        width,
        color,
        dasharray
      },
      enableMarker,
      childNode
    );
  }
  // 获取彩虹线条颜色
  getRainbowLineColor(node) {
    return this.mindMap.rainbowLines ? this.mindMap.rainbowLines.getNodeColor(node) : "";
  }
  //  移除连线
  removeLine() {
    this._lines.forEach((line) => {
      line.remove();
    });
    this._lines = [];
  }
  //  检测当前节点是否是某个节点的祖先节点
  isAncestor(node) {
    if (this.uid === node.uid) {
      return false;
    }
    let parent = node.parent;
    while (parent) {
      if (this.uid === parent.uid) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }
  // 检查当前节点是否是某个节点的父节点
  isParent(node) {
    if (this.uid === node.uid) {
      return false;
    }
    const parent = node.parent;
    if (parent && this.uid === parent.uid) {
      return true;
    }
    return false;
  }
  //  检测当前节点是否是某个节点的兄弟节点
  isBrother(node) {
    if (!this.parent || this.uid === node.uid) {
      return false;
    }
    return this.parent.children.find((item) => {
      return item.uid === node.uid;
    });
  }
  // 获取该节点在兄弟节点列表中的索引
  getIndexInBrothers() {
    return this.parent && this.parent.children ? this.parent.children.findIndex((item) => {
      return item.uid === this.uid;
    }) : -1;
  }
  //  获取padding值
  getPaddingVale() {
    let { isActive } = this.getData();
    return {
      paddingX: this.getStyle("paddingX", true, isActive),
      paddingY: this.getStyle("paddingY", true, isActive)
    };
  }
  //  获取某个样式
  getStyle(prop, root) {
    let v = this.style.merge(prop, root);
    return v === void 0 ? "" : v;
  }
  //  获取自定义样式
  getSelfStyle(prop) {
    return this.style.getSelfStyle(prop);
  }
  //   获取最近一个存在自身自定义样式的祖先节点的自定义样式
  getParentSelfStyle(prop) {
    if (this.parent) {
      return this.parent.getSelfStyle(prop) || this.parent.getParentSelfStyle(prop);
    }
    return null;
  }
  //  获取自身可继承的自定义样式
  getSelfInhertStyle(prop) {
    return this.getSelfStyle(prop) || // 自身
    this.getParentSelfStyle(prop);
  }
  // 获取节点非节点状态的边框大小
  getBorderWidth() {
    return this.style.merge("borderWidth", false) || 0;
  }
  //  获取数据
  getData(key) {
    return key ? this.nodeData.data[key] : this.nodeData.data;
  }
  // 获取该节点的纯数据，即不包含对节点实例的引用
  getPureData(removeActiveState = true, removeId = false) {
    return copyNodeTree({}, this, removeActiveState, removeId);
  }
  // 获取祖先节点列表
  getAncestorNodes() {
    const list = [];
    let parent = this.parent;
    while (parent) {
      list.unshift(parent);
      parent = parent.parent;
    }
    return list;
  }
  // 是否存在自定义样式
  hasCustomStyle() {
    return this.style.hasCustomStyle();
  }
  // 获取节点的尺寸和位置信息，宽高是应用了缩放效果后的实际宽高，位置是相对于浏览器窗口左上角的位置
  getRect() {
    return this.group.rbox();
  }
  // 获取节点的尺寸和位置信息，宽高是应用了缩放效果后的实际宽高，位置信息相对于画布
  getRectInSvg() {
    let { scaleX, scaleY, translateX, translateY } = this.mindMap.draw.transform();
    let { left, top, width, height } = this;
    let right = (left + width) * scaleX + translateX;
    let bottom = (top + height) * scaleY + translateY;
    left = left * scaleX + translateX;
    top = top * scaleY + translateY;
    return {
      left,
      right,
      top,
      bottom,
      width: width * scaleX,
      height: height * scaleY
    };
  }
  // 高亮节点
  highlight() {
    if (this.group) this.group.addClass("smm-node-highlight");
  }
  // 取消高亮节点
  closeHighlight() {
    if (this.group) this.group.removeClass("smm-node-highlight");
  }
  // 伪克隆节点
  // 克隆出的节点并不能真正当做一个节点使用
  fakeClone() {
    const newNode = new _Node({
      ...this.opt,
      uid: createUid()
    });
    Object.keys(this).forEach((item) => {
      newNode[item] = this[item];
    });
    return newNode;
  }
  // 创建SVG文本节点
  createSvgTextNode(text = "") {
    return new Text().text(text);
  }
};
var Node_default = Node;

// node_modules/simple-mind-map/src/utils/Lru.js
var Lru = class {
  constructor(max) {
    this.max = max || 1e3;
    this.size = 0;
    this.pool = /* @__PURE__ */ new Map();
  }
  add(key, value) {
    const isExist = this.has(key);
    if (!isExist && this.size >= this.max) {
      return false;
    }
    this.delete(key);
    this.pool.set(key, value);
    this.size++;
    return true;
  }
  delete(key) {
    if (this.pool.has(key)) {
      this.pool.delete(key);
      this.size--;
    }
  }
  has(key) {
    return this.pool.has(key);
  }
  get(key) {
    if (this.pool.has(key)) {
      return this.pool.get(key);
    }
  }
  clear() {
    this.size = 0;
    this.pool = /* @__PURE__ */ new Map();
  }
};

// node_modules/simple-mind-map/src/layouts/Base.js
var Base = class {
  //  构造函数
  constructor(renderer) {
    this.renderer = renderer;
    this.mindMap = renderer.mindMap;
    this.draw = this.mindMap.draw;
    this.lineDraw = this.mindMap.lineDraw;
    this.root = null;
    this.lru = new Lru(this.mindMap.opt.maxNodeCacheCount);
    this.rootNodeCenterOffset = null;
  }
  //  计算节点位置
  doLayout() {
    throw new Error("【computed】方法为必要方法，需要子类进行重写！");
  }
  //  连线
  renderLine() {
    throw new Error("【renderLine】方法为必要方法，需要子类进行重写！");
  }
  //  定位展开收缩按钮
  renderExpandBtn() {
    throw new Error("【renderExpandBtn】方法为必要方法，需要子类进行重写！");
  }
  //  概要节点
  renderGeneralization() {
  }
  // 通过uid缓存节点
  cacheNode(uid, node) {
    this.renderer.nodeCache[uid] = node;
    this.lru.add(uid, node);
  }
  // 检查当前来源是否需要重新计算节点大小
  checkIsNeedResizeSources() {
    return [
      CONSTANTS.CHANGE_THEME,
      CONSTANTS.TRANSFORM_TO_NORMAL_NODE
    ].includes(this.renderer.renderSource);
  }
  // 层级类型改变
  checkIsLayerTypeChange(oldIndex, newIndex) {
    if (oldIndex >= 2 && newIndex >= 2) return false;
    if (oldIndex >= 2 && newIndex < 2) return true;
    if (oldIndex < 2 && newIndex >= 2) return true;
  }
  // 检查是否是结构布局改变重新渲染展开收起按钮占位元素
  checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(node) {
    if (this.renderer.renderSource === CONSTANTS.CHANGE_LAYOUT) {
      node.needRerenderExpandBtnPlaceholderRect = true;
    }
  }
  // 获取节点编号信息
  getNumberInfo({ parent, ancestors, layerIndex, index }) {
    const hasNumberPlugin = !!this.mindMap.numbers;
    const parentNumberStr = hasNumberPlugin && parent && parent._node.number ? parent._node.number : "";
    const newNumberStr = hasNumberPlugin ? this.mindMap.numbers.getNodeNumberStr({
      ancestors,
      layerIndex,
      num: index + 1,
      parentNumberStr
    }) : "";
    return {
      hasNumberPlugin,
      newNumberStr
    };
  }
  //  创建节点实例
  createNode(data, parent, isRoot, layerIndex, index, ancestors) {
    const { hasNumberPlugin, newNumberStr } = this.getNumberInfo({
      parent,
      ancestors,
      layerIndex,
      index
    });
    const uid = data.data.uid;
    let newNode = null;
    if (data && data._node && !this.renderer.reRender) {
      newNode = data._node;
      const isLayerTypeChange = this.checkIsLayerTypeChange(
        newNode.layerIndex,
        layerIndex
      );
      newNode.reset();
      newNode.layerIndex = layerIndex;
      if (isRoot) {
        newNode.isRoot = true;
      } else {
        newNode.parent = parent._node;
      }
      this.cacheNode(data._node.uid, newNode);
      this.checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(newNode);
      let isNumberChange = false;
      if (hasNumberPlugin) {
        isNumberChange = this.mindMap.numbers.updateNumber(
          newNode,
          newNumberStr
        );
      }
      if (this.checkIsNeedResizeSources() || isLayerTypeChange || newNode.getData("resetRichText") || isNumberChange) {
        newNode.getSize();
        newNode.needLayout = true;
      }
      this.checkGetGeneralizationChange(newNode);
    } else if ((this.lru.has(uid) || this.renderer.lastNodeCache[uid]) && !this.renderer.reRender) {
      newNode = this.lru.get(uid) || this.renderer.lastNodeCache[uid];
      const lastData = JSON.stringify(newNode.getData());
      const isLayerTypeChange = this.checkIsLayerTypeChange(
        newNode.layerIndex,
        layerIndex
      );
      newNode.reset();
      newNode.nodeData = newNode.handleData(data || {});
      newNode.layerIndex = layerIndex;
      if (isRoot) {
        newNode.isRoot = true;
      } else {
        newNode.parent = parent._node;
      }
      this.cacheNode(uid, newNode);
      this.checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(newNode);
      data._node = newNode;
      const isResizeSource = this.checkIsNeedResizeSources();
      const isNodeDataChange = lastData !== JSON.stringify(data.data);
      let isNumberChange = false;
      if (hasNumberPlugin) {
        isNumberChange = this.mindMap.numbers.updateNumber(
          newNode,
          newNumberStr
        );
      }
      if (isResizeSource || isNodeDataChange || isLayerTypeChange || newNode.getData("resetRichText") || isNumberChange) {
        newNode.getSize();
        newNode.needLayout = true;
      }
      this.checkGetGeneralizationChange(newNode);
    } else {
      const newUid = uid || createUid();
      newNode = new Node_default({
        data,
        uid: newUid,
        renderer: this.renderer,
        mindMap: this.mindMap,
        draw: this.draw,
        layerIndex,
        isRoot,
        parent: !isRoot ? parent._node : null,
        number: newNumberStr
      });
      data.data.uid = newUid;
      this.cacheNode(newUid, newNode);
      data._node = newNode;
    }
    if (data.data.isActive) {
      this.renderer.addNodeToActiveList(newNode);
    }
    if (this.mindMap.renderer.findActiveNodeIndex(newNode) !== -1) {
      newNode.setData({
        isActive: true
      });
    }
    if (isRoot) {
      this.root = newNode;
    } else {
      parent._node.addChildren(newNode);
    }
    return newNode;
  }
  // 检查概要节点是否需要更新
  checkGetGeneralizationChange(node) {
    const generalizationList = node.getData("generalization");
    if (generalizationList && node._generalizationList && node._generalizationList.length > 0) {
      node._generalizationList.forEach((item, index) => {
        const gNode = item.generalizationNode;
        const oldData = gNode.getData();
        const newData = generalizationList[index];
        if (newData && JSON.stringify(oldData) !== JSON.stringify(newData)) {
          gNode.nodeData.data = newData;
          gNode.getSize();
          gNode.needLayout = true;
        }
      });
    }
  }
  // 格式化节点位置
  formatPosition(value, size, nodeSize) {
    if (typeof value === "number") {
      return value;
    } else if (initRootNodePositionMap[value] !== void 0) {
      return size * initRootNodePositionMap[value];
    } else if (/^\d\d*%$/.test(value)) {
      return Number.parseFloat(value) / 100 * size;
    } else {
      return (size - nodeSize) / 2;
    }
  }
  // 规范initRootNodePosition配置
  formatInitRootNodePosition(pos) {
    const { CENTER } = CONSTANTS.INIT_ROOT_NODE_POSITION;
    if (!pos || !Array.isArray(pos) || pos.length < 2) {
      pos = [CENTER, CENTER];
    }
    return pos;
  }
  //  定位节点到画布中间
  setNodeCenter(node, position) {
    let { initRootNodePosition } = this.mindMap.opt;
    initRootNodePosition = this.formatInitRootNodePosition(
      position || initRootNodePosition
    );
    node.left = this.formatPosition(
      initRootNodePosition[0],
      this.mindMap.width,
      node.width
    );
    node.top = this.formatPosition(
      initRootNodePosition[1],
      this.mindMap.height,
      node.height
    );
  }
  // 当initRootNodePosition配置不为默认的['center','center']时，计算当前配置和默认配置情况下，根节点位置的差值
  getRootCenterOffset(width, height) {
    if (this.rootNodeCenterOffset) return this.rootNodeCenterOffset;
    let { initRootNodePosition } = this.mindMap.opt;
    const { CENTER } = CONSTANTS.INIT_ROOT_NODE_POSITION;
    initRootNodePosition = this.formatInitRootNodePosition(initRootNodePosition);
    if (initRootNodePosition[0] === CENTER && initRootNodePosition[1] === CENTER) {
      this.rootNodeCenterOffset = {
        x: 0,
        y: 0
      };
    } else {
      const tmpNode = {
        width,
        height
      };
      const tmpNode2 = {
        width,
        height
      };
      this.setNodeCenter(tmpNode, [CENTER, CENTER]);
      this.setNodeCenter(tmpNode2);
      this.rootNodeCenterOffset = {
        x: tmpNode2.left - tmpNode.left,
        y: tmpNode2.top - tmpNode.top
      };
    }
    return this.rootNodeCenterOffset;
  }
  //  更新子节点属性
  updateChildren(children, prop, offset) {
    children.forEach((item) => {
      item[prop] += offset;
      if (item.children && item.children.length && !item.hasCustomPosition()) {
        this.updateChildren(item.children, prop, offset);
      }
    });
  }
  //  更新子节点多个属性
  updateChildrenPro(children, props) {
    children.forEach((item) => {
      Object.keys(props).forEach((prop) => {
        item[prop] += props[prop];
      });
      if (item.children && item.children.length && !item.hasCustomPosition()) {
        this.updateChildrenPro(item.children, props);
      }
    });
  }
  //  递归计算节点的宽度
  getNodeAreaWidth(node, withGeneralization = false) {
    let widthArr = [];
    let totalGeneralizationNodeWidth = 0;
    let loop = (node2, width) => {
      if (withGeneralization && node2.checkHasGeneralization()) {
        totalGeneralizationNodeWidth += node2._generalizationNodeWidth;
      }
      if (node2.children.length) {
        width += node2.width / 2;
        node2.children.forEach((item) => {
          loop(item, width);
        });
      } else {
        width += node2.width;
        widthArr.push(width);
      }
    };
    loop(node, 0);
    return Math.max(...widthArr) + totalGeneralizationNodeWidth;
  }
  //  二次贝塞尔曲线
  quadraticCurvePath(x1, y1, x2, y2) {
    let cx = x1 + (x2 - x1) * 0.2;
    let cy = y1 + (y2 - y1) * 0.8;
    return `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;
  }
  //  三次贝塞尔曲线
  cubicBezierPath(x1, y1, x2, y2) {
    let cx1 = x1 + (x2 - x1) / 2;
    let cy1 = y1;
    let cx2 = cx1;
    let cy2 = y2;
    return `M ${x1},${y1} C ${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;
  }
  // 根据a,b两个点的位置，计算去除圆角大小后的新的b点
  computeNewPoint(a, b, radius = 0) {
    if (a[0] === b[0]) {
      if (b[1] > a[1]) {
        return [b[0], b[1] - radius];
      } else {
        return [b[0], b[1] + radius];
      }
    } else if (a[1] === b[1]) {
      if (b[0] > a[0]) {
        return [b[0] - radius, b[1]];
      } else {
        return [b[0] + radius, b[1]];
      }
    }
  }
  // 创建一段折线路径
  // 最后一个拐角支持圆角
  createFoldLine(list) {
    const { lineRadius } = this.mindMap.themeConfig;
    const len = list.length;
    let path = "";
    let radiusPath = "";
    if (len >= 3 && lineRadius > 0) {
      const start = list[len - 3];
      const center = list[len - 2];
      const end = list[len - 1];
      const isOneLine = start[0] === center[0] && center[0] === end[0] || start[1] === center[1] && center[1] === end[1];
      if (!isOneLine) {
        const cStart = this.computeNewPoint(start, center, lineRadius);
        const cEnd = this.computeNewPoint(end, center, lineRadius);
        radiusPath = `Q ${center[0]},${center[1]} ${cEnd[0]},${cEnd[1]}`;
        list.splice(len - 2, 1, cStart, radiusPath);
      }
    }
    list.forEach((item, index) => {
      if (typeof item === "string") {
        path += item;
      } else {
        const [x, y] = item;
        if (index === 0) {
          path += `M ${x},${y}`;
        } else {
          path += `L ${x},${y}`;
        }
      }
    });
    return path;
  }
  //   获取节点的marginX
  getMarginX(layerIndex) {
    const { themeConfig, opt } = this.mindMap;
    const { second, node } = themeConfig;
    const hoverRectPadding = opt.hoverRectPadding * 2;
    return layerIndex === 1 ? second.marginX + hoverRectPadding : node.marginX + hoverRectPadding;
  }
  //  获取节点的marginY
  getMarginY(layerIndex) {
    const { themeConfig, opt } = this.mindMap;
    const { second, node } = themeConfig;
    const hoverRectPadding = opt.hoverRectPadding * 2;
    return layerIndex === 1 ? second.marginY + hoverRectPadding : node.marginY + hoverRectPadding;
  }
  //  获取节点包括概要在内的宽度
  getNodeWidthWithGeneralization(node) {
    return Math.max(
      node.width,
      node.checkHasGeneralization() ? node._generalizationNodeWidth : 0
    );
  }
  //  获取节点包括概要在内的高度
  getNodeHeightWithGeneralization(node) {
    return Math.max(
      node.height,
      node.checkHasGeneralization() ? node._generalizationNodeHeight : 0
    );
  }
  //  获取节点的边界值
  /**
   * dir：生长方向，h（水平）、v（垂直）
   * isLeft：是否向左生长
   */
  getNodeBoundaries(node, dir) {
    let { generalizationLineMargin, generalizationNodeMargin } = this.mindMap.themeConfig;
    let walk2 = (root) => {
      let _left = Infinity;
      let _right = -Infinity;
      let _top = Infinity;
      let _bottom = -Infinity;
      if (root.children && root.children.length > 0) {
        root.children.forEach((child) => {
          let { left: left2, right: right2, top: top2, bottom: bottom2 } = walk2(child);
          let generalizationWidth = child.checkHasGeneralization() && child.getData("expand") ? child._generalizationNodeWidth + generalizationNodeMargin : 0;
          let generalizationHeight = child.checkHasGeneralization() && child.getData("expand") ? child._generalizationNodeHeight + generalizationNodeMargin : 0;
          if (left2 - (dir === "h" ? generalizationWidth : 0) < _left) {
            _left = left2 - (dir === "h" ? generalizationWidth : 0);
          }
          if (right2 + (dir === "h" ? generalizationWidth : 0) > _right) {
            _right = right2 + (dir === "h" ? generalizationWidth : 0);
          }
          if (top2 < _top) {
            _top = top2;
          }
          if (bottom2 + (dir === "v" ? generalizationHeight : 0) > _bottom) {
            _bottom = bottom2 + (dir === "v" ? generalizationHeight : 0);
          }
        });
      }
      let cur = {
        left: root.left,
        right: root.left + root.width,
        top: root.top,
        bottom: root.top + root.height
      };
      return {
        left: cur.left < _left ? cur.left : _left,
        right: cur.right > _right ? cur.right : _right,
        top: cur.top < _top ? cur.top : _top,
        bottom: cur.bottom > _bottom ? cur.bottom : _bottom
      };
    };
    let { left, right, top, bottom } = walk2(node);
    return {
      left,
      right,
      top,
      bottom,
      generalizationLineMargin,
      generalizationNodeMargin
    };
  }
  // 获取指定索引区间的子节点的边界范围
  getChildrenBoundaries(node, dir, startIndex = 0, endIndex) {
    let { generalizationLineMargin, generalizationNodeMargin } = this.mindMap.themeConfig;
    const children = node.children.slice(startIndex, endIndex + 1);
    let left = Infinity;
    let right = -Infinity;
    let top = Infinity;
    let bottom = -Infinity;
    children.forEach((item) => {
      const cur = this.getNodeBoundaries(item, dir);
      left = cur.left < left ? cur.left : left;
      right = cur.right > right ? cur.right : right;
      top = cur.top < top ? cur.top : top;
      bottom = cur.bottom > bottom ? cur.bottom : bottom;
    });
    return {
      left,
      right,
      top,
      bottom,
      generalizationLineMargin,
      generalizationNodeMargin
    };
  }
  // 获取节点概要的渲染边界
  getNodeGeneralizationRenderBoundaries(item, dir) {
    let res = null;
    if (item.range) {
      res = this.getChildrenBoundaries(
        item.node,
        dir,
        item.range[0],
        item.range[1]
      );
    } else {
      res = this.getNodeBoundaries(item.node, dir);
    }
    return res;
  }
  // 获取节点实际存在几个子节点
  getNodeActChildrenLength(node) {
    return node.nodeData.children && node.nodeData.children.length;
  }
  // 设置连线样式
  setLineStyle(style, line, path, childNode) {
    line.plot(this.transformPath(path));
    style && style(line, childNode, true);
  }
  // 转换路径，可以转换成特殊风格的线条样式
  transformPath(path) {
    const { customTransformNodeLinePath } = this.mindMap.opt;
    if (customTransformNodeLinePath) {
      return customTransformNodeLinePath(path);
    } else {
      return path;
    }
  }
};
var Base_default = Base;

// node_modules/simple-mind-map/src/layouts/LogicalStructure.js
var LogicalStructure = class extends Base_default {
  //  构造函数
  constructor(opt = {}, layout) {
    super(opt);
    this.isUseLeft = layout === CONSTANTS.LAYOUT.LOGICAL_STRUCTURE_LEFT;
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedTopValue();
      },
      () => {
        this.adjustTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据计算节点的left、width、height
  computedBaseValue() {
    let sortIndex = 0;
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index, ancestors) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex, index, ancestors);
        newNode.sortIndex = sortIndex;
        sortIndex++;
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (this.isUseLeft) {
            newNode.left = parent._node.left - newNode.width - this.getMarginX(layerIndex);
          } else {
            newNode.left = parent._node.left + parent._node.width + this.getMarginX(layerIndex);
          }
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        let len = cur.data.expand === false ? 0 : cur._node.children.length;
        cur._node.childrenAreaHeight = len ? cur._node.children.reduce((h, item) => {
          return h + item.height;
        }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;
        let generalizationNodeHeight = cur._node.checkHasGeneralization() ? cur._node._generalizationNodeHeight + this.getMarginY(layerIndex + 1) : 0;
        cur._node.childrenAreaHeight2 = Math.max(
          cur._node.childrenAreaHeight,
          generalizationNodeHeight
        );
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的top
  computedTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (node.getData("expand") && node.children && node.children.length) {
          let marginY = this.getMarginY(layerIndex + 1);
          let top = node.top + node.height / 2 - node.childrenAreaHeight / 2;
          let totalTop = top + marginY;
          node.children.forEach((cur) => {
            cur.top = totalTop;
            totalTop += cur.height + marginY;
          });
        }
      },
      null,
      true
    );
  }
  //  调整节点top
  adjustTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (!node.getData("expand")) {
          return;
        }
        let difference = node.childrenAreaHeight2 - this.getMarginY(layerIndex + 1) * 2 - node.height;
        if (difference > 0) {
          this.updateBrothers(node, difference / 2);
        }
      },
      null,
      true
    );
  }
  //  更新兄弟节点的top
  updateBrothers(node, addHeight) {
    if (node.parent) {
      let childrenList = node.parent.children;
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.uid === node.uid || item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index < index) {
          _offset = -addHeight;
        } else if (_index > index) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothers(node.parent, addHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node, lines, style, lineStyle) {
    if (lineStyle === "curve") {
      this.renderLineCurve(node, lines, style);
    } else if (lineStyle === "direct") {
      this.renderLineDirect(node, lines, style);
    } else {
      this.renderLineStraight(node, lines, style);
    }
  }
  //  直线风格连线
  renderLineStraight(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    let marginX = this.getMarginX(node.layerIndex + 1);
    let s1 = (marginX - expandBtnSize) * 0.6;
    if (this.isUseLeft) {
      s1 *= -1;
    }
    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;
    node.children.forEach((item, index) => {
      let x1;
      if (this.isUseLeft) {
        x1 = node.layerIndex === 0 ? left : left - expandBtnSize;
      } else {
        x1 = node.layerIndex === 0 ? left + width : left + width + expandBtnSize;
      }
      let y1 = top + height / 2;
      let x2 = this.isUseLeft ? item.left + item.width : item.left;
      let y2 = item.top + item.height / 2;
      let nodeUseLineStyleOffset = nodeUseLineStyle ? item.width * (this.isUseLeft ? -1 : 1) : 0;
      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;
      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;
      let path = this.createFoldLine([
        [x1, y1],
        [x1 + s1, y1],
        [x1 + s1, y2],
        [x2 + nodeUseLineStyleOffset, y2]
      ]);
      this.setLineStyle(style, lines[index], path, item);
    });
  }
  //  直连风格
  renderLineDirect(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    const { nodeUseLineStyle } = this.mindMap.themeConfig;
    node.children.forEach((item, index) => {
      if (node.layerIndex === 0) {
        expandBtnSize = 0;
      }
      let x1 = this.isUseLeft ? left - expandBtnSize : left + width + expandBtnSize;
      let y1 = top + height / 2;
      let x2 = this.isUseLeft ? item.left + item.width : item.left;
      let y2 = item.top + item.height / 2;
      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;
      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;
      let nodeUseLineStylePath = nodeUseLineStyle ? ` L ${this.isUseLeft ? item.left : item.left + item.width},${y2}` : "";
      let path = `M ${x1},${y1} L ${x2},${y2}` + nodeUseLineStylePath;
      this.setLineStyle(style, lines[index], path, item);
    });
  }
  //  曲线风格连线
  renderLineCurve(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    const {
      nodeUseLineStyle,
      rootLineStartPositionKeepSameInCurve,
      rootLineKeepSameInCurve
    } = this.mindMap.themeConfig;
    node.children.forEach((item, index) => {
      if (node.layerIndex === 0) {
        expandBtnSize = 0;
      }
      let x1;
      if (this.isUseLeft) {
        x1 = node.layerIndex === 0 && !rootLineStartPositionKeepSameInCurve ? left + width / 2 : left - expandBtnSize;
      } else {
        x1 = node.layerIndex === 0 && !rootLineStartPositionKeepSameInCurve ? left + width / 2 : left + width + expandBtnSize;
      }
      let y1 = top + height / 2;
      let x2 = this.isUseLeft ? item.left + item.width : item.left;
      let y2 = item.top + item.height / 2;
      let path = "";
      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;
      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;
      let nodeUseLineStylePath;
      if (this.isUseLeft) {
        nodeUseLineStylePath = nodeUseLineStyle ? ` L ${item.left},${y2}` : "";
      } else {
        nodeUseLineStylePath = nodeUseLineStyle ? ` L ${item.left + item.width},${y2}` : "";
      }
      if (node.isRoot && !rootLineKeepSameInCurve) {
        path = this.quadraticCurvePath(x1, y1, x2, y2) + nodeUseLineStylePath;
      } else {
        path = this.cubicBezierPath(x1, y1, x2, y2) + nodeUseLineStylePath;
      }
      this.setLineStyle(style, lines[index], path, item);
    });
  }
  //  渲染按钮
  renderExpandBtn(node, btn) {
    let { width, height, expandBtnSize, layerIndex } = node;
    if (layerIndex === 0) {
      expandBtnSize = 0;
    }
    let { translateX, translateY } = btn.transform();
    let nodeUseLineStyleOffset = this.mindMap.themeConfig.nodeUseLineStyle ? height / 2 : 0;
    let _x = this.isUseLeft ? 0 - expandBtnSize : width;
    let _y = height / 2 + nodeUseLineStyleOffset;
    if (_x === translateX && _y === translateY) {
      return;
    }
    btn.translate(_x - translateX, _y - translateY);
  }
  //  创建概要节点
  renderGeneralization(list) {
    list.forEach((item) => {
      let {
        left,
        top,
        bottom,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x = this.isUseLeft ? left - generalizationLineMargin : right + generalizationLineMargin;
      let x1 = x;
      let y1 = top;
      let x2 = x;
      let y2 = bottom;
      let cx = x1 + (this.isUseLeft ? -20 : 20);
      let cy = y1 + (y2 - y1) / 2;
      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;
      item.generalizationLine.plot(path);
      item.generalizationNode.left = x + (this.isUseLeft ? -generalizationNodeMargin : generalizationNodeMargin) - (this.isUseLeft ? item.generalizationNode.width : 0);
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width, height) {
    if (this.isUseLeft) {
      rect.size(expandBtnSize, height).x(-expandBtnSize).y(0);
    } else {
      rect.size(expandBtnSize, height).x(width).y(0);
    }
  }
};
var LogicalStructure_default = LogicalStructure;

// node_modules/simple-mind-map/src/layouts/MindMap.js
var MindMap = class extends Base_default {
  //  构造函数
  // 在逻辑结构图的基础上增加一个变量来记录生长方向，向左还是向右，同时在计算left的时候根据方向来计算、调整top时只考虑同方向的节点即可
  constructor(opt = {}) {
    super(opt);
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedTopValue();
      },
      () => {
        this.adjustTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据计算节点的left、width、height
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index, ancestors) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex, index, ancestors);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (parent._node.dir) {
            newNode.dir = parent._node.dir;
          } else {
            newNode.dir = index % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.RIGHT : CONSTANTS.LAYOUT_GROW_DIR.LEFT;
          }
          newNode.left = newNode.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT ? parent._node.left + parent._node.width + this.getMarginX(layerIndex) : parent._node.left - this.getMarginX(layerIndex) - newNode.width;
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        if (!cur.data.expand) {
          cur._node.leftChildrenAreaHeight = 0;
          cur._node.rightChildrenAreaHeight = 0;
          return;
        }
        let leftLen = 0;
        let rightLen = 0;
        let leftChildrenAreaHeight = 0;
        let rightChildrenAreaHeight = 0;
        cur._node.children.forEach((item) => {
          if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
            leftLen++;
            leftChildrenAreaHeight += item.height;
          } else {
            rightLen++;
            rightChildrenAreaHeight += item.height;
          }
        });
        cur._node.leftChildrenAreaHeight = leftChildrenAreaHeight + (leftLen + 1) * this.getMarginY(layerIndex + 1);
        cur._node.rightChildrenAreaHeight = rightChildrenAreaHeight + (rightLen + 1) * this.getMarginY(layerIndex + 1);
        let generalizationNodeHeight = cur._node.checkHasGeneralization() ? cur._node._generalizationNodeHeight + this.getMarginY(layerIndex + 1) : 0;
        cur._node.leftChildrenAreaHeight2 = Math.max(
          cur._node.leftChildrenAreaHeight,
          generalizationNodeHeight
        );
        cur._node.rightChildrenAreaHeight2 = Math.max(
          cur._node.rightChildrenAreaHeight,
          generalizationNodeHeight
        );
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的top
  computedTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (node.getData("expand") && node.children && node.children.length) {
          let marginY = this.getMarginY(layerIndex + 1);
          let baseTop = node.top + node.height / 2 + marginY;
          let leftTotalTop = baseTop - node.leftChildrenAreaHeight / 2;
          let rightTotalTop = baseTop - node.rightChildrenAreaHeight / 2;
          node.children.forEach((cur) => {
            if (cur.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
              cur.top = leftTotalTop;
              leftTotalTop += cur.height + marginY;
            } else {
              cur.top = rightTotalTop;
              rightTotalTop += cur.height + marginY;
            }
          });
        }
      },
      null,
      true
    );
  }
  //  调整节点top
  adjustTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (!node.getData("expand")) {
          return;
        }
        let base = this.getMarginY(layerIndex + 1) * 2 + node.height;
        let leftDifference = node.leftChildrenAreaHeight2 - base;
        let rightDifference = node.rightChildrenAreaHeight2 - base;
        if (leftDifference > 0 || rightDifference > 0) {
          this.updateBrothers(node, leftDifference / 2, rightDifference / 2);
        }
      },
      null,
      true
    );
  }
  //  更新兄弟节点的top
  updateBrothers(node, leftAddHeight, rightAddHeight) {
    if (node.parent) {
      let childrenList = node.parent.children.filter((item) => {
        return item.dir === node.dir;
      });
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        let addHeight = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? leftAddHeight : rightAddHeight;
        if (_index < index) {
          _offset = -addHeight;
        } else if (_index > index) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothers(node.parent, leftAddHeight, rightAddHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node, lines, style, lineStyle) {
    if (lineStyle === "curve") {
      this.renderLineCurve(node, lines, style);
    } else if (lineStyle === "direct") {
      this.renderLineDirect(node, lines, style);
    } else {
      this.renderLineStraight(node, lines, style);
    }
  }
  //  直线风格连线
  renderLineStraight(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    let marginX = this.getMarginX(node.layerIndex + 1);
    let s1 = (marginX - expandBtnSize) * 0.6;
    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;
    node.children.forEach((item, index) => {
      let x1 = 0;
      let _s = 0;
      let nodeUseLineStyleOffset = nodeUseLineStyle ? item.width : 0;
      if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
        _s = -s1;
        x1 = node.layerIndex === 0 ? left : left - expandBtnSize;
        nodeUseLineStyleOffset = -nodeUseLineStyleOffset;
      } else {
        _s = s1;
        x1 = node.layerIndex === 0 ? left + width : left + width + expandBtnSize;
      }
      let y1 = top + height / 2;
      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
      let y2 = item.top + item.height / 2;
      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;
      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;
      let path = this.createFoldLine([
        [x1, y1],
        [x1 + _s, y1],
        [x1 + _s, y2],
        [x2 + nodeUseLineStyleOffset, y2]
      ]);
      this.setLineStyle(style, lines[index], path, item);
    });
  }
  //  直连风格
  renderLineDirect(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    const { nodeUseLineStyle } = this.mindMap.themeConfig;
    node.children.forEach((item, index) => {
      if (node.layerIndex === 0) {
        expandBtnSize = 0;
      }
      let x1 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width + expandBtnSize;
      let y1 = top + height / 2;
      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
      let y2 = item.top + item.height / 2;
      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;
      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;
      let nodeUseLineStylePath = "";
      if (nodeUseLineStyle) {
        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
          nodeUseLineStylePath = ` L ${item.left},${y2}`;
        } else {
          nodeUseLineStylePath = ` L ${item.left + item.width},${y2}`;
        }
      }
      let path = `M ${x1},${y1} L ${x2},${y2}` + nodeUseLineStylePath;
      this.setLineStyle(style, lines[index], path, item);
    });
  }
  //  曲线风格连线
  renderLineCurve(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    const {
      nodeUseLineStyle,
      rootLineKeepSameInCurve,
      rootLineStartPositionKeepSameInCurve
    } = this.mindMap.themeConfig;
    node.children.forEach((item, index) => {
      if (node.layerIndex === 0) {
        expandBtnSize = 0;
      }
      let x1 = node.layerIndex === 0 && !rootLineStartPositionKeepSameInCurve ? left + width / 2 : item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width + expandBtnSize;
      let y1 = top + height / 2;
      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
      let y2 = item.top + item.height / 2;
      let path = "";
      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;
      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;
      let nodeUseLineStylePath = "";
      if (nodeUseLineStyle) {
        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
          nodeUseLineStylePath = ` L ${item.left},${y2}`;
        } else {
          nodeUseLineStylePath = ` L ${item.left + item.width},${y2}`;
        }
      }
      if (node.isRoot && !rootLineKeepSameInCurve) {
        path = this.quadraticCurvePath(x1, y1, x2, y2) + nodeUseLineStylePath;
      } else {
        path = this.cubicBezierPath(x1, y1, x2, y2) + nodeUseLineStylePath;
      }
      this.setLineStyle(style, lines[index], path, item);
    });
  }
  //  渲染按钮
  renderExpandBtn(node, btn) {
    let { width, height, expandBtnSize } = node;
    let { translateX, translateY } = btn.transform();
    let nodeUseLineStyleOffset = this.mindMap.themeConfig.nodeUseLineStyle ? height / 2 : 0;
    let _x = node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? 0 - expandBtnSize : width;
    let _y = height / 2 + nodeUseLineStyleOffset;
    if (_x === translateX && _y === translateY) {
      return;
    }
    let x = _x - translateX;
    let y = _y - translateY;
    btn.translate(x, y);
  }
  //  创建概要节点
  renderGeneralization(list) {
    list.forEach((item) => {
      let isLeft = item.node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT;
      let {
        top,
        bottom,
        left,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x = isLeft ? left - generalizationLineMargin : right + generalizationLineMargin;
      let x1 = x;
      let y1 = top;
      let x2 = x;
      let y2 = bottom;
      let cx = x1 + (isLeft ? -20 : 20);
      let cy = y1 + (y2 - y1) / 2;
      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;
      item.generalizationLine.plot(path);
      item.generalizationNode.left = x + (isLeft ? -generalizationNodeMargin : generalizationNodeMargin) - (isLeft ? item.generalizationNode.width : 0);
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {
    if (node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
      rect.size(expandBtnSize, height).x(-expandBtnSize).y(0);
    } else {
      rect.size(expandBtnSize, height).x(width).y(0);
    }
  }
};
var MindMap_default = MindMap;

// node_modules/simple-mind-map/src/layouts/CatalogOrganization.js
var CatalogOrganization = class extends Base_default {
  //  构造函数
  constructor(opt = {}) {
    super(opt);
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedLeftTopValue();
      },
      () => {
        this.adjustLeftTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据计算节点的left、width、height
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index, ancestors) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex, index, ancestors);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (parent._node.isRoot) {
            newNode.top = parent._node.top + parent._node.height + this.getMarginX(layerIndex);
          }
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        if (isRoot) {
          let len = cur.data.expand === false ? 0 : cur._node.children.length;
          cur._node.childrenAreaWidth = len ? cur._node.children.reduce((h, item) => {
            return h + item.width;
          }, 0) + (len + 1) * this.getMarginX(layerIndex + 1) : 0;
        }
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的left、top
  computedLeftTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (node.getData("expand") && node.children && node.children.length) {
          let marginX = this.getMarginX(layerIndex + 1);
          let marginY = this.getMarginY(layerIndex + 1);
          if (isRoot) {
            let left = node.left + node.width / 2 - node.childrenAreaWidth / 2;
            let totalLeft = left + marginX;
            node.children.forEach((cur) => {
              cur.left = totalLeft;
              totalLeft += cur.width + marginX;
            });
          } else {
            let totalTop = node.top + this.getNodeHeightWithGeneralization(node) + marginY + (this.getNodeActChildrenLength(node) > 0 ? node.expandBtnSize : 0);
            node.children.forEach((cur) => {
              cur.left = node.left + node.width * 0.5;
              cur.top = totalTop;
              totalTop += this.getNodeHeightWithGeneralization(cur) + marginY + (this.getNodeActChildrenLength(cur) > 0 ? cur.expandBtnSize : 0);
            });
          }
        }
      },
      null,
      true
    );
  }
  //  调整节点left、top
  adjustLeftTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (!node.getData("expand")) {
          return;
        }
        if (parent && parent.isRoot) {
          let areaWidth = this.getNodeAreaWidth(node, true);
          let difference = areaWidth - node.width;
          if (difference > 0) {
            this.updateBrothersLeft(node, difference);
          }
        }
        let len = node.children.length;
        if (parent && !parent.isRoot && len > 0) {
          let marginY = this.getMarginY(layerIndex + 1);
          let totalHeight = node.children.reduce((h, item) => {
            return h + this.getNodeHeightWithGeneralization(item) + (this.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0);
          }, 0) + len * marginY;
          this.updateBrothersTop(node, totalHeight);
        }
      },
      (node, parent, isRoot) => {
        if (isRoot) {
          let { right, left } = this.getNodeBoundaries(node, "h");
          let childrenWidth = right - left;
          let offset = node.left - left - (childrenWidth - node.width) / 2;
          this.updateChildren(node.children, "left", offset);
        }
      },
      true
    );
  }
  //  调整兄弟节点的left
  updateBrothersLeft(node, addWidth) {
    if (node.parent) {
      let childrenList = node.parent.children;
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition() || _index <= index) {
          return;
        }
        item.left += addWidth;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "left", addWidth);
        }
      });
      this.updateBrothersLeft(node.parent, addWidth);
    }
  }
  //  调整兄弟节点的top
  updateBrothersTop(node, addHeight) {
    if (node.parent && !node.parent.isRoot) {
      let childrenList = node.parent.children;
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index > index) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothersTop(node.parent, addHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    let len = node.children.length;
    let marginX = this.getMarginX(node.layerIndex + 1);
    if (node.isRoot) {
      let x1 = left + width / 2;
      let y1 = top + height;
      let s1 = marginX * 0.7;
      let minx = Infinity;
      let maxx = -Infinity;
      node.children.forEach((item, index) => {
        let x2 = item.left + item.width / 2;
        let y2 = item.top;
        if (x2 < minx) {
          minx = x2;
        }
        if (x2 > maxx) {
          maxx = x2;
        }
        let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle ? ` L ${item.left},${y2} L ${item.left + item.width},${y2}` : "";
        let path = `M ${x2},${y1 + s1} L ${x2},${y1 + s1 > y2 ? y2 + item.height : y2}` + nodeUseLineStylePath;
        this.setLineStyle(style, lines[index], path, item);
      });
      minx = Math.min(minx, x1);
      maxx = Math.max(maxx, x1);
      let line1 = this.lineDraw.path();
      node.style.line(line1);
      line1.plot(this.transformPath(`M ${x1},${y1} L ${x1},${y1 + s1}`));
      node._lines.push(line1);
      style && style(line1, node);
      if (len > 0) {
        let lin2 = this.lineDraw.path();
        node.style.line(lin2);
        lin2.plot(this.transformPath(`M ${minx},${y1 + s1} L ${maxx},${y1 + s1}`));
        node._lines.push(lin2);
        style && style(lin2, node);
      }
    } else {
      let y1 = top + height;
      let maxy = -Infinity;
      let x2 = node.left + node.width * 0.3;
      node.children.forEach((item, index) => {
        let y2 = item.top + item.height / 2;
        if (y2 > maxy) {
          maxy = y2;
        }
        let path = "";
        let _left = item.left;
        let _isLeft = item.left + item.width < x2;
        let _isXCenter = false;
        if (_isLeft) {
          _left = item.left + item.width;
        } else if (item.left < x2 && item.left + item.width > x2) {
          _isXCenter = true;
          y2 = item.top;
          maxy = y2;
        }
        if (y2 > top && y2 < y1) {
          path = `M ${_isLeft ? node.left : node.left + node.width},${y2} L ${_left},${y2}`;
        } else if (y2 < y1) {
          if (_isXCenter) {
            y2 = item.top + item.height;
            _left = x2;
          }
          path = `M ${x2},${top} L ${x2},${y2} L ${_left},${y2}`;
        } else {
          if (_isXCenter) {
            _left = x2;
          }
          path = `M ${x2},${y2} L ${_left},${y2}`;
        }
        let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle ? ` L ${_left},${y2 - item.height / 2} L ${_left},${y2 + item.height / 2}` : "";
        path += nodeUseLineStylePath;
        this.setLineStyle(style, lines[index], path, item);
      });
      if (len > 0) {
        let lin2 = this.lineDraw.path();
        expandBtnSize = len > 0 ? expandBtnSize : 0;
        node.style.line(lin2);
        if (maxy < y1 + expandBtnSize) {
          lin2.hide();
        } else {
          lin2.plot(
            this.transformPath(`M ${x2},${y1 + expandBtnSize} L ${x2},${maxy}`)
          );
          lin2.show();
        }
        node._lines.push(lin2);
        style && style(lin2, node);
      }
    }
  }
  //  渲染按钮
  renderExpandBtn(node, btn) {
    let { width, height, expandBtnSize, isRoot } = node;
    if (!isRoot) {
      let { translateX, translateY } = btn.transform();
      btn.translate(
        width * 0.3 - expandBtnSize / 2 - translateX,
        height + expandBtnSize / 2 - translateY
      );
    }
  }
  //  创建概要节点
  renderGeneralization(list) {
    list.forEach((item) => {
      let {
        top,
        bottom,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x1 = right + generalizationLineMargin;
      let y1 = top;
      let x2 = right + generalizationLineMargin;
      let y2 = bottom;
      let cx = x1 + 20;
      let cy = y1 + (y2 - y1) / 2;
      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;
      item.generalizationLine.plot(this.transformPath(path));
      item.generalizationNode.left = right + generalizationNodeMargin;
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {
    rect.size(width, expandBtnSize).x(0).y(height);
  }
};
var CatalogOrganization_default = CatalogOrganization;

// node_modules/simple-mind-map/src/layouts/OrganizationStructure.js
var OrganizationStructure = class extends Base_default {
  //  构造函数
  constructor(opt = {}) {
    super(opt);
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedLeftValue();
      },
      () => {
        this.adjustLeftValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据计算节点的left、width、height
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index, ancestors) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex, index, ancestors);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          newNode.top = parent._node.top + parent._node.height + this.getMarginX(layerIndex);
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        let len = cur.data.expand === false ? 0 : cur._node.children.length;
        cur._node.childrenAreaWidth = len ? cur._node.children.reduce((h, item) => {
          return h + item.width;
        }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;
        let generalizationNodeWidth = cur._node.checkHasGeneralization() ? cur._node._generalizationNodeWidth + this.getMarginY(layerIndex + 1) : 0;
        cur._node.childrenAreaWidth2 = Math.max(
          cur._node.childrenAreaWidth,
          generalizationNodeWidth
        );
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的left
  computedLeftValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (node.getData("expand") && node.children && node.children.length) {
          let marginX = this.getMarginY(layerIndex + 1);
          let left = node.left + node.width / 2 - node.childrenAreaWidth / 2;
          let totalLeft = left + marginX;
          node.children.forEach((cur) => {
            cur.left = totalLeft;
            totalLeft += cur.width + marginX;
          });
        }
      },
      null,
      true
    );
  }
  //  调整节点left
  adjustLeftValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (!node.getData("expand")) {
          return;
        }
        let difference = node.childrenAreaWidth2 - this.getMarginY(layerIndex + 1) * 2 - node.width;
        if (difference > 0) {
          this.updateBrothers(node, difference / 2);
        }
      },
      null,
      true
    );
  }
  //  更新兄弟节点的left
  updateBrothers(node, addWidth) {
    if (node.parent) {
      let childrenList = node.parent.children;
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index < index) {
          _offset = -addWidth;
        } else if (_index > index) {
          _offset = addWidth;
        }
        item.left += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "left", _offset);
        }
      });
      this.updateBrothers(node.parent, addWidth);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node, lines, style, lineStyle) {
    if (lineStyle === "direct") {
      this.renderLineDirect(node, lines, style);
    } else {
      this.renderLineStraight(node, lines, style);
    }
  }
  //  直连风格
  renderLineDirect(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height } = node;
    const { nodeUseLineStyle } = this.mindMap.themeConfig;
    let x1 = left + width / 2;
    let y1 = top + height;
    node.children.forEach((item, index) => {
      let x2 = item.left + item.width / 2;
      let y2 = item.top;
      let nodeUseLineStylePath = nodeUseLineStyle ? ` L ${item.left},${y2} L ${item.left + item.width},${y2}` : "";
      let path = `M ${x1},${y1} L ${x2},${y2}` + nodeUseLineStylePath;
      this.setLineStyle(style, lines[index], path, item);
    });
  }
  //  直线风格连线
  renderLineStraight(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize, isRoot } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    let x1 = left + width / 2;
    let y1 = top + height;
    let marginX = this.getMarginX(node.layerIndex + 1);
    let s1 = marginX * 0.7;
    let minx = Infinity;
    let maxx = -Infinity;
    let len = node.children.length;
    node.children.forEach((item, index) => {
      let x2 = item.left + item.width / 2;
      let y2 = y1 + s1 > item.top ? item.top + item.height : item.top;
      if (x2 < minx) {
        minx = x2;
      }
      if (x2 > maxx) {
        maxx = x2;
      }
      let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle ? ` L ${item.left},${y2} L ${item.left + item.width},${y2}` : "";
      let path = `M ${x2},${y1 + s1} L ${x2},${y2}` + nodeUseLineStylePath;
      this.setLineStyle(style, lines[index], path, item);
    });
    minx = Math.min(x1, minx);
    maxx = Math.max(x1, maxx);
    let line1 = this.lineDraw.path();
    node.style.line(line1);
    expandBtnSize = len > 0 && !isRoot ? expandBtnSize : 0;
    line1.plot(
      this.transformPath(`M ${x1},${y1 + expandBtnSize} L ${x1},${y1 + s1}`)
    );
    node._lines.push(line1);
    style && style(line1, node);
    if (len > 0) {
      let lin2 = this.lineDraw.path();
      node.style.line(lin2);
      lin2.plot(this.transformPath(`M ${minx},${y1 + s1} L ${maxx},${y1 + s1}`));
      node._lines.push(lin2);
      style && style(lin2, node);
    }
  }
  //  渲染按钮
  renderExpandBtn(node, btn) {
    let { width, height, expandBtnSize } = node;
    let { translateX, translateY } = btn.transform();
    btn.translate(
      width / 2 - expandBtnSize / 2 - translateX,
      height + expandBtnSize / 2 - translateY
    );
  }
  //  创建概要节点
  renderGeneralization(list) {
    list.forEach((item) => {
      let {
        bottom,
        left,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "v");
      let x1 = left;
      let y1 = bottom + generalizationLineMargin;
      let x2 = right;
      let y2 = bottom + generalizationLineMargin;
      let cx = x1 + (x2 - x1) / 2;
      let cy = y1 + 20;
      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;
      item.generalizationLine.plot(this.transformPath(path));
      item.generalizationNode.top = bottom + generalizationNodeMargin;
      item.generalizationNode.left = left + (right - left - item.generalizationNode.width) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {
    rect.size(width, expandBtnSize).x(0).y(height);
  }
};
var OrganizationStructure_default = OrganizationStructure;

// node_modules/simple-mind-map/src/layouts/Timeline.js
var Timeline = class extends Base_default {
  //  构造函数
  constructor(opt = {}, layout) {
    super(opt);
    this.layout = layout;
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedLeftTopValue();
      },
      () => {
        this.adjustLeftTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据创建节点、计算根节点的位置，计算根节点的子节点的top值
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index, ancestors) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex, index, ancestors);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (this.layout === CONSTANTS.LAYOUT.TIMELINE2) {
            if (parent._node.dir) {
              newNode.dir = parent._node.dir;
            } else {
              newNode.dir = index % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.BOTTOM : CONSTANTS.LAYOUT_GROW_DIR.TOP;
            }
          } else {
            newNode.dir = "";
          }
          if (parent._node.isRoot) {
            newNode.top = parent._node.top + (cur._node.height > parent._node.height ? -(cur._node.height - parent._node.height) / 2 : (parent._node.height - cur._node.height) / 2);
          }
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      null,
      true,
      0
    );
  }
  //  遍历节点树计算节点的left、top
  computedLeftTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex, index) => {
        if (node.getData("expand") && node.children && node.children.length) {
          let marginX = this.getMarginX(layerIndex + 1);
          let marginY = this.getMarginY(layerIndex + 1);
          if (isRoot) {
            let left = node.left + node.width;
            let totalLeft = left + marginX;
            node.children.forEach((cur) => {
              cur.left = totalLeft;
              totalLeft += cur.width + marginX;
            });
          } else {
            let totalTop = node.top + node.height + marginY + (this.getNodeActChildrenLength(node) > 0 ? node.expandBtnSize : 0);
            node.children.forEach((cur) => {
              cur.left = node.left + node.width * 0.5;
              cur.top = totalTop;
              totalTop += cur.height + marginY + (this.getNodeActChildrenLength(cur) > 0 ? cur.expandBtnSize : 0);
            });
          }
        }
      },
      null,
      true
    );
  }
  //  调整节点left、top
  adjustLeftTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (!node.getData("expand")) {
          return;
        }
        if (node.isRoot) {
          this.updateBrothersLeft(node);
        }
        let len = node.children.length;
        if (parent && !parent.isRoot && len > 0) {
          let marginY = this.getMarginY(layerIndex + 1);
          let totalHeight = node.children.reduce((h, item) => {
            return h + item.height + (this.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0);
          }, 0) + len * marginY;
          this.updateBrothersTop(node, totalHeight);
        }
      },
      (node, parent, isRoot, layerIndex) => {
        if (parent && parent.isRoot && node.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
          node.children.forEach((item) => {
            let totalHeight = this.getNodeAreaHeight(item);
            let _top = item.top;
            item.top = node.top - (item.top - node.top) - totalHeight + node.height;
            this.updateChildren(item.children, "top", item.top - _top);
          });
        }
      },
      true
    );
  }
  //  递归计算节点的宽度
  getNodeAreaHeight(node) {
    let totalHeight = 0;
    let loop = (node2) => {
      totalHeight += node2.height + (this.getNodeActChildrenLength(node2) > 0 ? node2.expandBtnSize : 0) + this.getMarginY(node2.layerIndex);
      if (node2.children.length) {
        node2.children.forEach((item) => {
          loop(item);
        });
      }
    };
    loop(node);
    return totalHeight;
  }
  //  调整兄弟节点的left
  updateBrothersLeft(node) {
    let childrenList = node.children;
    let totalAddWidth = 0;
    childrenList.forEach((item) => {
      item.left += totalAddWidth;
      if (item.children && item.children.length) {
        this.updateChildren(item.children, "left", totalAddWidth);
      }
      let { left, right } = this.getNodeBoundaries(item, "h");
      let areaWidth = right - left;
      let difference = areaWidth - item.width;
      if (difference > 0) {
        totalAddWidth += difference;
      }
    });
  }
  //  调整兄弟节点的top
  updateBrothersTop(node, addHeight) {
    if (node.parent && !node.parent.isRoot) {
      let childrenList = node.parent.children;
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index > index) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothersTop(node.parent, addHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    let len = node.children.length;
    if (node.isRoot) {
      let prevBother = node;
      node.children.forEach((item, index) => {
        let x1 = prevBother.left + prevBother.width;
        let x2 = item.left;
        let y = node.top + node.height / 2;
        let path = `M ${x1},${y} L ${x2},${y}`;
        this.setLineStyle(style, lines[index], path, item);
        prevBother = item;
      });
    } else {
      let maxy = -Infinity;
      let miny = Infinity;
      let x = node.left + node.width * 0.3;
      node.children.forEach((item, index) => {
        let y = item.top + item.height / 2;
        if (y > maxy) {
          maxy = y;
        }
        if (y < miny) {
          miny = y;
        }
        let path = `M ${x},${y} L ${item.left},${y}`;
        this.setLineStyle(style, lines[index], path, item);
      });
      if (len > 0) {
        let line = this.lineDraw.path();
        expandBtnSize = len > 0 ? expandBtnSize : 0;
        if (node.parent && node.parent.isRoot && node.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
          line.plot(this.transformPath(`M ${x},${top} L ${x},${miny}`));
        } else {
          line.plot(
            this.transformPath(
              `M ${x},${top + height + expandBtnSize} L ${x},${maxy}`
            )
          );
        }
        node.style.line(line);
        node._lines.push(line);
        style && style(line, node);
      }
    }
  }
  //  渲染按钮
  renderExpandBtn(node, btn) {
    let { width, height, expandBtnSize, isRoot } = node;
    if (!isRoot) {
      let { translateX, translateY } = btn.transform();
      if (node.parent && node.parent.isRoot && node.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
        btn.translate(
          width * 0.3 - expandBtnSize / 2 - translateX,
          -expandBtnSize / 2 - translateY
        );
      } else {
        btn.translate(
          width * 0.3 - expandBtnSize / 2 - translateX,
          height + expandBtnSize / 2 - translateY
        );
      }
    }
  }
  //  创建概要节点
  renderGeneralization(list) {
    list.forEach((item) => {
      let {
        top,
        bottom,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x1 = right + generalizationLineMargin;
      let y1 = top;
      let x2 = right + generalizationLineMargin;
      let y2 = bottom;
      let cx = x1 + 20;
      let cy = y1 + (y2 - y1) / 2;
      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;
      item.generalizationLine.plot(this.transformPath(path));
      item.generalizationNode.left = right + generalizationNodeMargin;
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {
    if (this.layout === CONSTANTS.LAYOUT.TIMELINE) {
      rect.size(width, expandBtnSize).x(0).y(height);
    } else {
      let dir = "";
      if (node.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
        dir = node.layerIndex === 1 ? CONSTANTS.LAYOUT_GROW_DIR.TOP : CONSTANTS.LAYOUT_GROW_DIR.BOTTOM;
      } else {
        dir = CONSTANTS.LAYOUT_GROW_DIR.BOTTOM;
      }
      if (dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
        rect.size(width, expandBtnSize).x(0).y(-expandBtnSize);
      } else {
        rect.size(width, expandBtnSize).x(0).y(height);
      }
    }
  }
};
var Timeline_default = Timeline;

// node_modules/simple-mind-map/src/layouts/VerticalTimeline.js
var VerticalTimeline = class extends Base_default {
  //  构造函数
  constructor(opt = {}, layout) {
    super(opt);
    this.layout = layout;
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedTopValue();
      },
      () => {
        this.adjustLeftTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据创建节点、计算根节点的位置，计算根节点的子节点的top值
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index, ancestors) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex, index, ancestors);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (parent._node.dir) {
            newNode.dir = parent._node.dir;
          } else {
            newNode.dir = index % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.RIGHT : CONSTANTS.LAYOUT_GROW_DIR.LEFT;
          }
          if (parent._node.isRoot) {
            newNode.left = parent._node.left + (cur._node.width > parent._node.width ? -(cur._node.width - parent._node.width) / 2 : (parent._node.width - cur._node.width) / 2);
          } else {
            newNode.left = newNode.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT ? parent._node.left + parent._node.width + this.getMarginX(layerIndex) : parent._node.left - this.getMarginX(layerIndex) - newNode.width;
          }
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        if (isRoot) {
          return;
        }
        let len = cur.data.expand === false ? 0 : cur._node.children.length;
        cur._node.childrenAreaHeight = len ? cur._node.children.reduce((h, item) => {
          return h + item.height;
        }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的top
  computedTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex, index) => {
        if (node.getData("expand") && node.children && node.children.length) {
          let marginY = this.getMarginY(layerIndex + 1);
          if (isRoot) {
            let top = node.top + node.height;
            let totalTop = top + marginY;
            node.children.forEach((cur) => {
              cur.top = totalTop;
              totalTop += cur.height + marginY;
            });
          } else {
            let marginY2 = this.getMarginY(layerIndex + 1);
            let baseTop = node.top + node.height / 2 + marginY2;
            let totalTop = baseTop - node.childrenAreaHeight / 2;
            node.children.forEach((cur) => {
              cur.top = totalTop;
              totalTop += cur.height + marginY2;
            });
          }
        }
      },
      null,
      true
    );
  }
  //  调整节点left、top
  adjustLeftTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (!node.getData("expand")) {
          return;
        }
        if (isRoot) return;
        let base = this.getMarginY(layerIndex + 1) * 2 + node.height;
        let difference = node.childrenAreaHeight - base;
        if (difference > 0) {
          this.updateBrothers(node, difference / 2);
        }
      },
      null,
      true
    );
  }
  //  更新兄弟节点的top
  updateBrothers(node, addHeight) {
    if (node.parent) {
      let childrenList = node.parent.children;
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) return;
        if (!node.parent.isRoot && item.uid === node.uid) return;
        let _offset = 0;
        if (node.parent.isRoot) {
          if (_index < index) {
            _offset = 0;
          } else if (_index > index) {
            _offset = addHeight * 2;
          } else {
            _offset = addHeight;
          }
        } else {
          if (_index < index) {
            _offset = -addHeight;
          } else if (_index > index) {
            _offset = addHeight;
          }
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothers(node.parent, addHeight);
    }
  }
  //  调整兄弟节点的top
  updateBrothersTop(node, addHeight) {
    if (node.parent && !node.parent.isRoot) {
      let childrenList = node.parent.children;
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index > index) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothersTop(node.parent, addHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node, lines, style, lineStyle) {
    if (lineStyle === "curve") {
      this.renderLineCurve(node, lines, style);
    } else if (lineStyle === "direct") {
      this.renderLineDirect(node, lines, style);
    } else {
      this.renderLineStraight(node, lines, style);
    }
  }
  // 直线连接
  renderLineStraight(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    if (node.isRoot) {
      let prevBother = node;
      node.children.forEach((item, index) => {
        let y1 = prevBother.top + prevBother.height;
        let y2 = item.top;
        let x = node.left + node.width / 2;
        let path = `M ${x},${y1} L ${x},${y2}`;
        this.setLineStyle(style, lines[index], path, item);
        prevBother = item;
      });
    } else {
      if (node.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT) {
        let nodeRight = node.left + node.width;
        let nodeYCenter = node.top + node.height / 2;
        let marginX = this.getMarginX(node.layerIndex + 1);
        let offset = (marginX - expandBtnSize) * 0.6;
        node.children.forEach((item, index) => {
          let itemLeft = item.left;
          let itemYCenter = item.top + item.height / 2;
          let path = this.createFoldLine([
            [nodeRight, nodeYCenter],
            [nodeRight + offset, nodeYCenter],
            [nodeRight + offset, itemYCenter],
            [itemLeft, itemYCenter]
          ]);
          this.setLineStyle(style, lines[index], path, item);
        });
      } else {
        let nodeLeft = node.left;
        let nodeYCenter = node.top + node.height / 2;
        let marginX = this.getMarginX(node.layerIndex + 1);
        let offset = (marginX - expandBtnSize) * 0.6;
        node.children.forEach((item, index) => {
          let itemRight = item.left + item.width;
          let itemYCenter = item.top + item.height / 2;
          let path = this.createFoldLine([
            [nodeLeft, nodeYCenter],
            [nodeLeft - offset, nodeYCenter],
            [nodeLeft - offset, itemYCenter],
            [itemRight, itemYCenter]
          ]);
          this.setLineStyle(style, lines[index], path, item);
        });
      }
    }
  }
  // 直连
  renderLineDirect(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    node.children.forEach((item, index) => {
      if (node.isRoot) {
        let prevBother = node;
        node.children.forEach((item2, index2) => {
          let y1 = prevBother.top + prevBother.height;
          let y2 = item2.top;
          let x = node.left + node.width / 2;
          let path = `M ${x},${y1} L ${x},${y2}`;
          this.setLineStyle(style, lines[index2], path, item2);
          prevBother = item2;
        });
      } else {
        let x1 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width + expandBtnSize;
        let y1 = top + height / 2;
        let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
        let y2 = item.top + item.height / 2;
        let path = `M ${x1},${y1} L ${x2},${y2}`;
        this.setLineStyle(style, lines[index], path, item);
      }
    });
  }
  //  曲线风格连线
  renderLineCurve(node, lines, style) {
    if (node.children.length <= 0) {
      return [];
    }
    let { left, top, width, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    node.children.forEach((item, index) => {
      if (node.isRoot) {
        let prevBother = node;
        node.children.forEach((item2, index2) => {
          let y1 = prevBother.top + prevBother.height;
          let y2 = item2.top;
          let x = node.left + node.width / 2;
          let path = `M ${x},${y1} L ${x},${y2}`;
          this.setLineStyle(style, lines[index2], path, item2);
          prevBother = item2;
        });
      } else {
        let x1 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width + expandBtnSize;
        let y1 = top + height / 2;
        let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
        let y2 = item.top + item.height / 2;
        let path = this.cubicBezierPath(x1, y1, x2, y2);
        this.setLineStyle(style, lines[index], path, item);
      }
    });
  }
  //  渲染按钮
  renderExpandBtn(node, btn) {
    let { width, height, expandBtnSize, isRoot } = node;
    if (!isRoot) {
      let { translateX, translateY } = btn.transform();
      if (node.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT) {
        btn.translate(width - translateX, height / 2 - translateY);
      } else {
        btn.translate(-expandBtnSize - translateX, height / 2 - translateY);
      }
    }
  }
  //  创建概要节点
  renderGeneralization(list) {
    list.forEach((item) => {
      let isLeft = item.node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT;
      let {
        top,
        bottom,
        left,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x = isLeft ? left - generalizationLineMargin : right + generalizationLineMargin;
      let x1 = x;
      let y1 = top;
      let x2 = x;
      let y2 = bottom;
      let cx = x1 + (isLeft ? -20 : 20);
      let cy = y1 + (y2 - y1) / 2;
      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;
      item.generalizationLine.plot(this.transformPath(path));
      item.generalizationNode.left = x + (isLeft ? -generalizationNodeMargin : generalizationNodeMargin) - (isLeft ? item.generalizationNode.width : 0);
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {
    if (node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
      rect.size(expandBtnSize, height).x(-expandBtnSize).y(0);
    } else {
      rect.size(expandBtnSize, height).x(width).y(0);
    }
  }
};
var VerticalTimeline_default = VerticalTimeline;

// node_modules/simple-mind-map/src/layouts/fishboneUtils.js
var fishboneUtils_default = {
  top: {
    renderExpandBtn({
      node,
      btn,
      expandBtnSize,
      translateX,
      translateY,
      width,
      height
    }) {
      if (node.parent && node.parent.isRoot) {
        btn.translate(
          width * 0.3 - expandBtnSize / 2 - translateX,
          -expandBtnSize / 2 - translateY
        );
      } else {
        btn.translate(
          width * 0.3 - expandBtnSize / 2 - translateX,
          height + expandBtnSize / 2 - translateY
        );
      }
    },
    renderLine({
      node,
      line,
      top,
      x,
      lineLength,
      height,
      expandBtnSize,
      maxy,
      ctx
    }) {
      if (node.parent && node.parent.isRoot) {
        line.plot(
          ctx.transformPath(
            `M ${x},${top} L ${x + lineLength},${top - Math.tan(degToRad(ctx.mindMap.opt.fishboneDeg)) * lineLength}`
          )
        );
      } else {
        line.plot(
          ctx.transformPath(
            `M ${x},${top + height + expandBtnSize} L ${x},${maxy}`
          )
        );
      }
    },
    computedLeftTopValue({ layerIndex, node, ctx }) {
      if (layerIndex >= 1 && node.children) {
        let marginY = ctx.getMarginY(layerIndex + 1);
        let startLeft = node.left + node.width * ctx.childIndent;
        let totalTop = node.top + node.height + (ctx.getNodeActChildrenLength(node) > 0 ? node.expandBtnSize : 0) + marginY;
        node.children.forEach((item) => {
          item.left = startLeft;
          item.top += totalTop;
          totalTop += item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        });
      }
    },
    adjustLeftTopValueBefore({ node, parent, ctx, layerIndex }) {
      let len = node.children.length;
      let marginY = ctx.getMarginY(layerIndex + 1);
      if (parent && !parent.isRoot && len > 0) {
        let totalHeight = node.children.reduce((h, item) => {
          return h + item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        }, 0);
        ctx.updateBrothersTop(node, totalHeight);
      }
    },
    adjustLeftTopValueAfter({ parent, node, ctx }) {
      if (parent && parent.isRoot) {
        let marginY = ctx.getMarginY(node.layerIndex + 1);
        let totalHeight = node.expandBtnSize + marginY;
        node.children.forEach((item) => {
          let nodeTotalHeight = ctx.getNodeAreaHeight(item);
          let _top = item.top;
          let _left = item.left;
          item.top = node.top - (item.top - node.top) - nodeTotalHeight + node.height;
          item.left = node.left + node.width * ctx.indent + (nodeTotalHeight + totalHeight) / Math.tan(degToRad(ctx.mindMap.opt.fishboneDeg));
          totalHeight += nodeTotalHeight;
          ctx.updateChildrenPro(item.children, {
            top: item.top - _top,
            left: item.left - _left
          });
        });
      }
    }
  },
  bottom: {
    renderExpandBtn({
      node,
      btn,
      expandBtnSize,
      translateX,
      translateY,
      width,
      height
    }) {
      if (node.parent && node.parent.isRoot) {
        btn.translate(
          width * 0.3 - expandBtnSize / 2 - translateX,
          height + expandBtnSize / 2 - translateY
        );
      } else {
        btn.translate(
          width * 0.3 - expandBtnSize / 2 - translateX,
          -expandBtnSize / 2 - translateY
        );
      }
    },
    renderLine({ node, line, top, x, lineLength, height, miny, ctx }) {
      if (node.parent && node.parent.isRoot) {
        line.plot(
          ctx.transformPath(
            `M ${x},${top + height} L ${x + lineLength},${top + height + Math.tan(degToRad(ctx.mindMap.opt.fishboneDeg)) * lineLength}`
          )
        );
      } else {
        line.plot(ctx.transformPath(`M ${x},${top} L ${x},${miny}`));
      }
    },
    computedLeftTopValue({ layerIndex, node, ctx }) {
      let marginY = ctx.getMarginY(layerIndex + 1);
      if (layerIndex === 1 && node.children) {
        let startLeft = node.left + node.width * ctx.childIndent;
        let totalTop = node.top + node.height + (ctx.getNodeActChildrenLength(node) > 0 ? node.expandBtnSize : 0) + marginY;
        node.children.forEach((item) => {
          item.left = startLeft;
          item.top = totalTop + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0);
          totalTop += item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        });
      }
      if (layerIndex > 1 && node.children) {
        let startLeft = node.left + node.width * ctx.childIndent;
        let totalTop = node.top - (ctx.getNodeActChildrenLength(node) > 0 ? node.expandBtnSize : 0) - marginY;
        node.children.forEach((item) => {
          item.left = startLeft;
          item.top = totalTop - item.height;
          totalTop -= item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        });
      }
    },
    adjustLeftTopValueBefore({ node, ctx, layerIndex }) {
      let marginY = ctx.getMarginY(layerIndex + 1);
      let len = node.children.length;
      if (layerIndex > 2 && len > 0) {
        let totalHeight = node.children.reduce((h, item) => {
          return h + item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        }, 0);
        ctx.updateBrothersTop(node, -totalHeight);
      }
    },
    adjustLeftTopValueAfter({ parent, node, ctx }) {
      if (parent && parent.isRoot) {
        let marginY = ctx.getMarginY(node.layerIndex + 1);
        let totalHeight = 0;
        let totalHeight2 = node.expandBtnSize;
        node.children.forEach((item) => {
          let hasChildren = ctx.getNodeActChildrenLength(item) > 0;
          let nodeTotalHeight = ctx.getNodeAreaHeight(item);
          let offset = hasChildren ? nodeTotalHeight - item.height - (hasChildren ? item.expandBtnSize : 0) : 0;
          offset -= hasChildren ? marginY : 0;
          let _top = totalHeight + offset;
          let _left = item.left;
          item.top += _top;
          item.left = node.left + node.width * ctx.indent + (nodeTotalHeight + totalHeight2) / Math.tan(degToRad(ctx.mindMap.opt.fishboneDeg));
          totalHeight += offset;
          totalHeight2 += nodeTotalHeight;
          ctx.updateChildrenPro(item.children, {
            top: _top,
            left: item.left - _left
          });
        });
      }
    }
  }
};

// node_modules/simple-mind-map/src/layouts/Fishbone.js
var Fishbone = class extends Base_default {
  //  构造函数
  constructor(opt = {}) {
    super(opt);
    this.indent = 0.3;
    this.childIndent = 0.5;
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedLeftTopValue();
      },
      () => {
        this.adjustLeftTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据创建节点、计算根节点的位置，计算根节点的子节点的top值
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (node, parent, isRoot, layerIndex, index, ancestors) => {
        let newNode = this.createNode(node, parent, isRoot, layerIndex, index, ancestors);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (parent._node.dir) {
            newNode.dir = parent._node.dir;
          } else {
            newNode.dir = index % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.TOP : CONSTANTS.LAYOUT_GROW_DIR.BOTTOM;
          }
          if (parent._node.isRoot) {
            let marginY = this.getMarginY(layerIndex);
            if (this.checkIsTop(newNode)) {
              newNode.top = parent._node.top - newNode.height - marginY;
            } else {
              newNode.top = parent._node.top + parent._node.height + marginY;
            }
          }
        }
        if (!node.data.expand) {
          return true;
        }
      },
      null,
      true,
      0
    );
  }
  //  遍历节点树计算节点的left、top
  computedLeftTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (node.isRoot) {
          let marginX = this.getMarginX(layerIndex + 1);
          let topTotalLeft = node.left + node.width + node.height + marginX;
          let bottomTotalLeft = node.left + node.width + node.height + marginX;
          node.children.forEach((item) => {
            if (this.checkIsTop(item)) {
              item.left = topTotalLeft;
              topTotalLeft += item.width + marginX;
            } else {
              item.left = bottomTotalLeft + 20;
              bottomTotalLeft += item.width + marginX;
            }
          });
        }
        let params = { layerIndex, node, ctx: this };
        if (this.checkIsTop(node)) {
          fishboneUtils_default.top.computedLeftTopValue(params);
        } else {
          fishboneUtils_default.bottom.computedLeftTopValue(params);
        }
      },
      null,
      true
    );
  }
  //  调整节点left、top
  adjustLeftTopValue() {
    walk(
      this.root,
      null,
      (node, parent, isRoot, layerIndex) => {
        if (!node.getData("expand")) {
          return;
        }
        let params = { node, parent, layerIndex, ctx: this };
        if (this.checkIsTop(node)) {
          fishboneUtils_default.top.adjustLeftTopValueBefore(params);
        } else {
          fishboneUtils_default.bottom.adjustLeftTopValueBefore(params);
        }
      },
      (node, parent) => {
        let params = { parent, node, ctx: this };
        if (this.checkIsTop(node)) {
          fishboneUtils_default.top.adjustLeftTopValueAfter(params);
        } else {
          fishboneUtils_default.bottom.adjustLeftTopValueAfter(params);
        }
        if (node.isRoot) {
          let topTotalLeft = 0;
          let bottomTotalLeft = 0;
          node.children.forEach((item) => {
            if (this.checkIsTop(item)) {
              item.left += topTotalLeft;
              this.updateChildren(item.children, "left", topTotalLeft);
              let { left, right } = this.getNodeBoundaries(item, "h");
              topTotalLeft += right - left;
            } else {
              item.left += bottomTotalLeft;
              this.updateChildren(item.children, "left", bottomTotalLeft);
              let { left, right } = this.getNodeBoundaries(item, "h");
              bottomTotalLeft += right - left;
            }
          });
        }
      },
      true
    );
  }
  //  递归计算节点的宽度
  getNodeAreaHeight(node) {
    let totalHeight = 0;
    let loop = (node2) => {
      let marginY = this.getMarginY(node2.layerIndex);
      totalHeight += node2.height + (this.getNodeActChildrenLength(node2) > 0 ? node2.expandBtnSize : 0) + marginY;
      if (node2.children.length) {
        node2.children.forEach((item) => {
          loop(item);
        });
      }
    };
    loop(node);
    return totalHeight;
  }
  //  调整兄弟节点的left
  updateBrothersLeft(node) {
    let childrenList = node.children;
    let totalAddWidth = 0;
    childrenList.forEach((item) => {
      item.left += totalAddWidth;
      if (item.children && item.children.length) {
        this.updateChildren(item.children, "left", totalAddWidth);
      }
      let { left, right } = this.getNodeBoundaries(item, "h");
      let areaWidth = right - left;
      let difference = areaWidth - item.width;
      if (difference > 0) {
        totalAddWidth += difference;
      }
    });
  }
  //  调整兄弟节点的top
  updateBrothersTop(node, addHeight) {
    if (node.parent && !node.parent.isRoot) {
      let childrenList = node.parent.children;
      let index = getNodeIndexInNodeList(node, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index > index) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      if (this.checkIsTop(node)) {
        this.updateBrothersTop(node.parent, addHeight);
      } else {
        this.updateBrothersTop(
          node.parent,
          node.layerIndex === 3 ? 0 : addHeight
        );
      }
    }
  }
  // 检查节点是否是上方节点
  checkIsTop(node) {
    return node.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP;
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node, lines, style) {
    if (node.layerIndex !== 1 && node.children.length <= 0) {
      return [];
    }
    let { top, height, expandBtnSize } = node;
    const { alwaysShowExpandBtn, notShowExpandBtn } = this.mindMap.opt;
    if (!alwaysShowExpandBtn || notShowExpandBtn) {
      expandBtnSize = 0;
    }
    let len = node.children.length;
    if (node.isRoot) {
      let maxx = -Infinity;
      node.children.forEach((item) => {
        if (item.left > maxx) {
          maxx = item.left;
        }
        let marginY = this.getMarginY(item.layerIndex);
        let nodeLineX = item.left;
        let offset2 = node.height / 2 + marginY;
        let offsetX = offset2 / Math.tan(degToRad(this.mindMap.opt.fishboneDeg));
        let line2 = this.lineDraw.path();
        if (this.checkIsTop(item)) {
          line2.plot(
            this.transformPath(
              `M ${nodeLineX - offsetX},${item.top + item.height + offset2} L ${item.left},${item.top + item.height}`
            )
          );
        } else {
          line2.plot(
            this.transformPath(
              `M ${nodeLineX - offsetX},${item.top - offset2} L ${nodeLineX},${item.top}`
            )
          );
        }
        node.style.line(line2);
        node._lines.push(line2);
        style && style(line2, node);
      });
      let nodeHalfTop = node.top + node.height / 2;
      let offset = node.height / 2 + this.getMarginY(node.layerIndex + 1);
      let line = this.lineDraw.path();
      line.plot(
        this.transformPath(
          `M ${node.left + node.width},${nodeHalfTop} L ${maxx - offset / Math.tan(degToRad(this.mindMap.opt.fishboneDeg))},${nodeHalfTop}`
        )
      );
      node.style.line(line);
      node._lines.push(line);
      style && style(line, node);
    } else {
      let maxy = -Infinity;
      let miny = Infinity;
      let maxx = -Infinity;
      let x = node.left + node.width * this.indent;
      node.children.forEach((item, index) => {
        if (item.left > maxx) {
          maxx = item.left;
        }
        let y = item.top + item.height / 2;
        if (y > maxy) {
          maxy = y;
        }
        if (y < miny) {
          miny = y;
        }
        if (node.layerIndex > 1) {
          let path = `M ${x},${y} L ${item.left},${y}`;
          this.setLineStyle(style, lines[index], path, item);
        }
      });
      if (len >= 0) {
        let line = this.lineDraw.path();
        expandBtnSize = len > 0 ? expandBtnSize : 0;
        let lineLength = maxx - node.left - node.width * this.indent;
        lineLength = Math.max(lineLength, 0);
        let params = {
          node,
          line,
          top,
          x,
          lineLength,
          height,
          expandBtnSize,
          maxy,
          miny,
          ctx: this
        };
        if (this.checkIsTop(node)) {
          fishboneUtils_default.top.renderLine(params);
        } else {
          fishboneUtils_default.bottom.renderLine(params);
        }
        node.style.line(line);
        node._lines.push(line);
        style && style(line, node);
      }
    }
  }
  //  渲染按钮
  renderExpandBtn(node, btn) {
    let { width, height, expandBtnSize, isRoot } = node;
    if (!isRoot) {
      let { translateX, translateY } = btn.transform();
      let params = {
        node,
        btn,
        expandBtnSize,
        translateX,
        translateY,
        width,
        height
      };
      if (this.checkIsTop(node)) {
        fishboneUtils_default.top.renderExpandBtn(params);
      } else {
        fishboneUtils_default.bottom.renderExpandBtn(params);
      }
    }
  }
  //  创建概要节点
  renderGeneralization(list) {
    list.forEach((item) => {
      let {
        top,
        bottom,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x1 = right + generalizationLineMargin;
      let y1 = top;
      let x2 = right + generalizationLineMargin;
      let y2 = bottom;
      let cx = x1 + 20;
      let cy = y1 + (y2 - y1) / 2;
      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;
      item.generalizationLine.plot(this.transformPath(path));
      item.generalizationNode.left = right + generalizationNodeMargin;
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {
    let dir = "";
    if (node.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
      dir = node.layerIndex === 1 ? CONSTANTS.LAYOUT_GROW_DIR.TOP : CONSTANTS.LAYOUT_GROW_DIR.BOTTOM;
    } else {
      dir = node.layerIndex === 1 ? CONSTANTS.LAYOUT_GROW_DIR.BOTTOM : CONSTANTS.LAYOUT_GROW_DIR.TOP;
    }
    if (dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
      rect.size(width, expandBtnSize).x(0).y(-expandBtnSize);
    } else {
      rect.size(width, expandBtnSize).x(0).y(height);
    }
  }
};
var Fishbone_default = Fishbone;

// node_modules/simple-mind-map/src/core/render/TextEdit.js
var TextEdit = class {
  //  构造函数
  constructor(renderer) {
    this.renderer = renderer;
    this.mindMap = renderer.mindMap;
    this.currentNode = null;
    this.textEditNode = null;
    this.showTextEdit = false;
    this.cacheEditingText = "";
    this.hasBodyMousedown = false;
    this.bindEvent();
  }
  //  事件
  bindEvent() {
    this.show = this.show.bind(this);
    this.onScale = this.onScale.bind(this);
    this.onKeydown = this.onKeydown.bind(this);
    this.mindMap.on("node_dblclick", (node, e, isInserting) => {
      this.show({ node, e, isInserting });
    });
    this.mindMap.on("draw_click", () => {
      this.hideEditTextBox();
    });
    this.mindMap.on("body_mousedown", () => {
      this.hasBodyMousedown = true;
    });
    this.mindMap.on("body_click", () => {
      if (!this.hasBodyMousedown) return;
      this.hasBodyMousedown = false;
      if (this.mindMap.opt.isEndNodeTextEditOnClickOuter) {
        this.hideEditTextBox();
      }
    });
    this.mindMap.on("svg_mousedown", () => {
      this.hideEditTextBox();
    });
    this.mindMap.on("expand_btn_click", () => {
      this.hideEditTextBox();
    });
    this.mindMap.on("before_node_active", () => {
      this.hideEditTextBox();
    });
    this.mindMap.on("mousewheel", () => {
      if (this.mindMap.opt.mousewheelAction === CONSTANTS.MOUSE_WHEEL_ACTION.MOVE) {
        this.hideEditTextBox();
      }
    });
    this.mindMap.keyCommand.addShortcut("F2", () => {
      if (this.renderer.activeNodeList.length <= 0) {
        return;
      }
      this.show({
        node: this.renderer.activeNodeList[0]
      });
    });
    this.mindMap.on("scale", this.onScale);
    if (this.mindMap.opt.enableAutoEnterTextEditWhenKeydown) {
      window.addEventListener("keydown", this.onKeydown);
    }
    this.mindMap.on("beforeDestroy", () => {
      this.unBindEvent();
    });
  }
  // 解绑事件
  unBindEvent() {
    window.removeEventListener("keydown", this.onKeydown);
  }
  // 按键事件
  onKeydown(e) {
    const activeNodeList = this.mindMap.renderer.activeNodeList;
    if (activeNodeList.length <= 0 || activeNodeList.length > 1) return;
    const node = activeNodeList[0];
    if (node && this.checkIsAutoEnterTextEditKey(e)) {
      this.show({
        node,
        e,
        isInserting: false,
        isFromKeyDown: true
      });
    }
  }
  // 判断是否是自动进入文本编模式的按钮
  checkIsAutoEnterTextEditKey(e) {
    const keyCode = e.keyCode;
    return (keyCode === 229 || keyCode >= 65 && keyCode <= 90 || keyCode >= 48 && keyCode <= 57) && !this.mindMap.keyCommand.hasCombinationKey(e);
  }
  //  注册临时快捷键
  registerTmpShortcut() {
    this.mindMap.keyCommand.addShortcut("Enter", () => {
      this.hideEditTextBox();
    });
    this.mindMap.keyCommand.addShortcut("Tab", () => {
      this.hideEditTextBox();
    });
  }
  // 获取当前文本编辑框是否处于显示状态，也就是是否处在文本编辑状态
  isShowTextEdit() {
    if (this.mindMap.richText) {
      return this.mindMap.richText.showTextEdit;
    }
    return this.showTextEdit;
  }
  //  显示文本编辑框
  // isInserting：是否是刚创建的节点
  // isFromKeyDown：是否是在按键事件进入的编辑
  async show({
    node,
    isInserting = false,
    isFromKeyDown = false,
    isFromScale = false
  }) {
    if (node.isUseCustomNodeContent()) {
      return;
    }
    const { beforeTextEdit } = this.mindMap.opt;
    if (typeof beforeTextEdit === "function") {
      let isShow = false;
      try {
        isShow = await beforeTextEdit(node, isInserting);
      } catch (error) {
        isShow = false;
        this.mindMap.opt.errorHandler(ERROR_TYPES.BEFORE_TEXT_EDIT_ERROR, error);
      }
      if (!isShow) return;
    }
    this.currentNode = node;
    const { offsetLeft, offsetTop } = checkNodeOuter(this.mindMap, node);
    this.mindMap.view.translateXY(offsetLeft, offsetTop);
    const rect = node._textData.node.node.getBoundingClientRect();
    const params = {
      node,
      rect,
      isInserting,
      isFromKeyDown,
      isFromScale
    };
    if (this.mindMap.richText) {
      this.mindMap.richText.showEditText(params);
      return;
    }
    this.showEditTextBox(params);
  }
  // 处理画布缩放
  onScale() {
    const node = this.getCurrentEditNode();
    if (!node) return;
    if (this.mindMap.richText) {
      this.mindMap.richText.cacheEditingText = this.mindMap.richText.getEditText();
      this.mindMap.richText.showTextEdit = false;
    } else {
      this.cacheEditingText = this.getEditText();
      this.showTextEdit = false;
    }
    this.show({
      node,
      isFromScale: true
    });
  }
  //  显示文本编辑框
  showEditTextBox({ node, rect, isInserting, isFromKeyDown, isFromScale }) {
    if (this.showTextEdit) return;
    const { nodeTextEditZIndex, textAutoWrapWidth, selectTextOnEnterEditText } = this.mindMap.opt;
    if (!isFromScale) {
      this.mindMap.emit("before_show_text_edit");
    }
    this.registerTmpShortcut();
    if (!this.textEditNode) {
      this.textEditNode = document.createElement("div");
      this.textEditNode.style.cssText = `position:fixed;box-sizing: border-box;background-color:#fff;box-shadow: 0 0 20px rgba(0,0,0,.5);padding: 3px 5px;margin-left: -5px;margin-top: -3px;outline: none; word-break: break-all;`;
      this.textEditNode.setAttribute("contenteditable", true);
      this.textEditNode.addEventListener("keyup", (e) => {
        e.stopPropagation();
      });
      this.textEditNode.addEventListener("click", (e) => {
        e.stopPropagation();
      });
      this.textEditNode.addEventListener("mousedown", (e) => {
        e.stopPropagation();
      });
      this.textEditNode.addEventListener("keydown", (e) => {
        if (this.checkIsAutoEnterTextEditKey(e)) {
          e.stopPropagation();
        }
      });
      this.textEditNode.addEventListener("paste", (e) => {
        const text = e.clipboardData.getData("text");
        const { isSmm, data } = checkSmmFormatData(text);
        if (isSmm && data[0] && data[0].data) {
          handleInputPasteText(e, getTextFromHtml(data[0].data.text));
        } else {
          handleInputPasteText(e);
        }
      });
      const targetNode = this.mindMap.opt.customInnerElsAppendTo || document.body;
      targetNode.appendChild(this.textEditNode);
    }
    let scale = this.mindMap.view.scale;
    let lineHeight = node.style.merge("lineHeight");
    let fontSize = node.style.merge("fontSize");
    let textLines = (this.cacheEditingText || node.getData("text")).split(/\n/gim).map((item) => {
      return htmlEscape(item);
    });
    let isMultiLine = node._textData.node.attr("data-ismultiLine") === "true";
    node.style.domText(this.textEditNode, scale, isMultiLine);
    this.textEditNode.style.zIndex = nodeTextEditZIndex;
    this.textEditNode.innerHTML = textLines.join("<br>");
    this.textEditNode.style.minWidth = rect.width + 10 + "px";
    this.textEditNode.style.minHeight = rect.height + 6 + "px";
    this.textEditNode.style.left = rect.left + "px";
    this.textEditNode.style.top = rect.top + "px";
    this.textEditNode.style.display = "block";
    this.textEditNode.style.maxWidth = textAutoWrapWidth * scale + "px";
    if (isMultiLine && lineHeight !== 1) {
      this.textEditNode.style.transform = `translateY(${-((lineHeight * fontSize - fontSize) / 2) * scale}px)`;
    }
    this.showTextEdit = true;
    if (isInserting || selectTextOnEnterEditText && !isFromKeyDown) {
      selectAllInput(this.textEditNode);
    } else {
      focusInput(this.textEditNode);
    }
    this.cacheEditingText = "";
  }
  // 删除文本编辑元素
  removeTextEditEl() {
    if (this.mindMap.richText) {
      this.mindMap.richText.removeTextEditEl();
      return;
    }
    if (!this.textEditNode) return;
    const targetNode = this.mindMap.opt.customInnerElsAppendTo || document.body;
    targetNode.removeChild(this.textEditNode);
  }
  // 获取当前正在编辑的内容
  getEditText() {
    return getStrWithBrFromHtml(this.textEditNode.innerHTML);
  }
  //  隐藏文本编辑框
  hideEditTextBox() {
    if (this.mindMap.richText) {
      return this.mindMap.richText.hideEditText();
    }
    if (!this.showTextEdit) {
      return;
    }
    this.renderer.activeNodeList.forEach((node) => {
      let str = this.getEditText();
      this.mindMap.execCommand("SET_NODE_TEXT", node, str);
      if (node.isGeneralization) {
        node.generalizationBelongNode.updateGeneralization();
      }
      this.mindMap.render();
    });
    this.mindMap.emit(
      "hide_text_edit",
      this.textEditNode,
      this.renderer.activeNodeList,
      this.currentNode
    );
    this.currentNode = null;
    this.textEditNode.style.display = "none";
    this.textEditNode.innerHTML = "";
    this.textEditNode.style.fontFamily = "inherit";
    this.textEditNode.style.fontSize = "inherit";
    this.textEditNode.style.fontWeight = "normal";
    this.textEditNode.style.transform = "translateY(0)";
    this.showTextEdit = false;
  }
  // 获取当前正在编辑中的节点实例
  getCurrentEditNode() {
    if (this.mindMap.richText) {
      return this.mindMap.richText.node;
    }
    return this.currentNode;
  }
};

// node_modules/simple-mind-map/src/themes/default.js
var default_default = {
  // 节点内边距
  paddingX: 15,
  paddingY: 5,
  // 图片显示的最大宽度
  imgMaxWidth: 100,
  // 图片显示的最大高度
  imgMaxHeight: 100,
  // icon的大小
  iconSize: 20,
  // 连线的粗细
  lineWidth: 1,
  // 连线的颜色
  lineColor: "#549688",
  // 连线样式
  lineDasharray: "none",
  // 连线风格
  lineStyle: "straight",
  // 曲线（curve）【仅支持logicalStructure、mindMap、verticalTimeline三种结构】、直线（straight）、直连（direct）【仅支持logicalStructure、mindMap、organizationStructure、verticalTimeline四种结构】
  // 曲线连接时，根节点和其他节点的连接线样式保持统一，默认根节点为 ( 型，其他节点为 { 型，设为true后，都为 { 型。仅支持logicalStructure、mindMap两种结构
  rootLineKeepSameInCurve: true,
  // 曲线连接时，根节点和其他节点的连线起始位置保持统一，默认根节点的连线起始位置在节点中心，其他节点在节点右侧（或左侧），如果该配置设为true，那么根节点的连线起始位置也会在节点右侧（或左侧）
  rootLineStartPositionKeepSameInCurve: false,
  // 直线连接(straight)时，连线的圆角大小，设置为0代表没有圆角，仅支持logicalStructure、mindMap、verticalTimeline三种结构
  lineRadius: 5,
  // 连线是否显示标记，目前只支持箭头
  showLineMarker: false,
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#549688",
  // 概要曲线距节点的距离
  generalizationLineMargin: 0,
  // 概要节点距节点的距离
  generalizationNodeMargin: 20,
  // 关联线默认状态的粗细
  associativeLineWidth: 2,
  // 关联线默认状态的颜色
  associativeLineColor: "rgb(51, 51, 51)",
  // 关联线激活状态的粗细
  associativeLineActiveWidth: 8,
  // 关联线激活状态的颜色
  associativeLineActiveColor: "rgba(2, 167, 240, 1)",
  // 关联线样式
  associativeLineDasharray: [6, 4],
  // 关联线文字颜色
  associativeLineTextColor: "rgb(51, 51, 51)",
  // 关联线文字大小
  associativeLineTextFontSize: 14,
  // 关联线文字行高
  associativeLineTextLineHeight: 1.2,
  // 关联线文字字体
  associativeLineTextFontFamily: "微软雅黑, Microsoft YaHei",
  // 背景颜色
  backgroundColor: "#fafafa",
  // 背景图片
  backgroundImage: "none",
  // 背景重复
  backgroundRepeat: "no-repeat",
  // 设置背景图像的起始位置
  backgroundPosition: "center center",
  // 设置背景图片大小
  backgroundSize: "cover",
  // 节点使用只有底边横线的样式，仅支持logicalStructure、mindMap、catalogOrganization、organizationStructure四种结构
  nodeUseLineStyle: false,
  // 根节点样式
  root: {
    shape: "rectangle",
    fillColor: "#549688",
    fontFamily: "微软雅黑, Microsoft YaHei",
    color: "#fff",
    fontSize: 16,
    fontWeight: "bold",
    fontStyle: "normal",
    lineHeight: 1.5,
    borderColor: "transparent",
    borderWidth: 0,
    borderDasharray: "none",
    borderRadius: 5,
    textDecoration: "none",
    gradientStyle: false,
    startColor: "#549688",
    endColor: "#fff",
    // 连线标记的位置，start（头部）、end（尾部），该配置在showLineMarker配置为true时生效
    lineMarkerDir: "end"
  },
  // 二级节点样式
  second: {
    shape: "rectangle",
    marginX: 100,
    marginY: 40,
    fillColor: "#fff",
    fontFamily: "微软雅黑, Microsoft YaHei",
    color: "#565656",
    fontSize: 16,
    fontWeight: "noraml",
    fontStyle: "normal",
    lineHeight: 1.5,
    borderColor: "#549688",
    borderWidth: 1,
    borderDasharray: "none",
    borderRadius: 5,
    textDecoration: "none",
    gradientStyle: false,
    startColor: "#549688",
    endColor: "#fff",
    lineMarkerDir: "end"
  },
  // 三级及以下节点样式
  node: {
    shape: "rectangle",
    marginX: 50,
    marginY: 0,
    fillColor: "transparent",
    fontFamily: "微软雅黑, Microsoft YaHei",
    color: "#6a6d6c",
    fontSize: 14,
    fontWeight: "noraml",
    fontStyle: "normal",
    lineHeight: 1.5,
    borderColor: "transparent",
    borderWidth: 0,
    borderRadius: 5,
    borderDasharray: "none",
    textDecoration: "none",
    gradientStyle: false,
    startColor: "#549688",
    endColor: "#fff",
    lineMarkerDir: "end"
  },
  // 概要节点样式
  generalization: {
    shape: "rectangle",
    marginX: 100,
    marginY: 40,
    fillColor: "#fff",
    fontFamily: "微软雅黑, Microsoft YaHei",
    color: "#565656",
    fontSize: 16,
    fontWeight: "noraml",
    fontStyle: "normal",
    lineHeight: 1.5,
    borderColor: "#549688",
    borderWidth: 1,
    borderDasharray: "none",
    borderRadius: 5,
    textDecoration: "none",
    gradientStyle: false,
    startColor: "#549688",
    endColor: "#fff"
  }
};
var nodeSizeIndependenceList = [
  "lineWidth",
  "lineColor",
  "lineDasharray",
  "lineStyle",
  "generalizationLineWidth",
  "generalizationLineColor",
  "associativeLineWidth",
  "associativeLineColor",
  "associativeLineActiveWidth",
  "associativeLineActiveColor",
  "associativeLineTextColor",
  "associativeLineTextFontSize",
  "associativeLineTextLineHeight",
  "associativeLineTextFontFamily",
  "backgroundColor",
  "backgroundImage",
  "backgroundRepeat",
  "backgroundPosition",
  "backgroundSize",
  "rootLineKeepSameInCurve",
  "rootLineStartPositionKeepSameInCurve",
  "showLineMarker",
  "gradientStyle",
  "lineRadius",
  "startColor",
  "endColor"
];
var checkIsNodeSizeIndependenceConfig = (config) => {
  let keys = Object.keys(config);
  for (let i = 0; i < keys.length; i++) {
    if (!nodeSizeIndependenceList.find((item) => {
      return item === keys[i];
    })) {
      return false;
    }
  }
  return true;
};
var lineStyleProps = [
  "lineColor",
  "lineDasharray",
  "lineWidth",
  "lineMarkerDir"
];

// node_modules/simple-mind-map/src/core/render/Render.js
var layouts = {
  // 逻辑结构图
  [CONSTANTS.LAYOUT.LOGICAL_STRUCTURE]: LogicalStructure_default,
  // 向左逻辑结构图
  [CONSTANTS.LAYOUT.LOGICAL_STRUCTURE_LEFT]: LogicalStructure_default,
  // 思维导图
  [CONSTANTS.LAYOUT.MIND_MAP]: MindMap_default,
  // 目录组织图
  [CONSTANTS.LAYOUT.CATALOG_ORGANIZATION]: CatalogOrganization_default,
  // 组织结构图
  [CONSTANTS.LAYOUT.ORGANIZATION_STRUCTURE]: OrganizationStructure_default,
  // 时间轴
  [CONSTANTS.LAYOUT.TIMELINE]: Timeline_default,
  // 时间轴2
  [CONSTANTS.LAYOUT.TIMELINE2]: Timeline_default,
  // 竖向时间轴
  [CONSTANTS.LAYOUT.VERTICAL_TIMELINE]: VerticalTimeline_default,
  // 鱼骨图
  [CONSTANTS.LAYOUT.FISHBONE]: Fishbone_default
};
var Render = class {
  //  构造函数
  constructor(opt = {}) {
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.themeConfig = this.mindMap.themeConfig;
    this.renderTree = this.mindMap.opt.data ? es_default({}, this.mindMap.opt.data) : null;
    this.reRender = false;
    this.isRendering = false;
    this.hasWaitRendering = false;
    this.waitRenderingParams = [];
    this.nodeCache = {};
    this.lastNodeCache = {};
    this.renderSource = "";
    this.activeNodeList = [];
    this.root = null;
    this.textEdit = new TextEdit(this);
    this.lastBeingCopyData = null;
    this.beingCopyData = null;
    this.beingPasteText = "";
    this.beingPasteImgSize = 0;
    this.currentBeingPasteType = "";
    this.highlightBoxNode = null;
    this.lastActiveNode = null;
    this.lastActiveNodeList = [];
    this.setLayout();
    this.bindEvent();
    this.registerCommands();
    this.registerShortcutKeys();
  }
  //  设置布局结构
  setLayout() {
    this.layout = new (layouts[this.mindMap.opt.layout] ? layouts[this.mindMap.opt.layout] : layouts[CONSTANTS.LAYOUT.LOGICAL_STRUCTURE])(this, this.mindMap.opt.layout);
  }
  // 重新设置思维导图数据
  setData(data) {
    if (this.mindMap.richText) {
      this.renderTree = data ? this.mindMap.richText.handleSetData(data) : null;
    } else {
      this.renderTree = data;
    }
  }
  //   绑定事件
  bindEvent() {
    this.mindMap.on("draw_click", (e) => {
      this.clearActiveNodeListOnDrawClick(e, "click");
    });
    this.mindMap.on("contextmenu", (e) => {
      this.clearActiveNodeListOnDrawClick(e, "contextmenu");
    });
    this.mindMap.svg.on("dblclick", () => {
      if (!this.mindMap.opt.enableDblclickBackToRootNode) return;
      this.setRootNodeCenter();
    });
    this.performanceMode();
  }
  // 性能模式，懒加载节点
  performanceMode() {
    const { openPerformance, performanceConfig } = this.mindMap.opt;
    const onViewDataChange = throttle(() => {
      if (this.root) {
        this.mindMap.emit("node_tree_render_start");
        this.root.render(
          () => {
            this.mindMap.emit("node_tree_render_end");
          },
          false,
          true
        );
      }
    }, performanceConfig.time);
    let lastOpen = false;
    this.mindMap.on("before_update_config", (opt) => {
      lastOpen = opt.openPerformance;
    });
    this.mindMap.on("after_update_config", (opt) => {
      if (opt.openPerformance && !lastOpen) {
        this.mindMap.on("view_data_change", onViewDataChange);
        this.forceLoadNode();
      }
      if (!opt.openPerformance && lastOpen) {
        this.mindMap.off("view_data_change", onViewDataChange);
        this.forceLoadNode();
      }
    });
    if (!openPerformance) return;
    this.mindMap.on("view_data_change", onViewDataChange);
  }
  // 强制渲染节点，不考虑是否在画布可视区域内
  forceLoadNode(node) {
    node = node || this.root;
    if (node) {
      this.mindMap.emit("node_tree_render_start");
      node.render(() => {
        this.mindMap.emit("node_tree_render_end");
      }, true);
    }
  }
  //  注册命令
  registerCommands() {
    this.selectAll = this.selectAll.bind(this);
    this.mindMap.command.add("SELECT_ALL", this.selectAll);
    this.back = this.back.bind(this);
    this.mindMap.command.add("BACK", this.back);
    this.forward = this.forward.bind(this);
    this.mindMap.command.add("FORWARD", this.forward);
    this.insertNode = this.insertNode.bind(this);
    this.mindMap.command.add("INSERT_NODE", this.insertNode);
    this.insertMultiNode = this.insertMultiNode.bind(this);
    this.mindMap.command.add("INSERT_MULTI_NODE", this.insertMultiNode);
    this.insertChildNode = this.insertChildNode.bind(this);
    this.mindMap.command.add("INSERT_CHILD_NODE", this.insertChildNode);
    this.insertMultiChildNode = this.insertMultiChildNode.bind(this);
    this.mindMap.command.add(
      "INSERT_MULTI_CHILD_NODE",
      this.insertMultiChildNode
    );
    this.insertParentNode = this.insertParentNode.bind(this);
    this.mindMap.command.add("INSERT_PARENT_NODE", this.insertParentNode);
    this.upNode = this.upNode.bind(this);
    this.mindMap.command.add("UP_NODE", this.upNode);
    this.downNode = this.downNode.bind(this);
    this.mindMap.command.add("DOWN_NODE", this.downNode);
    this.moveUpOneLevel = this.moveUpOneLevel.bind(this);
    this.mindMap.command.add("MOVE_UP_ONE_LEVEL", this.moveUpOneLevel);
    this.insertAfter = this.insertAfter.bind(this);
    this.mindMap.command.add("INSERT_AFTER", this.insertAfter);
    this.insertBefore = this.insertBefore.bind(this);
    this.mindMap.command.add("INSERT_BEFORE", this.insertBefore);
    this.moveNodeTo = this.moveNodeTo.bind(this);
    this.mindMap.command.add("MOVE_NODE_TO", this.moveNodeTo);
    this.removeNode = this.removeNode.bind(this);
    this.mindMap.command.add("REMOVE_NODE", this.removeNode);
    this.removeCurrentNode = this.removeCurrentNode.bind(this);
    this.mindMap.command.add("REMOVE_CURRENT_NODE", this.removeCurrentNode);
    this.pasteNode = this.pasteNode.bind(this);
    this.mindMap.command.add("PASTE_NODE", this.pasteNode);
    this.cutNode = this.cutNode.bind(this);
    this.mindMap.command.add("CUT_NODE", this.cutNode);
    this.setNodeStyle = this.setNodeStyle.bind(this);
    this.mindMap.command.add("SET_NODE_STYLE", this.setNodeStyle);
    this.setNodeStyles = this.setNodeStyles.bind(this);
    this.mindMap.command.add("SET_NODE_STYLES", this.setNodeStyles);
    this.setNodeActive = this.setNodeActive.bind(this);
    this.mindMap.command.add("SET_NODE_ACTIVE", this.setNodeActive);
    this.clearActiveNode = this.clearActiveNode.bind(this);
    this.mindMap.command.add("CLEAR_ACTIVE_NODE", this.clearActiveNode);
    this.setNodeExpand = this.setNodeExpand.bind(this);
    this.mindMap.command.add("SET_NODE_EXPAND", this.setNodeExpand);
    this.expandAllNode = this.expandAllNode.bind(this);
    this.mindMap.command.add("EXPAND_ALL", this.expandAllNode);
    this.unexpandAllNode = this.unexpandAllNode.bind(this);
    this.mindMap.command.add("UNEXPAND_ALL", this.unexpandAllNode);
    this.expandToLevel = this.expandToLevel.bind(this);
    this.mindMap.command.add("UNEXPAND_TO_LEVEL", this.expandToLevel);
    this.setNodeData = this.setNodeData.bind(this);
    this.mindMap.command.add("SET_NODE_DATA", this.setNodeData);
    this.setNodeText = this.setNodeText.bind(this);
    this.mindMap.command.add("SET_NODE_TEXT", this.setNodeText);
    this.setNodeImage = this.setNodeImage.bind(this);
    this.mindMap.command.add("SET_NODE_IMAGE", this.setNodeImage);
    this.setNodeIcon = this.setNodeIcon.bind(this);
    this.mindMap.command.add("SET_NODE_ICON", this.setNodeIcon);
    this.setNodeHyperlink = this.setNodeHyperlink.bind(this);
    this.mindMap.command.add("SET_NODE_HYPERLINK", this.setNodeHyperlink);
    this.setNodeNote = this.setNodeNote.bind(this);
    this.mindMap.command.add("SET_NODE_NOTE", this.setNodeNote);
    this.setNodeAttachment = this.setNodeAttachment.bind(this);
    this.mindMap.command.add("SET_NODE_ATTACHMENT", this.setNodeAttachment);
    this.setNodeTag = this.setNodeTag.bind(this);
    this.mindMap.command.add("SET_NODE_TAG", this.setNodeTag);
    this.insertFormula = this.insertFormula.bind(this);
    this.mindMap.command.add("INSERT_FORMULA", this.insertFormula);
    this.addGeneralization = this.addGeneralization.bind(this);
    this.mindMap.command.add("ADD_GENERALIZATION", this.addGeneralization);
    this.removeGeneralization = this.removeGeneralization.bind(this);
    this.mindMap.command.add("REMOVE_GENERALIZATION", this.removeGeneralization);
    this.setNodeCustomPosition = this.setNodeCustomPosition.bind(this);
    this.mindMap.command.add(
      "SET_NODE_CUSTOM_POSITION",
      this.setNodeCustomPosition
    );
    this.resetLayout = this.resetLayout.bind(this);
    this.mindMap.command.add("RESET_LAYOUT", this.resetLayout);
    this.setNodeShape = this.setNodeShape.bind(this);
    this.mindMap.command.add("SET_NODE_SHAPE", this.setNodeShape);
    this.goTargetNode = this.goTargetNode.bind(this);
    this.mindMap.command.add("GO_TARGET_NODE", this.goTargetNode);
    this.removeCustomStyles = this.removeCustomStyles.bind(this);
    this.mindMap.command.add("REMOVE_CUSTOM_STYLES", this.removeCustomStyles);
    this.removeAllNodeCustomStyles = this.removeAllNodeCustomStyles.bind(this);
    this.mindMap.command.add(
      "REMOVE_ALL_NODE_CUSTOM_STYLES",
      this.removeAllNodeCustomStyles
    );
  }
  //  注册快捷键
  registerShortcutKeys() {
    this.mindMap.keyCommand.addShortcut("Tab", () => {
      this.mindMap.execCommand("INSERT_CHILD_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Insert", () => {
      this.mindMap.execCommand("INSERT_CHILD_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Enter", () => {
      this.mindMap.execCommand("INSERT_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Shift+Tab", () => {
      this.mindMap.execCommand("INSERT_PARENT_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Control+g", () => {
      this.mindMap.execCommand("ADD_GENERALIZATION");
    });
    this.toggleActiveExpand = this.toggleActiveExpand.bind(this);
    this.mindMap.keyCommand.addShortcut("/", this.toggleActiveExpand);
    this.mindMap.keyCommand.addShortcut("Del|Backspace", () => {
      this.mindMap.execCommand("REMOVE_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Shift+Backspace", () => {
      this.mindMap.execCommand("REMOVE_CURRENT_NODE");
    });
    this.mindMap.on("before_show_text_edit", () => {
      this.startTextEdit();
    });
    this.mindMap.on("hide_text_edit", () => {
      this.endTextEdit();
    });
    this.mindMap.keyCommand.addShortcut("Control+a", () => {
      this.mindMap.execCommand("SELECT_ALL");
    });
    this.mindMap.keyCommand.addShortcut("Control+l", () => {
      this.mindMap.execCommand("RESET_LAYOUT");
    });
    this.mindMap.keyCommand.addShortcut("Control+Up", () => {
      this.mindMap.execCommand("UP_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Control+Down", () => {
      this.mindMap.execCommand("DOWN_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Control+c", () => {
      this.copy();
    });
    this.mindMap.keyCommand.addShortcut("Control+x", () => {
      this.cut();
    });
    this.mindMap.keyCommand.addShortcut("Control+v", () => {
      this.paste();
    });
    this.mindMap.keyCommand.addShortcut("Control+Enter", () => {
      this.setRootNodeCenter();
    });
  }
  // 派发节点激活事件
  emitNodeActiveEvent(node = null, activeNodeList = [...this.activeNodeList]) {
    let isChange = false;
    isChange = this.lastActiveNode !== node;
    if (!isChange) {
      isChange = !checkNodeListIsEqual(this.lastActiveNodeList, activeNodeList);
    }
    if (!isChange) return;
    this.lastActiveNode = node;
    this.lastActiveNodeList = [...activeNodeList];
    this.mindMap.batchExecution.push("emitNodeActiveEvent", () => {
      this.mindMap.emit("node_active", node, activeNodeList);
    });
  }
  // 鼠标点击画布时清空当前激活节点列表
  clearActiveNodeListOnDrawClick(e, eventType) {
    if (this.activeNodeList.length <= 0) return;
    let isTrueClick = true;
    const { useLeftKeySelectionRightKeyDrag } = this.mindMap.opt;
    if (eventType === "contextmenu" ? !useLeftKeySelectionRightKeyDrag : useLeftKeySelectionRightKeyDrag) {
      const mousedownPos = this.mindMap.event.mousedownPos;
      isTrueClick = Math.abs(e.clientX - mousedownPos.x) <= 5 && Math.abs(e.clientY - mousedownPos.y) <= 5;
    }
    if (isTrueClick) {
      this.mindMap.execCommand("CLEAR_ACTIVE_NODE");
    }
  }
  //  开启文字编辑，会禁用回车键和删除键相关快捷键防止冲突
  startTextEdit() {
    this.mindMap.keyCommand.save();
  }
  //  结束文字编辑，会恢复回车键和删除键相关快捷键
  endTextEdit() {
    this.mindMap.keyCommand.restore();
  }
  // 清空节点缓存池
  clearCache() {
    this.layout.lru.clear();
    this.nodeCache = {};
    this.lastNodeCache = {};
  }
  //   渲染
  render(callback = () => {
  }, source) {
    if (source === CONSTANTS.CHANGE_THEME) {
      this.resetUnExpandNodeStyle();
    }
    if (this.isRendering) {
      this.hasWaitRendering = true;
      this.waitRenderingParams = [callback, source];
      return;
    }
    this.isRendering = true;
    this.renderSource = source;
    this.lastNodeCache = this.nodeCache;
    this.nodeCache = {};
    if (this.reRender) {
      this.clearActiveNodeList();
    }
    if (!this.renderTree) {
      this.isRendering = false;
      this.mindMap.emit("node_tree_render_end");
      return;
    }
    this.mindMap.emit("node_tree_render_start");
    this.root = null;
    this.layout.doLayout((root) => {
      Object.keys(this.lastNodeCache).forEach((uid) => {
        if (!this.nodeCache[uid]) {
          this.removeNodeFromActiveList(this.lastNodeCache[uid]);
          this.emitNodeActiveEvent();
          this.lastNodeCache[uid].destroy();
        }
      });
      this.root = root;
      this.root.render(() => {
        this.isRendering = false;
        callback && callback();
        if (this.hasWaitRendering) {
          const params = this.waitRenderingParams;
          this.hasWaitRendering = false;
          this.waitRenderingParams = [];
          this.render(...params);
        } else {
          this.renderSource = "";
          if (this.reRender) {
            this.reRender = false;
          }
          if (this.mindMap.richText && [CONSTANTS.CHANGE_THEME, CONSTANTS.SET_DATA].includes(source)) {
            this.mindMap.command.addHistory();
          }
        }
        this.mindMap.emit("node_tree_render_end");
      });
    });
    this.emitNodeActiveEvent();
  }
  // 给当前被收起来的节点数据添加文本复位标志
  resetUnExpandNodeStyle() {
    if (!this.renderTree) return;
    walk(this.renderTree, null, (node) => {
      if (!node.data.expand) {
        walk(node, null, (node2) => {
          node2.data.resetRichText = true;
        });
        return true;
      }
    });
  }
  //  清除当前所有激活节点，并会触发事件
  clearActiveNode() {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    this.clearActiveNodeList();
    this.emitNodeActiveEvent(null, []);
  }
  //  清除当前激活的节点列表
  clearActiveNodeList() {
    this.activeNodeList.forEach((item) => {
      this.mindMap.execCommand("SET_NODE_ACTIVE", item, false);
    });
    this.activeNodeList = [];
  }
  // 添加节点到激活列表里
  addNodeToActiveList(node, notEmitBeforeNodeActiveEvent = false) {
    if (this.mindMap.opt.onlyOneEnableActiveNodeOnCooperate && node.userList.length > 0)
      return;
    const index = this.findActiveNodeIndex(node);
    if (index === -1) {
      if (!notEmitBeforeNodeActiveEvent) {
        this.mindMap.emit("before_node_active", node, this.activeNodeList);
      }
      this.mindMap.execCommand("SET_NODE_ACTIVE", node, true);
      this.activeNodeList.push(node);
    }
  }
  // 在激活列表里移除某个节点
  removeNodeFromActiveList(node) {
    let index = this.findActiveNodeIndex(node);
    if (index === -1) {
      return;
    }
    this.mindMap.execCommand("SET_NODE_ACTIVE", node, false);
    this.activeNodeList.splice(index, 1);
  }
  // 手动激活多个节点，激活单个节点请直接调用节点实例的active()方法
  activeMultiNode(nodeList = []) {
    nodeList.forEach((node) => {
      this.mindMap.emit("before_node_active", node, this.activeNodeList);
      this.addNodeToActiveList(node, true);
      this.emitNodeActiveEvent(node);
    });
  }
  // 手动取消激活多个节点
  cancelActiveMultiNode(nodeList = []) {
    nodeList.forEach((node) => {
      this.removeNodeFromActiveList(node);
      this.emitNodeActiveEvent(null);
    });
  }
  //  检索某个节点在激活列表里的索引
  findActiveNodeIndex(node) {
    return getNodeIndexInNodeList(node, this.activeNodeList);
  }
  //  全选
  selectAll() {
    if (this.mindMap.opt.readonly) return;
    walk(
      this.root,
      null,
      (node) => {
        if (!node.getData("isActive")) {
          this.addNodeToActiveList(node);
        }
        if (node._generalizationList && node._generalizationList.length > 0) {
          node._generalizationList.forEach((item) => {
            const gNode = item.generalizationNode;
            if (!gNode.getData("isActive")) {
              this.addNodeToActiveList(gNode);
            }
          });
        }
      },
      null,
      true,
      0,
      0
    );
    this.emitNodeActiveEvent();
  }
  //  回退
  back(step) {
    this.backForward("back", step);
  }
  //  前进
  forward(step) {
    this.backForward("forward", step);
  }
  // 前进回退
  backForward(type, step) {
    this.mindMap.execCommand("CLEAR_ACTIVE_NODE");
    const data = this.mindMap.command[type](step);
    if (data) {
      this.renderTree = data;
      this.mindMap.render();
    }
  }
  // 获取创建新节点的行为
  getNewNodeBehavior(openEdit = false, handleMultiNodes = false) {
    const { createNewNodeBehavior } = this.mindMap.opt;
    let focusNewNode = false;
    let inserting = false;
    switch (createNewNodeBehavior) {
      case CONSTANTS.CREATE_NEW_NODE_BEHAVIOR.DEFAULT:
        focusNewNode = handleMultiNodes || !openEdit;
        inserting = handleMultiNodes ? false : openEdit;
        break;
      case CONSTANTS.CREATE_NEW_NODE_BEHAVIOR.NOT_ACTIVE:
        focusNewNode = false;
        inserting = false;
        break;
      case CONSTANTS.CREATE_NEW_NODE_BEHAVIOR.ACTIVE_ONLY:
        focusNewNode = true;
        inserting = false;
        break;
      default:
        break;
    }
    return {
      focusNewNode,
      inserting
    };
  }
  //  插入同级节点
  insertNode(openEdit = true, appointNodes = [], appointData = null, appointChildren = []) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const {
      defaultInsertSecondLevelNodeText,
      defaultInsertBelowSecondLevelNodeText
    } = this.mindMap.opt;
    const list = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const handleMultiNodes = list.length > 1;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode, inserting } = this.getNewNodeBehavior(
      openEdit,
      handleMultiNodes
    );
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
      // 如果同时对多个节点插入子节点，那么需要把新增的节点设为激活状态。如果不进入编辑状态，那么也需要手动设为激活状态
    };
    appointChildren = addDataToAppointNodes(appointChildren, {
      ...params
    });
    list.forEach((node) => {
      if (node.isGeneralization || node.isRoot) {
        return;
      }
      const parent = node.parent;
      const isOneLayer = node.layerIndex === 1;
      const text = isOneLayer ? defaultInsertSecondLevelNodeText : defaultInsertBelowSecondLevelNodeText;
      const index = getNodeDataIndex(node);
      const newNodeData = {
        inserting,
        data: {
          text,
          ...params,
          uid: createUid(),
          ...appointData || {}
        },
        children: [...createUidForAppointNodes(appointChildren)]
      };
      parent.nodeData.children.splice(index + 1, 0, newNodeData);
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  // 插入多个同级节点
  insertMultiNode(appointNodes, nodeList) {
    if (!nodeList || nodeList.length <= 0) return;
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const list = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode } = this.getNewNodeBehavior(false, true);
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
    };
    nodeList = addDataToAppointNodes(nodeList, params);
    list.forEach((node) => {
      if (node.isGeneralization || node.isRoot) {
        return;
      }
      const parent = node.parent;
      const index = getNodeDataIndex(node);
      const newNodeList = createUidForAppointNodes(simpleDeepClone(nodeList));
      parent.nodeData.children.splice(index + 1, 0, ...newNodeList);
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  //  插入子节点
  insertChildNode(openEdit = true, appointNodes = [], appointData = null, appointChildren = []) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const {
      defaultInsertSecondLevelNodeText,
      defaultInsertBelowSecondLevelNodeText
    } = this.mindMap.opt;
    const list = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const handleMultiNodes = list.length > 1;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode, inserting } = this.getNewNodeBehavior(
      openEdit,
      handleMultiNodes
    );
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
    };
    appointChildren = addDataToAppointNodes(appointChildren, {
      ...params
    });
    list.forEach((node) => {
      if (node.isGeneralization) {
        return;
      }
      if (!node.nodeData.children) {
        node.nodeData.children = [];
      }
      const text = node.isRoot ? defaultInsertSecondLevelNodeText : defaultInsertBelowSecondLevelNodeText;
      const newNode = {
        inserting,
        data: {
          text,
          uid: createUid(),
          ...params,
          ...appointData || {}
        },
        children: [...createUidForAppointNodes(appointChildren)]
      };
      node.nodeData.children.push(newNode);
      node.setData({
        expand: true
      });
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  // 插入多个子节点
  insertMultiChildNode(appointNodes, childList) {
    if (!childList || childList.length <= 0) return;
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const list = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode } = this.getNewNodeBehavior(false, true);
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
    };
    childList = addDataToAppointNodes(childList, params);
    list.forEach((node) => {
      if (node.isGeneralization) {
        return;
      }
      if (!node.nodeData.children) {
        node.nodeData.children = [];
      }
      childList = createUidForAppointNodes(childList);
      node.nodeData.children.push(...childList);
      node.setData({
        expand: true
      });
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  // 插入父节点
  insertParentNode(openEdit = true, appointNodes, appointData) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const {
      defaultInsertSecondLevelNodeText,
      defaultInsertBelowSecondLevelNodeText
    } = this.mindMap.opt;
    const list = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const handleMultiNodes = list.length > 1;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode, inserting } = this.getNewNodeBehavior(
      openEdit,
      handleMultiNodes
    );
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
    };
    list.forEach((node) => {
      if (node.isGeneralization || node.isRoot) {
        return;
      }
      const text = node.layerIndex === 1 ? defaultInsertSecondLevelNodeText : defaultInsertBelowSecondLevelNodeText;
      const newNode = {
        inserting,
        data: {
          text,
          uid: createUid(),
          ...params,
          ...appointData || {}
        },
        children: [node.nodeData]
      };
      node.setData({
        resetRichText: true
      });
      const parent = node.parent;
      const index = getNodeDataIndex(node);
      parent.nodeData.children.splice(index, 1, newNode);
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  //  上移节点，多个节点只会操作第一个节点
  upNode() {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    let node = this.activeNodeList[0];
    if (node.isRoot) {
      return;
    }
    let parent = node.parent;
    let childList = parent.children;
    let index = getNodeIndexInNodeList(node, childList);
    if (index === -1 || index === 0) {
      return;
    }
    let insertIndex = index - 1;
    childList.splice(index, 1);
    childList.splice(insertIndex, 0, node);
    parent.nodeData.children.splice(index, 1);
    parent.nodeData.children.splice(insertIndex, 0, node.nodeData);
    this.mindMap.render();
  }
  //  下移节点，多个节点只会操作第一个节点
  downNode() {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    let node = this.activeNodeList[0];
    if (node.isRoot) {
      return;
    }
    let parent = node.parent;
    let childList = parent.children;
    let index = getNodeIndexInNodeList(node, childList);
    if (index === -1 || index === childList.length - 1) {
      return;
    }
    let insertIndex = index + 1;
    childList.splice(index, 1);
    childList.splice(insertIndex, 0, node);
    parent.nodeData.children.splice(index, 1);
    parent.nodeData.children.splice(insertIndex, 0, node.nodeData);
    this.mindMap.render();
  }
  // 将节点上移一个层级，多个节点只会操作第一个节点
  moveUpOneLevel(node) {
    node = node || this.activeNodeList[0];
    if (!node || node.isRoot || node.layerIndex <= 1) {
      return;
    }
    const parent = node.parent;
    const grandpa = parent.parent;
    const index = getNodeIndexInNodeList(node, parent.children);
    const parentIndex = getNodeIndexInNodeList(parent, grandpa.children);
    this.checkNodeLayerChange(node, parent);
    parent.nodeData.children.splice(index, 1);
    grandpa.nodeData.children.splice(parentIndex + 1, 0, node.nodeData);
    this.mindMap.render();
  }
  // 移除节点数据的自定义样式的内部方法
  _handleRemoveCustomStyles(nodeData) {
    let hasCustomStyles = false;
    Object.keys(nodeData).forEach((key) => {
      if (checkIsNodeStyleDataKey(key)) {
        hasCustomStyles = true;
        delete nodeData[key];
      }
    });
    if (hasCustomStyles && this.mindMap.richText) {
      nodeData.resetRichText = true;
      nodeData.text = removeRichTextStyes(nodeData.text);
    }
    return hasCustomStyles;
  }
  // 一键去除自定义样式
  removeCustomStyles(node) {
    node = node || this.activeNodeList[0];
    if (!node) {
      return;
    }
    const hasCustomStyles = this._handleRemoveCustomStyles(node.getData());
    if (hasCustomStyles) {
      this.reRenderNodeCheckChange(node);
    }
  }
  // 一键去除所有节点自定义样式
  removeAllNodeCustomStyles(appointNodes) {
    appointNodes = formatDataToArray(appointNodes);
    let hasCustomStyles = false;
    if (appointNodes.length > 0) {
      appointNodes.forEach((node) => {
        const _hasCustomStyles = this._handleRemoveCustomStyles(node.getData());
        if (_hasCustomStyles) hasCustomStyles = true;
      });
    } else {
      if (!this.renderTree) return;
      walk(this.renderTree, null, (node) => {
        const _hasCustomStyles = this._handleRemoveCustomStyles(node.data);
        if (_hasCustomStyles) hasCustomStyles = true;
        const generalizationList = formatGetNodeGeneralization(node.data);
        if (generalizationList.length > 0) {
          generalizationList.forEach((generalizationData) => {
            const _hasCustomStyles2 = this._handleRemoveCustomStyles(generalizationData);
            if (_hasCustomStyles2) hasCustomStyles = true;
          });
        }
      });
    }
    if (hasCustomStyles) {
      this.mindMap.reRender();
    }
  }
  // 复制节点
  copy() {
    this.beingCopyData = this.copyNode();
    if (!this.beingCopyData) return;
    if (!this.mindMap.opt.disabledClipboard) {
      setDataToClipboard(createSmmFormatData(this.beingCopyData));
    }
  }
  // 剪切节点
  cut() {
    this.mindMap.execCommand("CUT_NODE", (copyData) => {
      this.beingCopyData = copyData;
      if (!this.mindMap.opt.disabledClipboard) {
        setDataToClipboard(createSmmFormatData(copyData));
      }
    });
  }
  // 粘贴
  async paste() {
    const {
      errorHandler,
      handleIsSplitByWrapOnPasteCreateNewNode,
      handleNodePasteImg,
      disabledClipboard
    } = this.mindMap.opt;
    let text = "";
    let img = null;
    if (!disabledClipboard) {
      try {
        const res = await getDataFromClipboard();
        text = res.text || "";
        img = res.img || null;
      } catch (error) {
        errorHandler(ERROR_TYPES.READ_CLIPBOARD_ERROR, error);
      }
    }
    const imgSize = img ? img.size : 0;
    if (this.beingPasteText !== text || this.beingPasteImgSize !== imgSize) {
      this.currentBeingPasteType = CONSTANTS.PASTE_TYPE.CLIP_BOARD;
      this.beingPasteText = text;
      this.beingPasteImgSize = imgSize;
    }
    if (this.lastBeingCopyData !== this.beingCopyData) {
      this.lastBeingCopyData = this.beingCopyData;
      this.currentBeingPasteType = CONSTANTS.PASTE_TYPE.CANVAS;
    }
    if (this.currentBeingPasteType === CONSTANTS.PASTE_TYPE.CLIP_BOARD) {
      if (text) {
        let smmData = null;
        let useDefault = true;
        if (this.mindMap.opt.customHandleClipboardText) {
          try {
            const res = await this.mindMap.opt.customHandleClipboardText(text);
            if (!isUndef(res)) {
              useDefault = false;
              const checkRes = checkSmmFormatData(res);
              if (checkRes.isSmm) {
                smmData = checkRes.data;
              } else {
                text = checkRes.data;
              }
            }
          } catch (error) {
            errorHandler(ERROR_TYPES.CUSTOM_HANDLE_CLIPBOARD_TEXT_ERROR, error);
          }
        }
        if (useDefault) {
          const checkRes = checkSmmFormatData(text);
          if (checkRes.isSmm) {
            smmData = checkRes.data;
          } else {
            text = checkRes.data;
          }
        }
        if (smmData) {
          this.mindMap.execCommand(
            "INSERT_MULTI_CHILD_NODE",
            [],
            Array.isArray(smmData) ? smmData : [smmData]
          );
        } else {
          text = htmlEscape(text);
          const textArr = text.split(new RegExp("\r?\n|(?<!\n)\r", "g")).filter((item) => {
            return !!item;
          });
          if (textArr.length > 1 && handleIsSplitByWrapOnPasteCreateNewNode) {
            handleIsSplitByWrapOnPasteCreateNewNode().then(() => {
              this.mindMap.execCommand(
                "INSERT_MULTI_CHILD_NODE",
                [],
                textArr.map((item) => {
                  return {
                    data: {
                      text: item
                    },
                    children: []
                  };
                })
              );
            }).catch(() => {
              this.mindMap.execCommand("INSERT_CHILD_NODE", false, [], {
                text
              });
            });
          } else {
            this.mindMap.execCommand("INSERT_CHILD_NODE", false, [], {
              text
            });
          }
        }
      }
      if (img) {
        try {
          let imgData = null;
          if (handleNodePasteImg && typeof handleNodePasteImg === "function") {
            imgData = await handleNodePasteImg(img);
          } else {
            imgData = await loadImage(img);
          }
          if (this.activeNodeList.length > 0) {
            this.activeNodeList.forEach((node) => {
              this.mindMap.execCommand("SET_NODE_IMAGE", node, {
                url: imgData.url,
                title: "",
                width: imgData.size.width,
                height: imgData.size.height
              });
            });
          }
        } catch (error) {
          errorHandler(ERROR_TYPES.LOAD_CLIPBOARD_IMAGE_ERROR, error);
        }
      }
    } else {
      if (this.beingCopyData) {
        this.mindMap.execCommand("PASTE_NODE", this.beingCopyData);
      }
    }
  }
  //  将节点移动到另一个节点的前面
  insertBefore(node, exist) {
    this.insertTo(node, exist, "before");
  }
  //  将节点移动到另一个节点的后面
  insertAfter(node, exist) {
    this.insertTo(node, exist, "after");
  }
  // 将节点移动到另一个节点的前面或后面
  insertTo(node, exist, dir = "before") {
    let nodeList = formatDataToArray(node);
    nodeList = nodeList.filter((item) => {
      return !item.isRoot;
    });
    if (dir === "after") {
      nodeList.reverse();
    }
    nodeList.forEach((item) => {
      this.checkNodeLayerChange(item, exist);
      let nodeParent = item.parent;
      let nodeBorthers = nodeParent.children;
      let nodeIndex = getNodeIndexInNodeList(item, nodeBorthers);
      if (nodeIndex === -1) {
        return;
      }
      nodeBorthers.splice(nodeIndex, 1);
      nodeParent.nodeData.children.splice(nodeIndex, 1);
      let existParent = exist.parent;
      let existBorthers = existParent.children;
      let existIndex = getNodeIndexInNodeList(exist, existBorthers);
      if (existIndex === -1) {
        return;
      }
      if (dir === "after") {
        existIndex++;
      }
      existBorthers.splice(existIndex, 0, item);
      existParent.nodeData.children.splice(existIndex, 0, item.nodeData);
    });
    this.mindMap.render();
  }
  // 如果是富文本模式，那么某些层级变化需要更新样式
  checkNodeLayerChange(node, toNode, toNodeIsParent = false) {
    if (this.mindMap.richText) {
      if (this.mindMap.richText.checkNodeHasCustomRichTextStyle(node)) {
        return;
      }
      const toIndex = toNodeIsParent ? toNode.layerIndex + 1 : toNode.layerIndex;
      let nodeLayerChanged = node.layerIndex === 1 && toIndex !== 1 || node.layerIndex !== 1 && toIndex === 1;
      if (nodeLayerChanged) {
        node.setData({
          resetRichText: true
        });
      }
    }
  }
  //  移除节点
  removeNode(appointNodes = []) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    let needActiveNode = null;
    let isAppointNodes = appointNodes.length > 0;
    let list = isAppointNodes ? appointNodes : this.activeNodeList;
    let root = list.find((node) => {
      return node.isRoot;
    });
    if (root) {
      this.clearActiveNodeList();
      root.children = [];
      root.nodeData.children = [];
    } else {
      needActiveNode = this.getNextActiveNode(list);
      for (let i = 0; i < list.length; i++) {
        const node = list[i];
        const currentEditNode = this.textEdit.getCurrentEditNode();
        if (currentEditNode && currentEditNode.getData("uid") === node.getData("uid")) {
          this.textEdit.hideEditTextBox();
        }
        if (isAppointNodes) list.splice(i, 1);
        if (node.isGeneralization) {
          this.deleteNodeGeneralization(node);
          this.removeNodeFromActiveList(node);
          i--;
        } else {
          this.removeNodeFromActiveList(node);
          removeFromParentNodeData(node);
          i--;
        }
      }
    }
    this.activeNodeList = [];
    if (needActiveNode) {
      this.addNodeToActiveList(needActiveNode);
    }
    this.emitNodeActiveEvent();
    this.mindMap.render();
  }
  // 删除概要节点，即从所属节点里删除该概要
  deleteNodeGeneralization(node) {
    const targetNode = node.generalizationBelongNode;
    const index = targetNode.getGeneralizationNodeIndex(node);
    let generalization = targetNode.getData("generalization");
    if (Array.isArray(generalization)) {
      generalization.splice(index, 1);
    } else {
      generalization = null;
    }
    this.mindMap.execCommand("SET_NODE_DATA", targetNode, {
      generalization
    });
    this.closeHighlightNode();
  }
  // 仅删除当前节点
  removeCurrentNode(appointNodes = []) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    let isAppointNodes = appointNodes.length > 0;
    let list = isAppointNodes ? appointNodes : this.activeNodeList;
    list = list.filter((node) => {
      return !node.isRoot;
    });
    let needActiveNode = this.getNextActiveNode(list);
    for (let i = 0; i < list.length; i++) {
      let node = list[i];
      if (node.isGeneralization) {
        this.deleteNodeGeneralization(node);
      } else {
        const parent = node.parent;
        const index = getNodeDataIndex(node);
        parent.nodeData.children.splice(
          index,
          1,
          ...node.nodeData.children || []
        );
      }
    }
    this.activeNodeList = [];
    if (needActiveNode) {
      this.addNodeToActiveList(needActiveNode);
    }
    this.emitNodeActiveEvent();
    this.mindMap.render();
  }
  // 计算下一个可激活的节点
  getNextActiveNode(deleteList) {
    if (deleteList.length !== 1) return null;
    if (this.findActiveNodeIndex(deleteList[0]) === -1) return null;
    let needActiveNode = null;
    if (this.activeNodeList.length === 1 && !this.activeNodeList[0].isGeneralization && this.mindMap.opt.deleteNodeActive) {
      const node = this.activeNodeList[0];
      const broList = node.parent.children;
      const nodeIndex = getNodeIndexInNodeList(node, broList);
      if (nodeIndex < broList.length - 1) {
        needActiveNode = broList[nodeIndex + 1];
      } else {
        if (nodeIndex > 0) {
          needActiveNode = broList[nodeIndex - 1];
        } else {
          needActiveNode = node.parent;
        }
      }
    }
    return needActiveNode;
  }
  //  复制节点
  copyNode() {
    if (this.activeNodeList.length <= 0) {
      return null;
    }
    let nodeList = getTopAncestorsFomNodeList(this.activeNodeList);
    nodeList = sortNodeList(nodeList);
    return nodeList.map((node) => {
      return copyNodeTree({}, node, true);
    });
  }
  //  剪切节点
  cutNode(callback) {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    let nodeList = getTopAncestorsFomNodeList(this.activeNodeList).filter(
      (node) => {
        return !node.isRoot;
      }
    );
    nodeList = sortNodeList(nodeList);
    const copyData = nodeList.map((node) => {
      return copyNodeTree({}, node, true);
    });
    nodeList.forEach((node) => {
      removeFromParentNodeData(node);
    });
    this.clearActiveNodeList();
    this.mindMap.render();
    if (callback && typeof callback === "function") {
      callback(copyData);
    }
  }
  //  移动节点作为另一个节点的子节点
  moveNodeTo(node, toNode) {
    let nodeList = formatDataToArray(node);
    nodeList = nodeList.filter((item) => {
      return !item.isRoot;
    });
    nodeList.forEach((item) => {
      this.checkNodeLayerChange(item, toNode, true);
      this.removeNodeFromActiveList(item);
      removeFromParentNodeData(item);
      toNode.setData({
        expand: true
      });
      toNode.nodeData.children.push(item.nodeData);
    });
    this.emitNodeActiveEvent();
    this.mindMap.render();
  }
  //   粘贴节点到节点
  pasteNode(data) {
    data = formatDataToArray(data);
    if (this.activeNodeList.length <= 0 || data.length <= 0) {
      return;
    }
    this.activeNodeList.forEach((node) => {
      node.setData({
        expand: true
      });
      node.nodeData.children.push(
        ...data.map((item) => {
          const newData = simpleDeepClone(item);
          createUidForAppointNodes([newData], true, (node2) => {
            if (this.mindMap.richText) {
              if (this.mindMap.richText.checkNodeHasCustomRichTextStyle(node2.data)) {
                return;
              }
              node2.data.resetRichText = true;
            }
          });
          return newData;
        })
      );
    });
    this.mindMap.render();
  }
  //  设置节点样式
  setNodeStyle(node, prop, value) {
    let data = {
      [prop]: value
    };
    if (this.mindMap.richText) {
      this.mindMap.richText.setNotActiveNodeStyle(node, {
        [prop]: value
      });
    }
    this.setNodeDataRender(node, data);
    if (lineStyleProps.includes(prop)) {
      ;
      (node.parent || node).renderLine(true);
    }
  }
  //  设置节点多个样式
  setNodeStyles(node, style) {
    let data = { ...style };
    if (this.mindMap.richText) {
      this.mindMap.richText.setNotActiveNodeStyle(node, style);
    }
    this.setNodeDataRender(node, data);
    let props = Object.keys(style);
    let hasLineStyleProps = false;
    props.forEach((key) => {
      if (lineStyleProps.includes(key)) {
        hasLineStyleProps = true;
      }
    });
    if (hasLineStyleProps) {
      ;
      (node.parent || node).renderLine(true);
    }
  }
  //  设置节点是否激活
  setNodeActive(node, active) {
    this.mindMap.execCommand("SET_NODE_DATA", node, {
      isActive: active
    });
    node.updateNodeByActive(active);
  }
  //  设置节点是否展开
  setNodeExpand(node, expand) {
    this.mindMap.execCommand("SET_NODE_DATA", node, {
      expand
    });
    this.mindMap.render();
  }
  //  展开所有
  expandAllNode() {
    if (!this.renderTree) return;
    walk(
      this.renderTree,
      null,
      (node) => {
        if (!node.data.expand) {
          node.data.expand = true;
        }
      },
      null,
      true,
      0,
      0
    );
    this.mindMap.render();
  }
  //  收起所有
  unexpandAllNode(isSetRootNodeCenter = true) {
    if (!this.renderTree) return;
    walk(
      this.renderTree,
      null,
      (node, parent, isRoot) => {
        if (!isRoot && node.children && node.children.length > 0) {
          node.data.expand = false;
        }
      },
      null,
      true,
      0,
      0
    );
    this.mindMap.render(() => {
      if (isSetRootNodeCenter) {
        this.setRootNodeCenter();
      }
    });
  }
  //  展开到指定层级
  expandToLevel(level) {
    if (!this.renderTree) return;
    walk(
      this.renderTree,
      null,
      (node, parent, isRoot, layerIndex) => {
        const expand = layerIndex < level;
        if (expand) {
          node.data.expand = true;
        } else if (!isRoot && node.children && node.children.length > 0) {
          node.data.expand = false;
        }
      },
      null,
      true,
      0,
      0
    );
    this.mindMap.render();
  }
  //  切换激活节点的展开状态
  toggleActiveExpand() {
    this.activeNodeList.forEach((node) => {
      if (node.nodeData.children.length <= 0 || node.isRoot) {
        return;
      }
      this.toggleNodeExpand(node);
    });
  }
  //  切换节点展开状态
  toggleNodeExpand(node) {
    this.mindMap.execCommand("SET_NODE_EXPAND", node, !node.getData("expand"));
  }
  //  设置节点文本
  setNodeText(node, text, richText, resetRichText) {
    richText = richText === void 0 ? node.getData("richText") : richText;
    this.setNodeDataRender(node, {
      text,
      richText,
      resetRichText
    });
  }
  //  设置节点图片
  setNodeImage(node, data) {
    const {
      url,
      title,
      width,
      height,
      custom = false
    } = data || { url: "", title: "", width: 0, height: 0, custom: false };
    this.setNodeDataRender(node, {
      image: url,
      imageTitle: title || "",
      imageSize: {
        width,
        height,
        custom
      }
    });
  }
  //  设置节点图标
  setNodeIcon(node, icons) {
    this.setNodeDataRender(node, {
      icon: icons
    });
  }
  //  设置节点超链接
  setNodeHyperlink(node, link, title = "") {
    this.setNodeDataRender(node, {
      hyperlink: link,
      hyperlinkTitle: title
    });
  }
  //  设置节点备注
  setNodeNote(node, note2) {
    this.setNodeDataRender(node, {
      note: note2
    });
  }
  //  设置节点附件
  setNodeAttachment(node, url, name = "") {
    this.setNodeDataRender(node, {
      attachmentUrl: url,
      attachmentName: name
    });
  }
  //  设置节点标签
  setNodeTag(node, tag) {
    this.setNodeDataRender(node, {
      tag
    });
  }
  // 设置节点公式
  insertFormula(formula, appointNodes = []) {
    if (!this.mindMap.richText || !this.mindMap.formula) return;
    appointNodes = formatDataToArray(appointNodes);
    const list = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    list.forEach((node) => {
      this.mindMap.formula.insertFormulaToNode(node, formula);
    });
  }
  //  添加节点概要
  addGeneralization(data, openEdit = true) {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    const nodeList = this.activeNodeList.filter((node) => {
      return !node.isRoot && !node.isGeneralization && !node.checkHasSelfGeneralization();
    });
    const list = parseAddGeneralizationNodeList(nodeList);
    if (list.length <= 0) return;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode, inserting } = this.getNewNodeBehavior(
      openEdit,
      list.length > 1
    );
    let needRender = false;
    list.forEach((item) => {
      const newData = {
        inserting,
        ...data || {
          text: this.mindMap.opt.defaultGeneralizationText
        },
        range: item.range || null,
        uid: createUid(),
        richText: isRichText,
        resetRichText: isRichText,
        isActive: focusNewNode
      };
      let generalization = item.node.getData("generalization");
      generalization = generalization ? Array.isArray(generalization) ? generalization : [generalization] : [];
      if (item.range) {
        const isExist = !!generalization.find((item2) => {
          return item2.range && item2.range[0] === item.range[0] && item2.range[1] === item.range[1];
        });
        if (isExist) {
          return;
        }
        generalization.push(newData);
      } else {
        generalization.push(newData);
      }
      needRender = true;
      this.mindMap.execCommand("SET_NODE_DATA", item.node, {
        generalization
      });
      item.node.setData({
        expand: true
      });
    });
    if (!needRender) return;
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render(() => {
      this.mindMap.render();
    });
  }
  //  删除节点概要
  removeGeneralization() {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    this.activeNodeList.forEach((node) => {
      if (!node.checkHasGeneralization()) {
        return;
      }
      this.mindMap.execCommand("SET_NODE_DATA", node, {
        generalization: null
      });
    });
    this.mindMap.render();
    this.closeHighlightNode();
  }
  //  设置节点自定义位置
  setNodeCustomPosition(node, left = void 0, top = void 0) {
    let nodeList = [node];
    nodeList.forEach((item) => {
      this.mindMap.execCommand("SET_NODE_DATA", item, {
        customLeft: left,
        customTop: top
      });
    });
  }
  //  一键整理布局，即去除自定义位置
  resetLayout() {
    walk(
      this.root,
      null,
      (node) => {
        node.customLeft = void 0;
        node.customTop = void 0;
        this.mindMap.execCommand("SET_NODE_DATA", node, {
          customLeft: void 0,
          customTop: void 0
        });
        this.mindMap.render();
      },
      null,
      true,
      0,
      0
    );
  }
  //  设置节点形状
  setNodeShape(node, shape) {
    if (!shape || !shapeList.includes(shape)) {
      return;
    }
    let nodeList = [node];
    nodeList.forEach((item) => {
      this.setNodeStyle(item, "shape", shape);
    });
  }
  // 定位到指定节点
  goTargetNode(node, callback = () => {
  }) {
    let uid = typeof node === "string" ? node : node.getData("uid");
    if (!uid) return;
    this.expandToNodeUid(uid, () => {
      let targetNode = this.findNodeByUid(uid);
      if (targetNode) {
        targetNode.active();
        this.moveNodeToCenter(targetNode);
        callback(targetNode);
      }
    });
  }
  //  更新节点数据
  setNodeData(node, data) {
    Object.keys(data).forEach((key) => {
      node.nodeData.data[key] = data[key];
    });
  }
  //  设置节点数据，并判断是否渲染
  setNodeDataRender(node, data, notRender = false) {
    this.mindMap.execCommand("SET_NODE_DATA", node, data);
    this.reRenderNodeCheckChange(node, notRender);
  }
  // 重新节点某个节点，判断节点大小是否发生了改变，是的话触发重绘
  reRenderNodeCheckChange(node, notRender) {
    let changed = node.reRender();
    if (changed) {
      if (!notRender) this.mindMap.render();
    } else {
      this.mindMap.emit("node_tree_render_end");
    }
  }
  // 移动节点到画布中心
  // resetScale参数指定是否要将画布缩放值复位为100%，当你没有显式传递时，默认值为undefined，因为实例化选项的resetScaleOnMoveNodeToCenter配置也会决定是否复位缩放，所以当你没有显式传递时使用resetScaleOnMoveNodeToCenter配置，否则使用resetScale配置
  moveNodeToCenter(node, resetScale) {
    let { resetScaleOnMoveNodeToCenter } = this.mindMap.opt;
    if (resetScale !== void 0) {
      resetScaleOnMoveNodeToCenter = resetScale;
    }
    let { transform, state } = this.mindMap.view.getTransformData();
    let { left, top, width, height } = node;
    if (!resetScaleOnMoveNodeToCenter) {
      left *= transform.scaleX;
      top *= transform.scaleY;
      width *= transform.scaleX;
      height *= transform.scaleY;
    }
    let halfWidth = this.mindMap.width / 2;
    let halfHeight = this.mindMap.height / 2;
    let nodeCenterX = left + width / 2;
    let nodeCenterY = top + height / 2;
    let targetX = halfWidth - state.x;
    let targetY = halfHeight - state.y;
    let offsetX = targetX - nodeCenterX;
    let offsetY = targetY - nodeCenterY;
    this.mindMap.view.translateX(offsetX);
    this.mindMap.view.translateY(offsetY);
    if (resetScaleOnMoveNodeToCenter) {
      this.mindMap.view.setScale(1);
    }
  }
  // 回到中心主题，即设置根节点到画布中心
  setRootNodeCenter() {
    this.moveNodeToCenter(this.root);
  }
  // 展开到指定uid的节点
  expandToNodeUid(uid, callback = () => {
  }) {
    if (!this.renderTree) {
      callback();
      return;
    }
    let parentsList = [];
    let isGeneralization = false;
    const cache = {};
    bfsWalk(this.renderTree, (node, parent) => {
      if (node.data.uid === uid) {
        parentsList = parent ? [...cache[parent.data.uid], parent] : [];
        return "stop";
      }
      const generalizationList = formatGetNodeGeneralization(node.data);
      generalizationList.forEach((item) => {
        if (item.uid === uid) {
          parentsList = parent ? [...cache[parent.data.uid], parent, node] : [];
          isGeneralization = true;
        }
      });
      if (isGeneralization) {
        return "stop";
      }
      cache[node.data.uid] = parent ? [...cache[parent.data.uid], parent] : [];
    });
    let needRender = false;
    parentsList.forEach((node) => {
      if (!node.data.expand) {
        needRender = true;
        node.data.expand = true;
      }
    });
    if (isGeneralization) {
      const lastNode = parentsList[parentsList.length - 1];
      if (lastNode) {
        walk(lastNode, null, (node) => {
          if (!node.data.expand) {
            needRender = true;
            node.data.expand = true;
          }
        });
      }
    }
    if (needRender) {
      this.mindMap.render(callback);
    } else {
      callback();
    }
  }
  // 根据uid找到对应的节点实例
  findNodeByUid(uid) {
    let res = null;
    walk(this.root, null, (node) => {
      if (node.getData("uid") === uid) {
        res = node;
        return true;
      }
      let isGeneralization = false;
      (node._generalizationList || []).forEach((item) => {
        if (item.generalizationNode.getData("uid") === uid) {
          res = item.generalizationNode;
          isGeneralization = true;
        }
      });
      if (isGeneralization) {
        return true;
      }
    });
    return res;
  }
  // 高亮节点或子节点
  highlightNode(node, range) {
    if (this.isRendering) return;
    const { highlightNodeBoxStyle = {} } = this.mindMap.opt;
    if (!this.highlightBoxNode) {
      this.highlightBoxNode = new Polygon().stroke({
        color: highlightNodeBoxStyle.stroke || "transparent"
      }).fill({
        color: highlightNodeBoxStyle.fill || "transparent"
      });
    }
    let minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
    if (range) {
      const children = node.children.slice(range[0], range[1] + 1);
      children.forEach((child) => {
        if (child.left < minx) {
          minx = child.left;
        }
        if (child.top < miny) {
          miny = child.top;
        }
        const right = child.left + child.width;
        const bottom = child.top + child.height;
        if (right > maxx) {
          maxx = right;
        }
        if (bottom > maxy) {
          maxy = bottom;
        }
      });
    } else {
      minx = node.left;
      miny = node.top;
      maxx = node.left + node.width;
      maxy = node.top + node.height;
    }
    this.highlightBoxNode.plot([
      [minx, miny],
      [maxx, miny],
      [maxx, maxy],
      [minx, maxy]
    ]);
    this.mindMap.otherDraw.add(this.highlightBoxNode);
  }
  // 关闭高亮
  closeHighlightNode() {
    if (!this.highlightBoxNode) return;
    this.highlightBoxNode.remove();
  }
};
var Render_default = Render;

// node_modules/simple-mind-map/src/themes/freshGreen.js
var freshGreen_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "#333",
  // 背景颜色
  backgroundColor: "#d1f6ec",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "#1fb27d"
  },
  // 二级节点样式
  second: {
    fillColor: "#fff",
    color: "#565656",
    borderColor: "transparent",
    borderWidth: 0
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/blueSky.js
var blueSky_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(115, 161, 191)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(115, 161, 191)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(238, 243, 246)",
    color: "#333",
    borderColor: "rgb(115, 161, 191)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/brainImpairedPink.js
var brainImpairedPink_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(191, 115, 148)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(191, 115, 148)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(246, 238, 242)",
    color: "#333",
    borderColor: "rgb(191, 115, 148)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/romanticPurple.js
var romanticPurple_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(123, 115, 191)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(123, 115, 191)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(239, 238, 246)",
    color: "#333",
    borderColor: "rgb(123, 115, 191)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/freshRed.js
var freshRed_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(191, 115, 115)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(191, 115, 115)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(246, 238, 238)",
    color: "#333",
    borderColor: "rgb(191, 115, 115)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/earthYellow.js
var earthYellow_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(191, 147, 115)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(191, 147, 115)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(246, 242, 238)",
    color: "#333",
    borderColor: "rgb(191, 147, 115)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/classic.js
var classic_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "#fff",
  // 连线的粗细
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 背景颜色
  backgroundColor: "rgb(58, 65, 68)",
  // 背景图片
  backgroundImage: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQzg5QTQ0NDhENzgxMUUzOENGREE4QTg0RDgzRTZDNyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQzg5QTQ0NThENzgxMUUzOENGREE4QTg0RDgzRTZDNyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMwOEQ1NDRGOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMwOEQ1NDUwOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+e9P33AAAACVJREFUeNpisXJ0YUACTAyoAMr/+eM7EGGRZ4FQ7BycEAZAgAEAHbEGtkoQm/wAAAAASUVORK5CYII=",
  // 背景重复
  backgroundRepeat: "repeat",
  backgroundSize: "auto",
  // 根节点样式
  root: {
    fillColor: "rgb(233, 223, 152)",
    color: "#333",
    fontSize: 24,
    borderRadius: 21
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(164, 197, 192)",
    borderColor: "transparent",
    color: "#333",
    fontSize: 16,
    borderRadius: 10
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#fff",
    fontWeight: "bold"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "transparent",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/classic2.js
var classic2_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(51, 51, 51)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(51, 51, 51)",
  // 背景颜色
  backgroundColor: "#fff",
  // 根节点样式
  root: {
    fillColor: "rgb(18, 187, 55)",
    color: "#fff",
    fontSize: 24,
    borderRadius: 10
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(241, 242, 241)",
    borderColor: "transparent",
    color: "#1a1a1a",
    fontSize: 18,
    borderRadius: 10
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#1a1a1a"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "rgb(51, 51, 51)",
    borderWidth: 2,
    color: "#1a1a1a"
  }
});

// node_modules/simple-mind-map/src/themes/classic3.js
var classic3_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(94, 202, 110)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#1a1a1a",
  // 背景颜色
  backgroundColor: "rgb(241, 241, 241)",
  // 根节点样式
  root: {
    fillColor: "rgb(255, 245, 214)",
    color: "#1a1a1a",
    fontSize: 24,
    borderRadius: 10,
    borderColor: "rgb(249, 199, 84)",
    borderWidth: 1
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(255, 245, 214)",
    borderColor: "rgb(249, 199, 84)",
    borderWidth: 1,
    color: "#1a1a1a",
    fontSize: 18,
    borderRadius: 10
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#1a1a1a"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#1a1a1a",
    color: "#1a1a1a",
    borderWidth: 2
  }
});

// node_modules/simple-mind-map/src/themes/classic4.js
var classic4_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(30, 53, 86)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 2,
  // 概要连线的颜色
  generalizationLineColor: "rgb(56, 123, 233)",
  // 背景颜色
  backgroundColor: "rgb(241, 241, 241)",
  // 根节点样式
  root: {
    fillColor: "rgb(30, 53, 86)",
    color: "#fff",
    fontSize: 24,
    borderRadius: 10,
    borderColor: "rgb(189, 197, 201)",
    borderWidth: 2
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(169, 218, 218)",
    borderColor: "rgb(30, 53, 86)",
    borderWidth: 2,
    color: "#fff",
    fontSize: 18,
    borderRadius: 10
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(30, 53, 86)",
    borderColor: "rgb(30, 53, 86)",
    borderWidth: 1,
    marginY: 20
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(56, 123, 233)",
    borderColor: "rgb(56, 123, 233)",
    color: "#fff",
    borderWidth: 0
  }
});

// node_modules/simple-mind-map/src/themes/dark.js
var dark_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(17, 68, 23)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 2,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 背景颜色
  backgroundColor: "rgb(15, 16, 17)",
  // 根节点样式
  root: {
    fillColor: "rgb(28, 178, 43)",
    color: "#fff",
    fontSize: 24,
    borderRadius: 10
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(55, 56, 58)",
    color: "rgb(147,148,149)",
    fontSize: 18,
    borderRadius: 10,
    borderWidth: 0
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(147, 148, 149)"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "transparent",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/classicGreen.js
var classicGreen_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(123, 199, 120)",
  // 背景颜色
  backgroundColor: "rgb(236, 245, 231)",
  // 概要连线的粗细
  generalizationLineWidth: 2,
  // 概要连线的颜色
  generalizationLineColor: "rgb(123, 199, 120)",
  // 根节点样式
  root: {
    fillColor: "rgb(253, 244, 217)",
    color: "#222"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(253, 244, 217)",
    color: "#222",
    borderColor: "rgb(242, 200, 104)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(123, 199, 120)",
    borderColor: "transparent",
    borderWidth: 2,
    color: "#fff"
  }
});

// node_modules/simple-mind-map/src/themes/classicBlue.js
var classicBlue_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(51, 51, 51)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 2,
  // 概要连线的颜色
  generalizationLineColor: "rgb(51, 51, 51)",
  // 背景颜色
  backgroundColor: "rgb(239, 248, 250)",
  // 根节点样式
  root: {
    fillColor: "rgb(255, 255, 255)",
    color: "#222"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(255, 255, 255)",
    color: "#222",
    borderColor: "rgb(255, 255, 255)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "rgb(51, 51, 51)",
    color: "#333"
  }
});

// node_modules/simple-mind-map/src/themes/minions.js
var minions_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(51, 51, 51)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#222",
  // 背景颜色
  backgroundColor: "rgb(248, 215, 49)",
  // 根节点样式
  root: {
    fillColor: "rgb(55, 165, 255)",
    borderColor: "rgb(51, 51, 51)",
    borderWidth: 3
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(255, 160, 36)",
    color: "#222",
    borderColor: "rgb(51, 51, 51)",
    borderWidth: 3,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    borderColor: "#222",
    borderWidth: 3,
    color: "#222"
  }
});

// node_modules/simple-mind-map/src/themes/pinkGrape.js
var pinkGrape_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(166, 101, 106)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 背景颜色
  backgroundColor: "rgb(255, 208, 211)",
  // 根节点样式
  root: {
    fillColor: "rgb(139, 109, 225)",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(243, 104, 138)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "transparent",
    color: "#222"
  }
});

// node_modules/simple-mind-map/src/themes/mint.js
var mint_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(104, 204, 202)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(90, 206, 241)",
  // 背景颜色
  backgroundColor: "rgb(239, 255, 255)",
  // 根节点样式
  root: {
    fillColor: "rgb(0, 192, 184)",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "#fff",
    color: "#222",
    borderColor: "rgb(184, 235, 233)",
    borderWidth: 2,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(90, 206, 241)",
    borderColor: "transparent",
    color: "#fff"
  }
});

// node_modules/simple-mind-map/src/themes/gold.js
var gold_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(51, 56, 62)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(127, 93, 64)",
  // 背景颜色
  backgroundColor: "#fff",
  // 根节点样式
  root: {
    fillColor: "rgb(51, 56, 62)",
    color: "rgb(247, 208, 160)",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(239, 209, 176)",
    color: "rgb(81, 58, 42)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(127, 93, 64)",
    borderColor: "transparent",
    color: "rgb(255, 214, 175)"
  }
});

// node_modules/simple-mind-map/src/themes/vitalityOrange.js
var vitalityOrange_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(254, 146, 0)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(255, 222, 69)",
  // 背景颜色
  backgroundColor: "rgb(255, 246, 243)",
  // 根节点样式
  root: {
    fillColor: "rgb(255, 112, 52)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "#fff",
    color: "rgb(51, 51, 51)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(255, 222, 69)",
    borderColor: "transparent",
    color: "rgb(51, 51, 51)"
  }
});

// node_modules/simple-mind-map/src/themes/greenLeaf.js
var greenLeaf_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(40, 193, 84)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(251, 158, 0)",
  // 背景颜色
  backgroundColor: "rgb(238, 255, 243)",
  // 根节点样式
  root: {
    fillColor: "rgb(25, 193, 73)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "#fff",
    color: "rgb(69, 149, 96)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "rgb(251, 158, 0)",
    borderWidth: 2,
    color: "rgb(51, 51, 51)"
  }
});

// node_modules/simple-mind-map/src/themes/dark2.js
var dark2_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(75, 81, 78)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(255, 119, 34)",
  // 背景颜色
  backgroundColor: "rgb(27, 31, 34)",
  // 根节点样式
  root: {
    fillColor: "rgb(36, 179, 96)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(254, 199, 13)",
    color: "rgb(0, 0, 0)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "rgb(204, 204, 204)"
  },
  // 概要节点样式
  generalization: {
    fillColor: "transparent",
    borderColor: "rgb(255, 119, 34)",
    borderWidth: 2,
    color: "rgb(204, 204, 204)"
  }
});

// node_modules/simple-mind-map/src/themes/skyGreen.js
var skyGreen_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "#fff",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 背景颜色
  backgroundColor: "rgb(80, 156, 170)",
  // 根节点样式
  root: {
    fillColor: "#fff",
    borderColor: "",
    borderWidth: 0,
    color: "rgb(65, 89, 158)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(251, 227, 188)",
    color: "rgb(65, 89, 158)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "rgb(65, 89, 158)"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "transparent",
    color: "rgb(65, 89, 158)"
  }
});

// node_modules/simple-mind-map/src/themes/simpleBlack.js
var simpleBlack_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(34, 34, 34)",
  lineWidth: 4,
  // 概要连线的粗细
  generalizationLineWidth: 4,
  // 概要连线的颜色
  generalizationLineColor: "rgb(34, 34, 34)",
  // 根节点样式
  root: {
    fillColor: "#fff",
    color: "rgb(34, 34, 34)",
    borderColor: "rgb(34, 34, 34)",
    borderWidth: 3,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(241, 246, 248)",
    color: "rgb(34, 34, 34)",
    borderColor: "rgb(34, 34, 34)",
    borderWidth: 3,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(34, 34, 34)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "transparent",
    borderColor: "rgb(34, 34, 34)",
    borderWidth: 2,
    color: "rgb(34, 34, 34)"
  }
});

// node_modules/simple-mind-map/src/themes/courseGreen.js
var courseGreen_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(113, 195, 169)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(113, 195, 169)",
  // 根节点样式
  root: {
    fillColor: "rgb(16, 160, 121)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(240, 252, 249)",
    color: "rgb(50, 113, 96)",
    borderColor: "rgb(113, 195, 169)",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(10, 59, 43)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(246, 238, 211)",
    borderColor: "",
    borderWidth: 0,
    color: "rgb(173, 91, 12)"
  }
});

// node_modules/simple-mind-map/src/themes/coffee.js
var coffee_default = es_default(default_default, {
  // 连线的颜色
  lineColor: "rgb(173, 123, 91)",
  lineWidth: 4,
  // 概要连线的粗细
  generalizationLineWidth: 4,
  // 概要连线的颜色
  generalizationLineColor: "rgb(173, 123, 91)",
  // 根节点样式
  root: {
    fillColor: "rgb(202, 117, 79)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(245, 231, 216)",
    color: "rgb(125, 86, 42)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(96, 71, 47)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(255, 249, 239)",
    borderColor: "rgb(173, 123, 91)",
    borderWidth: 2,
    color: "rgb(122, 83, 44)"
  }
});

// node_modules/simple-mind-map/src/themes/redSpirit.js
var redSpirit_default = es_default(default_default, {
  // 背景颜色
  backgroundColor: "rgb(255, 238, 228)",
  // 连线的颜色
  lineColor: "rgb(230, 138, 131)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(222, 101, 85)",
  // 根节点样式
  root: {
    fillColor: "rgb(207, 44, 44)",
    color: "rgb(255, 233, 157)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(255, 255, 255)",
    color: "rgb(211, 58, 21)",
    borderColor: "rgb(222, 101, 85)",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(144, 71, 43)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(255, 247, 211)",
    borderColor: "rgb(255, 202, 162)",
    borderWidth: 2,
    color: "rgb(187, 101, 69)"
  }
});

// node_modules/simple-mind-map/src/themes/blackHumour.js
var blackHumour_default = es_default(default_default, {
  // 背景颜色
  backgroundColor: "rgb(27, 31, 34)",
  // 连线的颜色
  lineColor: "rgb(75, 81, 78)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(255, 119, 34)",
  // 根节点样式
  root: {
    fillColor: "rgb(36, 179, 96)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(254, 199, 13)",
    color: "rgb(0, 0, 0)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(204, 204, 204)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(27, 31, 34)",
    borderColor: "rgb(255, 119, 34)",
    borderWidth: 2,
    color: "rgb(204, 204, 204)"
  }
});

// node_modules/simple-mind-map/src/themes/lateNightOffice.js
var lateNightOffice_default = es_default(default_default, {
  // 背景颜色
  backgroundColor: "rgb(32, 37, 49)",
  // 连线的颜色
  lineColor: "rgb(137, 167, 196)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(255, 119, 34)",
  // 根节点样式
  root: {
    fillColor: "rgb(23, 153, 243)",
    color: "rgb(255, 255, 255)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(70, 78, 94)",
    color: "rgb(209, 210, 210)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(204, 204, 204)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(255, 119, 34)",
    borderColor: "",
    borderWidth: 2,
    color: "#fff"
  }
});

// node_modules/simple-mind-map/src/themes/blackGold.js
var blackGold_default = es_default(default_default, {
  // 背景颜色
  backgroundColor: "rgb(18, 20, 20)",
  // 连线的颜色
  lineColor: "rgb(205, 186, 156)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(245, 224, 191)",
  // 根节点样式
  root: {
    fillColor: "rgb(255, 208, 124)",
    color: "rgb(111, 61, 6)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(66, 57, 46)",
    color: "rgb(225, 201, 158)",
    borderColor: "rgb(245, 224, 191)",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(231, 203, 155)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(56, 45, 34)",
    borderColor: "rgb(104, 84, 61)",
    borderWidth: 2,
    color: "rgb(242, 216, 176)"
  }
});

// node_modules/simple-mind-map/src/themes/avocado.js
var avocado_default = es_default(default_default, {
  // 背景颜色
  backgroundColor: "#e6f1de",
  // 连线的颜色
  lineColor: "#f5ffad",
  lineWidth: 4,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#749336",
  // 根节点样式
  root: {
    fillColor: "#94c143",
    color: "#fff",
    borderColor: "#94c143",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "#cee498",
    color: "#749336",
    borderColor: "#aec668",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#749336"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "#cee498",
    borderColor: "#aec668",
    borderWidth: 2,
    color: "#749336"
  }
});

// node_modules/simple-mind-map/src/themes/autumn.js
var autumn_default = es_default(default_default, {
  // 背景颜色
  backgroundColor: "#fff2df",
  // 连线的颜色
  lineColor: "#b0bc47",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#b0bc47",
  // 根节点样式
  root: {
    fillColor: "#e68112",
    color: "#fff",
    borderColor: "#e68112",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "#ffd683",
    color: "#8c5416",
    borderColor: "#b0bc47",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#8c5416"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "#ffd683",
    borderColor: "#b0bc47",
    borderWidth: 2,
    color: "#8c5416"
  }
});

// node_modules/simple-mind-map/src/themes/orangeJuice.js
var orangeJuice_default = es_default(default_default, {
  // 背景颜色
  backgroundColor: "#070616",
  // 连线的颜色
  lineColor: "#fff",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 根节点样式
  root: {
    fillColor: "#ff6811",
    color: "#110501",
    borderColor: "#ff6811",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "#070616",
    color: "#a9a4a9",
    borderColor: "#ff6811",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#a9a4a9"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "",
    borderColor: "#ff6811",
    borderWidth: 2,
    color: "#a9a4a9"
  }
});

// node_modules/simple-mind-map/src/themes/index.js
var themes_default = {
  default: default_default,
  freshGreen: freshGreen_default,
  blueSky: blueSky_default,
  brainImpairedPink: brainImpairedPink_default,
  romanticPurple: romanticPurple_default,
  freshRed: freshRed_default,
  earthYellow: earthYellow_default,
  classic: classic_default,
  classic2: classic2_default,
  classic3: classic3_default,
  classic4: classic4_default,
  dark: dark_default,
  classicGreen: classicGreen_default,
  classicBlue: classicBlue_default,
  minions: minions_default,
  pinkGrape: pinkGrape_default,
  mint: mint_default,
  gold: gold_default,
  vitalityOrange: vitalityOrange_default,
  greenLeaf: greenLeaf_default,
  dark2: dark2_default,
  skyGreen: skyGreen_default,
  simpleBlack: simpleBlack_default,
  courseGreen: courseGreen_default,
  coffee: coffee_default,
  redSpirit: redSpirit_default,
  blackHumour: blackHumour_default,
  lateNightOffice: lateNightOffice_default,
  blackGold: blackGold_default,
  avocado: avocado_default,
  autumn: autumn_default,
  orangeJuice: orangeJuice_default
};

// node_modules/simple-mind-map/src/core/command/keyMap.js
var map = {
  Backspace: 8,
  Tab: 9,
  Enter: 13,
  Shift: 16,
  Control: 17,
  Alt: 18,
  CapsLock: 20,
  Esc: 27,
  Spacebar: 32,
  PageUp: 33,
  PageDown: 34,
  End: 35,
  Home: 36,
  Insert: 45,
  Left: 37,
  Up: 38,
  Right: 39,
  Down: 40,
  Del: 46,
  NumLock: 144,
  Cmd: 91,
  CmdFF: 224,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  "`": 192,
  "=": 187,
  "-": 189,
  "/": 191,
  ".": 190
};
for (let i = 0; i <= 9; i++) {
  map[i] = i + 48;
}
"abcdefghijklmnopqrstuvwxyz".split("").forEach((n, index) => {
  map[n] = index + 65;
});
var keyMap = map;

// node_modules/simple-mind-map/src/core/command/KeyCommand.js
var KeyCommand = class {
  //  构造函数
  constructor(opt) {
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.shortcutMap = {
      //Enter: [fn]
    };
    this.shortcutMapCache = {};
    this.isPause = false;
    this.isInSvg = false;
    this.bindEvent();
  }
  //  暂停快捷键响应
  pause() {
    this.isPause = true;
  }
  //  恢复快捷键响应
  recovery() {
    this.isPause = false;
  }
  //  保存当前注册的快捷键数据，然后清空快捷键数据
  save() {
    this.shortcutMapCache = this.shortcutMap;
    this.shortcutMap = {};
  }
  //  恢复保存的快捷键数据，然后清空缓存数据
  restore() {
    this.shortcutMap = this.shortcutMapCache;
    this.shortcutMapCache = {};
  }
  //  绑定事件
  bindEvent() {
    this.onKeydown = this.onKeydown.bind(this);
    this.mindMap.on("svg_mouseenter", () => {
      this.isInSvg = true;
    });
    this.mindMap.on("svg_mouseleave", () => {
      if (this.mindMap.renderer.textEdit.isShowTextEdit()) return;
      if (this.mindMap.associativeLine && this.mindMap.associativeLine.showTextEdit) {
        return;
      }
      this.isInSvg = false;
    });
    window.addEventListener("keydown", this.onKeydown);
    this.mindMap.on("beforeDestroy", () => {
      this.unBindEvent();
    });
  }
  // 解绑事件
  unBindEvent() {
    window.removeEventListener("keydown", this.onKeydown);
  }
  // 按键事件
  onKeydown(e) {
    const { enableShortcutOnlyWhenMouseInSvg, beforeShortcutRun } = this.mindMap.opt;
    if (this.isPause || enableShortcutOnlyWhenMouseInSvg && !this.isInSvg) {
      return;
    }
    Object.keys(this.shortcutMap).forEach((key) => {
      if (this.checkKey(e, key)) {
        if (!this.checkKey(e, "Control+v")) {
          e.stopPropagation();
          e.preventDefault();
        }
        if (typeof beforeShortcutRun === "function") {
          const isStop = beforeShortcutRun(key, [...this.mindMap.renderer.activeNodeList]);
          if (isStop) return;
        }
        this.shortcutMap[key].forEach((fn) => {
          fn();
        });
      }
    });
  }
  //  检查键值是否符合
  checkKey(e, key) {
    let o = this.getOriginEventCodeArr(e);
    let k = this.getKeyCodeArr(key);
    if (o.length !== k.length) {
      return false;
    }
    for (let i = 0; i < o.length; i++) {
      let index = k.findIndex((item) => {
        return item === o[i];
      });
      if (index === -1) {
        return false;
      } else {
        k.splice(index, 1);
      }
    }
    return true;
  }
  //  获取事件对象里的键值数组
  getOriginEventCodeArr(e) {
    let arr = [];
    if (e.ctrlKey || e.metaKey) {
      arr.push(keyMap["Control"]);
    }
    if (e.altKey) {
      arr.push(keyMap["Alt"]);
    }
    if (e.shiftKey) {
      arr.push(keyMap["Shift"]);
    }
    if (!arr.includes(e.keyCode)) {
      arr.push(e.keyCode);
    }
    return arr;
  }
  // 判断是否按下了组合键
  hasCombinationKey(e) {
    return e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;
  }
  //  获取快捷键对应的键值数组
  getKeyCodeArr(key) {
    let keyArr = key.split(/\s*\+\s*/);
    let arr = [];
    keyArr.forEach((item) => {
      arr.push(keyMap[item]);
    });
    return arr;
  }
  //  添加快捷键命令
  /**
   * Enter
   * Tab | Insert
   * Shift + a
   */
  addShortcut(key, fn) {
    key.split(/\s*\|\s*/).forEach((item) => {
      if (this.shortcutMap[item]) {
        this.shortcutMap[item].push(fn);
      } else {
        this.shortcutMap[item] = [fn];
      }
    });
  }
  //  移除快捷键命令
  removeShortcut(key, fn) {
    key.split(/\s*\|\s*/).forEach((item) => {
      if (this.shortcutMap[item]) {
        if (fn) {
          let index = this.shortcutMap[item].findIndex((f) => {
            return f === fn;
          });
          if (index !== -1) {
            this.shortcutMap[item].splice(index, 1);
          }
        } else {
          this.shortcutMap[item] = [];
          delete this.shortcutMap[item];
        }
      }
    });
  }
  //  获取指定快捷键的处理函数
  getShortcutFn(key) {
    let res = [];
    key.split(/\s*\|\s*/).forEach((item) => {
      res = this.shortcutMap[item] || [];
    });
    return res;
  }
};

// node_modules/simple-mind-map/src/core/command/Command.js
var Command = class {
  //  构造函数
  constructor(opt = {}) {
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.commands = {};
    this.history = [];
    this.activeHistoryIndex = 0;
    this.registerShortcutKeys();
    this.addHistory = throttle(
      this.addHistory,
      this.mindMap.opt.addHistoryTime,
      this
    );
    this.isPause = false;
  }
  // 暂停收集历史数据
  pause() {
    this.isPause = true;
  }
  // 恢复收集历史数据
  recovery() {
    this.isPause = false;
  }
  //  清空历史数据
  clearHistory() {
    this.history = [];
    this.activeHistoryIndex = 0;
    this.mindMap.emit("back_forward", 0, 0);
  }
  //  注册快捷键
  registerShortcutKeys() {
    this.mindMap.keyCommand.addShortcut("Control+z", () => {
      this.mindMap.execCommand("BACK");
    });
    this.mindMap.keyCommand.addShortcut("Control+y", () => {
      this.mindMap.execCommand("FORWARD");
    });
  }
  //  执行命令
  exec(name, ...args) {
    if (this.commands[name]) {
      this.commands[name].forEach((fn) => {
        fn(...args);
      });
      if (["BACK", "FORWARD", "SET_NODE_ACTIVE", "CLEAR_ACTIVE_NODE"].includes(
        name
      )) {
        return;
      }
      this.addHistory();
    }
  }
  //  添加命令
  add(name, fn) {
    if (this.commands[name]) {
      this.commands[name].push(fn);
    } else {
      this.commands[name] = [fn];
    }
  }
  //  移除命令
  remove(name, fn) {
    if (!this.commands[name]) {
      return;
    }
    if (!fn) {
      this.commands[name] = [];
      delete this.commands[name];
    } else {
      let index = this.commands[name].find((item) => {
        return item === fn;
      });
      if (index !== -1) {
        this.commands[name].splice(index, 1);
      }
    }
  }
  //  添加回退数据
  addHistory() {
    if (this.mindMap.opt.readonly || this.isPause) {
      return;
    }
    const lastData = this.history.length > 0 ? this.history[this.activeHistoryIndex] : null;
    const data = this.getCopyData();
    if (lastData === data) return;
    if (lastData && JSON.stringify(lastData) === JSON.stringify(data)) {
      return;
    }
    this.emitDataUpdatesEvent(lastData, data);
    this.history = this.history.slice(0, this.activeHistoryIndex + 1);
    this.history.push(simpleDeepClone(data));
    if (this.history.length > this.mindMap.opt.maxHistoryCount) {
      this.history.shift();
    }
    this.activeHistoryIndex = this.history.length - 1;
    this.mindMap.emit("data_change", data);
    this.mindMap.emit(
      "back_forward",
      this.activeHistoryIndex,
      this.history.length
    );
  }
  //  回退
  back(step = 1) {
    if (this.mindMap.opt.readonly) {
      return;
    }
    if (this.activeHistoryIndex - step >= 0) {
      const lastData = this.history[this.activeHistoryIndex];
      this.activeHistoryIndex -= step;
      this.mindMap.emit(
        "back_forward",
        this.activeHistoryIndex,
        this.history.length
      );
      const data = simpleDeepClone(this.history[this.activeHistoryIndex]);
      this.emitDataUpdatesEvent(lastData, data);
      this.mindMap.emit("data_change", data);
      return data;
    }
  }
  //  前进
  forward(step = 1) {
    if (this.mindMap.opt.readonly) {
      return;
    }
    let len = this.history.length;
    if (this.activeHistoryIndex + step <= len - 1) {
      const lastData = this.history[this.activeHistoryIndex];
      this.activeHistoryIndex += step;
      this.mindMap.emit(
        "back_forward",
        this.activeHistoryIndex,
        this.history.length
      );
      const data = simpleDeepClone(this.history[this.activeHistoryIndex]);
      this.emitDataUpdatesEvent(lastData, data);
      this.mindMap.emit("data_change", data);
      return data;
    }
  }
  //  获取渲染树数据副本
  getCopyData() {
    if (!this.mindMap.renderer.renderTree) return null;
    return copyRenderTree({}, this.mindMap.renderer.renderTree, true);
  }
  // 移除节点数据中的uid
  removeDataUid(data) {
    data = simpleDeepClone(data);
    let walk2 = (root) => {
      delete root.data.uid;
      if (root.children && root.children.length > 0) {
        root.children.forEach((item) => {
          walk2(item);
        });
      }
    };
    walk2(data);
    return data;
  }
  // 派发思维导图更新明细事件
  emitDataUpdatesEvent(lastData, data) {
    try {
      const eventName = "data_change_detail";
      const count = this.mindMap.event.listenerCount(eventName);
      if (count > 0 && lastData && data) {
        const lastDataObj = simpleDeepClone(transformTreeDataToObject(lastData));
        const dataObj = simpleDeepClone(transformTreeDataToObject(data));
        const res = [];
        const walkReplace = (root, obj) => {
          if (root.children && root.children.length > 0) {
            root.children.forEach((childUid, index) => {
              root.children[index] = typeof childUid === "string" ? obj[childUid] : obj[childUid.data.uid];
              walkReplace(root.children[index], obj);
            });
          }
          return root;
        };
        Object.keys(dataObj).forEach((uid) => {
          if (!lastDataObj[uid]) {
            res.push({
              action: "create",
              data: walkReplace(dataObj[uid], dataObj)
            });
          } else if (!isSameObject(lastDataObj[uid], dataObj[uid])) {
            res.push({
              action: "update",
              oldData: walkReplace(lastDataObj[uid], lastDataObj),
              data: walkReplace(dataObj[uid], dataObj)
            });
          }
        });
        Object.keys(lastDataObj).forEach((uid) => {
          if (!dataObj[uid]) {
            res.push({
              action: "delete",
              data: walkReplace(lastDataObj[uid], lastDataObj)
            });
          }
        });
        this.mindMap.emit(eventName, res);
      }
    } catch (error) {
      this.mindMap.opt.errorHandler(
        ERROR_TYPES.DATA_CHANGE_DETAIL_EVENT_ERROR,
        error
      );
    }
  }
};
var Command_default = Command;

// node_modules/simple-mind-map/src/utils/BatchExecution.js
var BatchExecution = class {
  //  构造函数
  constructor() {
    this.has = {};
    this.queue = [];
    this.nextTick = nextTick(this.flush, this);
  }
  //  添加任务
  push(name, fn) {
    if (this.has[name]) {
      this.replaceTask(name, fn);
      return;
    }
    this.has[name] = true;
    this.queue.push({
      name,
      fn
    });
    this.nextTick();
  }
  // 替换任务
  replaceTask(name, fn) {
    const index = this.queue.findIndex((item) => {
      return item.name === name;
    });
    if (index !== -1) {
      this.queue[index] = {
        name,
        fn
      };
    }
  }
  //   执行队列
  flush() {
    let fns = this.queue.slice(0);
    this.queue = [];
    fns.forEach(({ name, fn }) => {
      this.has[name] = false;
      fn();
    });
  }
};
var BatchExecution_default = BatchExecution;

// node_modules/simple-mind-map/src/constants/defaultOptions.js
var defaultOpt = {
  // 【基本】
  // 容器元素，必传，必须为DOM元素
  el: null,
  // 思维导图回显数据
  data: null,
  // 是否只读
  readonly: false,
  // 布局
  layout: CONSTANTS.LAYOUT.LOGICAL_STRUCTURE,
  // 如果结构为鱼骨图，那么可以通过该选项控制倾斜角度
  fishboneDeg: 45,
  // 主题
  theme: "default",
  // 内置主题：default（默认主题）
  // 主题配置，会和所选择的主题进行合并
  themeConfig: {},
  // 放大缩小的增量比例
  scaleRatio: 0.2,
  // 鼠标缩放是否以鼠标当前位置为中心点，否则以画布中心点
  mouseScaleCenterUseMousePosition: true,
  // 最多显示几个标签
  maxTag: 5,
  // 标签显示的位置，相对于节点文本，bottom（下方）、right（右侧）
  tagPosition: CONSTANTS.TAG_POSITION.RIGHT,
  // 展开收缩按钮尺寸
  expandBtnSize: 20,
  // 节点里图片和文字的间距
  imgTextMargin: 5,
  // 节点里各种文字信息的间距，如图标和文字的间距
  textContentMargin: 2,
  // 自定义节点备注内容显示
  customNoteContentShow: null,
  /*
          {
              show(){},
              hide(){}
          }
      */
  // 达到该宽度文本自动换行
  textAutoWrapWidth: 500,
  // 自定义鼠标滚轮事件处理
  // 可以传一个函数，回调参数为事件对象
  customHandleMousewheel: null,
  // 鼠标滚动的行为，如果customHandleMousewheel传了自定义函数，这个属性不生效
  mousewheelAction: CONSTANTS.MOUSE_WHEEL_ACTION.MOVE,
  // zoom（放大缩小）、move（上下移动）
  // 当mousewheelAction设为move时，可以通过该属性控制鼠标滚动一下视图移动的步长，单位px
  mousewheelMoveStep: 100,
  // 当mousewheelAction设为zoom时，或者按住Ctrl键时，默认向前滚动是缩小，向后滚动是放大，如果该属性设为true，那么会反过来
  mousewheelZoomActionReverse: true,
  // 默认插入的二级节点的文字
  defaultInsertSecondLevelNodeText: "二级节点",
  // 默认插入的二级以下节点的文字
  defaultInsertBelowSecondLevelNodeText: "分支主题",
  // 展开收起按钮的颜色
  expandBtnStyle: {
    color: "#808080",
    fill: "#fff",
    fontSize: 13,
    strokeColor: "#333333"
  },
  // 自定义展开收起按钮的图标
  expandBtnIcon: {
    open: "",
    // svg字符串
    close: ""
  },
  // 处理收起节点数量
  expandBtnNumHandler: (num) => {
    return num;
  },
  // 是否显示带数量的收起按钮
  isShowExpandNum: true,
  // 是否只有当鼠标在画布内才响应快捷键事件
  enableShortcutOnlyWhenMouseInSvg: true,
  // 初始根节点的位置
  initRootNodePosition: null,
  // 节点文本编辑框的z-index
  nodeTextEditZIndex: 3e3,
  // 节点备注浮层的z-index
  nodeNoteTooltipZIndex: 3e3,
  // 是否在点击了画布外的区域时结束节点文本的编辑状态
  isEndNodeTextEditOnClickOuter: true,
  // 最大历史记录数
  maxHistoryCount: 500,
  // 是否一直显示节点的展开收起按钮，默认为鼠标移上去和激活时才显示
  alwaysShowExpandBtn: false,
  // 不显示展开收起按钮，优先级比alwaysShowExpandBtn配置高
  notShowExpandBtn: false,
  // 扩展节点可插入的图标
  iconList: [
    // {
    //   name: '',// 分组名称
    //   type: '',// 分组的值
    //   list: [// 分组下的图标列表
    //     {
    //       name: '',// 图标名称
    //       icon:''// 图标，可以传svg或图片
    //     }
    //   ]
    // }
  ],
  // 节点最大缓存数量
  maxNodeCacheCount: 1e3,
  // 思维导图适应画布大小时的内边距
  fitPadding: 50,
  // 是否开启按住ctrl键多选节点功能
  enableCtrlKeyNodeSelection: true,
  // 设置为左键多选节点，右键拖动画布
  useLeftKeySelectionRightKeyDrag: false,
  // 节点即将进入编辑前的回调方法，如果该方法返回true以外的值，那么将取消编辑，函数可以返回一个值，或一个Promise，回调参数为节点实例
  beforeTextEdit: null,
  // 是否开启自定义节点内容
  isUseCustomNodeContent: false,
  // 自定义返回节点内容的方法
  customCreateNodeContent: null,
  // 指定内部一些元素（节点文本编辑元素、节点备注显示元素、关联线文本编辑元素、节点图片调整按钮元素）添加到的位置，默认添加到document.body下
  customInnerElsAppendTo: null,
  // 是否在存在一个激活节点时，当按下中文、英文、数字按键时自动进入文本编辑模式
  // 开启该特性后，需要给你的输入框绑定keydown事件，并禁止冒泡
  enableAutoEnterTextEditWhenKeydown: false,
  // 自定义对剪贴板文本的处理。当按ctrl+v粘贴时会读取用户剪贴板中的文本和图片，默认只会判断文本是否是普通文本和simple-mind-map格式的节点数据，如果你想处理其他思维导图的数据，比如processon、zhixi等，那么可以传递一个函数，接受当前剪贴板中的文本为参数，返回处理后的数据，可以返回两种类型：
  /*
      1.返回一个纯文本，那么会直接以该文本创建一个子节点
  
      2.返回一个节点对象，格式如下：
        {
          // 代表是simple-mind-map格式的数据
          simpleMindMap: true,
          // 节点数据，同simple-mind-map节点数据格式
          data: {
            data: {
              text: ''
            },
            children: []
          }
        }
    */
  // 如果你的处理逻辑存在异步逻辑，也可以返回一个promise
  customHandleClipboardText: null,
  // 禁止鼠标滚轮缩放，你仍旧可以使用api进行缩放
  disableMouseWheelZoom: false,
  // 错误处理函数
  errorHandler: (code, error) => {
    console.error(code, error);
  },
  // 是否在鼠标双击时回到根节点，也就是让根节点居中显示
  enableDblclickBackToRootNode: false,
  // 节点鼠标hover和激活时显示的矩形边框的颜色
  hoverRectColor: "rgb(94, 200, 248)",
  // 节点鼠标hover和激活时显示的矩形边框距节点内容的距离
  hoverRectPadding: 2,
  // 双击节点进入节点文本编辑时是否默认选中文本，默认只在创建新节点时会选中
  selectTextOnEnterEditText: false,
  // 删除节点后激活相邻节点
  deleteNodeActive: true,
  // 是否首次加载fit view
  fit: false,
  // 自定义标签的颜色
  // {pass: 'green, unpass: 'red'}
  tagsColorMap: {},
  // 节点协作样式配置
  cooperateStyle: {
    avatarSize: 22,
    // 头像大小
    fontSize: 12
    // 如果是文字头像，那么文字的大小
  },
  // 协同编辑时，同一个节点不能同时被多人选中
  onlyOneEnableActiveNodeOnCooperate: false,
  // 插入概要的默认文本
  defaultGeneralizationText: "概要",
  // 粘贴文本的方式创建新节点时，控制是否按换行自动分割节点，即如果存在换行，那么会根据换行创建多个节点，否则只会创建一个节点
  // 可以传递一个函数，返回promise，resolve代表根据换行分割，reject代表忽略换行
  handleIsSplitByWrapOnPasteCreateNewNode: null,
  // 多少时间内只允许添加一次历史记录，避免添加没有必要的中间状态，单位：ms
  addHistoryTime: 100,
  // 是否禁止拖动画布
  isDisableDrag: false,
  // 鼠标移入概要高亮所属节点时的高亮框样式
  highlightNodeBoxStyle: {
    stroke: "rgb(94, 200, 248)",
    fill: "transparent"
  },
  // 创建新节点时的行为
  /*
    DEFAULT  ：默认会激活新创建的节点，并且进入编辑模式。如果同时创建了多个新节点，那么只会激活而不会进入编辑模式
    NOT_ACTIVE  : 不激活新创建的节点
    ACTIVE_ONLY  : 只激活新创建的节点，不进入编辑模式
  */
  createNewNodeBehavior: CONSTANTS.CREATE_NEW_NODE_BEHAVIOR.DEFAULT,
  // 当节点图片加载失败时显示的默认图片
  defaultNodeImage: "",
  // 是否将思维导图限制在画布内
  // 比如向右拖动时，思维导图图形的最左侧到达画布中心时将无法继续向右拖动，其他同理
  isLimitMindMapInCanvas: false,
  // 在节点上粘贴剪贴板中的图片的处理方法，默认是转换为data:url数据插入到节点中，你可以通过该方法来将图片数据上传到服务器，实现保存图片的url
  // 可以传递一个异步方法，接收Blob类型的图片数据，需要返回如下结构：
  /*
    {
      url,    // 图片url
      size: {
        width,  // 图片的宽度
        height  //图片的高度
      }
    }
  */
  handleNodePasteImg: null,
  // 自定义创建节点形状的方法，可以传一个函数，均接收一个参数
  // 矩形、圆角矩形、椭圆、圆等形状会调用该方法
  // 接收svg path字符串，返回svg节点
  customCreateNodePath: null,
  // 菱形、平行四边形、八角矩形、外三角矩形、内三角矩形等形状会调用该方法
  // 接收points数组点位，返回svg节点
  customCreateNodePolygon: null,
  // 自定义转换节点连线路径的方法
  // 接收svg path字符串，返回转换后的svg path字符串
  customTransformNodeLinePath: null,
  // 快捷键操作即将执行前的生命周期函数，返回true可以阻止操作执行
  // 函数接收两个参数：key（快捷键）、activeNodeList（当前激活的节点列表）
  beforeShortcutRun: null,
  // 移动节点到画布中心、回到根节点等操作时是否将缩放层级复位为100%
  // 该选项实际影响的是render.moveNodeToCenter方法，moveNodeToCenter方法本身也存在第二个参数resetScale来设置是否复位，如果resetScale参数没有传递，那么使用resetScaleOnMoveNodeToCenter配置，否则使用resetScale配置
  resetScaleOnMoveNodeToCenter: false,
  // 添加附加的节点前置内容，前置内容指和文本同一行的区域中的前置内容，不包括节点图片部分
  createNodePrefixContent: null,
  // 添加附加的节点后置内容，后置内容指和文本同一行的区域中的后置内容，不包括节点图片部分
  createNodePostfixContent: null,
  // 禁止粘贴用户剪贴板中的数据，禁止将复制的数据写入用户的剪贴板中
  disabledClipboard: false,
  // 自定义超链接的跳转
  // 如果不传，默认会以新窗口的方式打开超链接，可以传递一个函数，函数接收两个参数：link（超链接的url）、node（所属节点实例），只要传递了函数，就会阻止默认的跳转
  customHyperlinkJump: null,
  // 是否开启性能模式，默认情况下所有节点都会直接渲染，无论是否处于画布可视区域，这样当节点数量比较多时（1000+）会比较卡，如果你的数据量比较大，那么可以通过该配置开启性能模式，即只渲染画布可视区域内的节点，超出的节点不渲染，这样会大幅提高渲染速度，当然同时也会带来一些其他问题，比如：1.当拖动或是缩放画布时会实时计算并渲染未节点的节点，所以会带来一定卡顿；2.导出图片、svg、pdf时需要先渲染全部节点，所以会比较慢；3.其他目前未发现的问题
  openPerformance: false,
  // 性能优化模式配置
  performanceConfig: {
    time: 250,
    // 当视图改变后多久刷新一次节点，单位：ms，
    padding: 100,
    // 超出画布四周指定范围内依旧渲染节点
    removeNodeWhenOutCanvas: true
    // 节点移除画布可视区域后从画布删除
  },
  // 【Select插件】
  // 多选节点时鼠标移动到边缘时的画布移动偏移量
  selectTranslateStep: 3,
  // 多选节点时鼠标移动距边缘多少距离时开始偏移
  selectTranslateLimit: 20,
  // 【Drag插件】
  // 是否开启节点自由拖拽
  enableFreeDrag: false,
  // 拖拽节点时鼠标移动到画布边缘是否开启画布自动移动
  autoMoveWhenMouseInEdgeOnDrag: true,
  // 拖拽多个节点时随鼠标移动的示意矩形的样式配置
  dragMultiNodeRectConfig: {
    width: 40,
    height: 20,
    fill: "rgb(94, 200, 248)"
    // 填充颜色
  },
  // 节点拖拽时新位置的示意矩形的填充颜色
  dragPlaceholderRectFill: "rgb(94, 200, 248)",
  // 节点拖拽时新位置的示意连线的样式配置
  dragPlaceholderLineConfig: {
    color: "rgb(94, 200, 248)",
    width: 2
  },
  // 节点拖拽时的透明度配置
  dragOpacityConfig: {
    cloneNodeOpacity: 0.5,
    // 跟随鼠标移动的克隆节点或矩形的透明度
    beingDragNodeOpacity: 0.3
    // 被拖拽节点的透明度
  },
  // 拖拽单个节点时会克隆被拖拽节点，如果想修改该克隆节点，那么可以通过该选项提供一个处理函数，函数接收克隆节点对象
  // 需要注意的是节点对象指的是@svgdotjs/svg.js库的元素对象，所以你需要阅读该库的文档来操作该对象
  handleDragCloneNode: null,
  // 即将拖拽完成前调用该函数，函数接收一个对象作为参数：{overlapNodeUid,prevNodeUid,nextNodeUid}，代表拖拽信息，如果要阻止本次拖拽，那么可以返回true，此时node_dragend事件不会再触发。函数可以是异步函数，返回Promise实例
  beforeDragEnd: null,
  // 即将开始调整节点前调用该函数，函数接收当前即将被拖拽的节点实例列表作为参数，如果要阻止本次拖拽，那么可以返回true
  beforeDragStart: null,
  // 【Watermark插件】
  // 水印配置
  watermarkConfig: {
    onlyExport: false,
    // 是否仅在导出时添加水印
    text: "",
    lineSpacing: 100,
    textSpacing: 100,
    angle: 30,
    textStyle: {
      color: "#999",
      opacity: 0.5,
      fontSize: 14
    },
    belowNode: false
  },
  // 【Export插件】
  // 导出png、svg、pdf时的图形内边距，注意是单侧内边距
  exportPaddingX: 10,
  exportPaddingY: 10,
  // 设置导出图片和svg时，针对富文本节点内容，也就是嵌入到svg中的html节点的默认样式覆盖
  // 如果不覆盖，会发生偏移问题
  resetCss: `
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
  `,
  // 导出图片时canvas的缩放倍数，该配置会和window.devicePixelRatio值取最大值
  minExportImgCanvasScale: 2,
  // 导出png、svg、pdf时在头部和尾部添加自定义内容
  // 可传递一个函数，这个函数可以返回null代表不添加内容，也可以返回如下数据：
  /*
    {
      el,// 要追加的自定义DOM节点，样式可内联
      cssText,// 可选，如果样式不想内联，可以传递该值，一个css字符串
      height: 50// 返回的DOM节点的高度，必须传递
    }
  */
  addContentToHeader: null,
  addContentToFooter: null,
  // 导出png、svg、pdf时会获取画布上的svg数据进行克隆，然后通过该克隆的元素进行导出，如果你想对该克隆元素做一些处理，比如新增、替换、修改其中的一些元素，那么可以通过该参数传递一个处理函数，接收svg元素对象，处理后，需要返回原svg元素对象。
  // 需要注意的是svg对象指的是@svgdotjs/svg.js库的元素对象，所以你需要阅读该库的文档来操作该对象
  handleBeingExportSvg: null,
  // 【AssociativeLine插件】
  // 关联线默认文字
  defaultAssociativeLineText: "关联",
  // 关联线是否始终显示在节点上层
  // false：即创建关联线和激活关联线时处于最顶层，其他情况下处于节点下方
  associativeLineIsAlwaysAboveNode: true,
  // 默认情况下，新创建的关联线两个端点的位置是根据两个节点中心点的相对位置来计算的，如果你想固定位置，可以通过这个属性来配置
  // from和to都不传，则都自动计算，如果只传一个，另一个则会自动计算
  associativeLineInitPointsPosition: {
    // from和to可选值：left、top、bottom、right
    from: "",
    // 关联线起始节点上端点的位置
    to: ""
    // 关联线目标节点上端点的位置
  },
  // 是否允许调整关联线两个端点的位置
  enableAdjustAssociativeLinePoints: true,
  // 【TouchEvent插件】
  // 禁止双指缩放，你仍旧可以使用api进行缩放
  // 需要注册TouchEvent插件后生效
  disableTouchZoom: false,
  // 允许最大和最小的缩放值，百分数
  // 传-1代表不限制
  minTouchZoomScale: 20,
  maxTouchZoomScale: -1,
  // 【Scrollbar插件】
  // 当注册了滚动条插件（Scrollbar）时，是否将思维导图限制在画布内，isLimitMindMapInCanvas不再起作用
  isLimitMindMapInCanvasWhenHasScrollbar: true,
  // 【Search插件】
  // 是否仅搜索当前渲染的节点，被收起的节点不会被搜索到
  isOnlySearchCurrentRenderNodes: false,
  // 【Cooperate插件】
  // 协同编辑时，节点操作即将更新到其他客户端前的生命周期函数
  // 函数接收一个对象作为参数：
  /*
    {
      type: createOrUpdate（创建节点或更新节点）、delete（删除节点）
      data: 1.当type=createOrUpdate时，代表被创建或被更新的节点数据，即将同步到其他客户端，所以你可以修改该数据；2.当type=delete时，代表被删除的节点数据
    }
  */
  beforeCooperateUpdate: null,
  // 【RainbowLines插件】
  // 彩虹线条配置，需要先注册RainbowLines插件
  rainbowLinesConfig: {
    open: false,
    // 是否开启彩虹线条
    colorsList: []
    // 自定义彩虹线条的颜色列表，如果不设置，会使用默认颜色列表
    /*
    [
      'rgb(255, 213, 73)',
      'rgb(255, 136, 126)',
      'rgb(107, 225, 141)',
      'rgb(151, 171, 255)',
      'rgb(129, 220, 242)',
      'rgb(255, 163, 125)',
      'rgb(152, 132, 234)'
    ]
    */
  },
  // 【Demonstrate插件】
  // 演示插件配置
  demonstrateConfig: null,
  // 【Formula插件】
  // 是否开启在富文本编辑框中直接编辑数学公式
  enableEditFormulaInRichTextEdit: true,
  // katex库的字体文件的请求路径。仅当katex的output配置为html时才会请求字体文件。可以通过mindMap.formula.getKatexConfig()方法来获取当前的配置
  // 字体文件可以从node_modules中找到：katex/dist/fonts/。可以上传到你的服务器或cdn
  // 最终的字体请求路径为`${katexFontPath}fonts/KaTeX_AMS-Regular.woff2`，可以自行拼接进行测试是否可以访问
  katexFontPath: "https://unpkg.com/katex@0.16.11/dist/",
  // 自定义katex库的输出模式。默认当Chrome内核100以下会使用html方式，否则使用mathml方式，如果你有自己的规则，那么可以传递一个函数，函数返回值为：mathml或html
  getKatexOutputType: null,
  // 【RichText插件】
  // 转换富文本内容，当进入富文本编辑时，可以通过该参数传递一个函数，函数接收文本内容，需要返回你处理后的文本内容
  transformRichTextOnEnterEdit: null,
  // 可以传递一个函数，即将结束富文本编辑前会执行该函数，函数接收richText实例，所以你可以在此时机更新quill文档数据
  beforeHideRichTextEdit: null,
  // 设置富文本节点编辑框和节点大小一致，形成伪原地编辑的效果
  // 需要注意的是，只有当节点内只有文本、且形状是矩形才会有比较好的效果
  richTextEditFakeInPlace: false,
  // 【OuterFrame】插件
  outerFramePaddingX: 10,
  outerFramePaddingY: 10
};

// node_modules/simple-mind-map/index.js
var MindMap2 = class _MindMap {
  //  构造函数
  /**
   *
   * @param {defaultOpt} opt
   */
  constructor(opt = {}) {
    this.opt = this.handleOpt(es_default(defaultOpt, opt));
    this.opt.data = this.handleData(this.opt.data);
    this.el = this.opt.el;
    if (!this.el) throw new Error("缺少容器元素el");
    this.getElRectInfo();
    this.initWidth = this.width;
    this.initHeight = this.height;
    this.cssEl = null;
    this.addCss();
    this.initContainer();
    this.initTheme();
    this.initCache();
    this.event = new Event_default({
      mindMap: this
    });
    this.keyCommand = new KeyCommand({
      mindMap: this
    });
    this.command = new Command_default({
      mindMap: this
    });
    this.renderer = new Render_default({
      mindMap: this
    });
    this.view = new View_default({
      mindMap: this
    });
    this.batchExecution = new BatchExecution_default();
    _MindMap.pluginList.forEach((plugin) => {
      this.initPlugin(plugin);
    });
    this.render(this.opt.fit ? () => this.view.fit() : () => {
    });
    setTimeout(() => {
      if (this.opt.data) this.command.addHistory();
    }, 0);
  }
  //  配置参数处理
  handleOpt(opt) {
    if (!layoutValueList.includes(opt.layout)) {
      opt.layout = CONSTANTS.LAYOUT.LOGICAL_STRUCTURE;
    }
    opt.theme = opt.theme && themes_default[opt.theme] ? opt.theme : "default";
    return opt;
  }
  // 预处理节点数据
  handleData(data) {
    if (isUndef(data) || Object.keys(data).length <= 0) return null;
    data = simpleDeepClone(data || {});
    if (data.data && !data.data.expand) {
      data.data.expand = true;
    }
    return data;
  }
  // 创建容器元素
  initContainer() {
    const { associativeLineIsAlwaysAboveNode } = this.opt;
    this.el.classList.add("smm-mind-map-container");
    const createAssociativeLineDraw = () => {
      this.associativeLineDraw = this.draw.group();
      this.associativeLineDraw.addClass("smm-associative-line-container");
    };
    this.svg = SVG().addTo(this.el).size(this.width, this.height);
    this.draw = this.svg.group();
    this.draw.addClass("smm-container");
    this.lineDraw = this.draw.group();
    this.lineDraw.addClass("smm-line-container");
    if (!associativeLineIsAlwaysAboveNode) {
      createAssociativeLineDraw();
    }
    this.nodeDraw = this.draw.group();
    this.nodeDraw.addClass("smm-node-container");
    if (associativeLineIsAlwaysAboveNode) {
      createAssociativeLineDraw();
    }
    this.otherDraw = this.draw.group();
    this.otherDraw.addClass("smm-other-container");
  }
  // 清空各容器
  clearDraw() {
    this.lineDraw.clear();
    this.associativeLineDraw.clear();
    this.nodeDraw.clear();
    this.otherDraw.clear();
  }
  // 添加必要的css样式到页面
  addCss() {
    this.cssEl = document.createElement("style");
    this.cssEl.type = "text/css";
    this.cssEl.innerHTML = cssContent;
    document.head.appendChild(this.cssEl);
  }
  // 移除css
  removeCss() {
    document.head.removeChild(this.cssEl);
  }
  //  渲染，部分渲染
  render(callback, source = "") {
    this.batchExecution.push("render", () => {
      this.initTheme();
      this.renderer.render(callback, source);
    });
  }
  //  重新渲染
  reRender(callback, source = "") {
    this.renderer.reRender = true;
    this.renderer.clearCache();
    this.clearDraw();
    this.render(callback, source);
  }
  // 获取或更新容器尺寸位置信息
  getElRectInfo() {
    this.elRect = this.el.getBoundingClientRect();
    this.width = this.elRect.width;
    this.height = this.elRect.height;
    if (this.width <= 0 || this.height <= 0)
      throw new Error("容器元素el的宽高不能为0");
  }
  //  容器尺寸变化，调整尺寸
  resize() {
    const oldWidth = this.width;
    const oldHeight = this.height;
    this.getElRectInfo();
    this.svg.size(this.width, this.height);
    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.render();
    }
    this.emit("resize");
  }
  //  监听事件
  on(event, fn) {
    this.event.on(event, fn);
  }
  //  触发事件
  emit(event, ...args) {
    this.event.emit(event, ...args);
  }
  //  解绑事件
  off(event, fn) {
    this.event.off(event, fn);
  }
  // 初始化缓存数据
  initCache() {
    this.commonCaches = {
      measureCustomNodeContentSizeEl: null,
      measureRichtextNodeTextSizeEl: null
    };
  }
  //  设置主题
  initTheme() {
    this.themeConfig = es_default(themes_default[this.opt.theme], this.opt.themeConfig);
    Style_default.setBackgroundStyle(this.el, this.themeConfig);
  }
  //  设置主题
  setTheme(theme, notRender = false) {
    this.execCommand("CLEAR_ACTIVE_NODE");
    this.opt.theme = theme;
    if (!notRender) {
      this.render(null, CONSTANTS.CHANGE_THEME);
    }
    this.emit("view_theme_change", theme);
  }
  //  获取当前主题
  getTheme() {
    return this.opt.theme;
  }
  //  设置主题配置
  setThemeConfig(config, notRender = false) {
    const changedConfig = getObjectChangedProps(this.themeConfig, config);
    this.opt.themeConfig = config;
    if (!notRender) {
      let res = checkIsNodeSizeIndependenceConfig(changedConfig);
      this.render(null, res ? "" : CONSTANTS.CHANGE_THEME);
    }
  }
  //  获取自定义主题配置
  getCustomThemeConfig() {
    return this.opt.themeConfig;
  }
  //  获取某个主题配置值
  getThemeConfig(prop) {
    return prop === void 0 ? this.themeConfig : this.themeConfig[prop];
  }
  // 获取配置
  getConfig(prop) {
    return prop === void 0 ? this.opt : this.opt[prop];
  }
  // 更新配置
  updateConfig(opt = {}) {
    this.emit("before_update_config", this.opt);
    this.opt = this.handleOpt(es_default.all([defaultOpt, this.opt, opt]));
    this.emit("after_update_config", this.opt);
  }
  //  获取当前布局结构
  getLayout() {
    return this.opt.layout;
  }
  //  设置布局结构
  setLayout(layout, notRender = false) {
    if (!layoutValueList.includes(layout)) {
      layout = CONSTANTS.LAYOUT.LOGICAL_STRUCTURE;
    }
    this.opt.layout = layout;
    this.view.reset();
    this.renderer.setLayout();
    if (!notRender) {
      this.render(null, CONSTANTS.CHANGE_LAYOUT);
    }
    this.emit("layout_change", layout);
  }
  //  执行命令
  execCommand(...args) {
    this.command.exec(...args);
  }
  // 更新画布数据，如果新的数据是在当前画布节点数据基础上增删改查后形成的，那么可以使用该方法来更新画布数据
  updateData(data) {
    this.renderer.setData(data);
    this.render();
    this.command.addHistory();
  }
  //  动态设置思维导图数据，纯节点数据
  setData(data) {
    data = this.handleData(data);
    this.opt.data = data;
    this.execCommand("CLEAR_ACTIVE_NODE");
    this.command.clearHistory();
    this.command.addHistory();
    this.renderer.setData(data);
    this.reRender(() => {
    }, CONSTANTS.SET_DATA);
    this.emit("set_data", data);
  }
  //  动态设置思维导图数据，包括节点数据、布局、主题、视图
  setFullData(data) {
    if (data.root) {
      this.setData(data.root);
    }
    if (data.layout) {
      this.setLayout(data.layout);
    }
    if (data.theme) {
      if (data.theme.template) {
        this.setTheme(data.theme.template);
      }
      if (data.theme.config) {
        this.setThemeConfig(data.theme.config);
      }
    }
    if (data.view) {
      this.view.setTransformData(data.view);
    }
  }
  //  获取思维导图数据，节点树、主题、布局等
  getData(withConfig) {
    let nodeData = this.command.getCopyData();
    let data = {};
    if (withConfig) {
      data = {
        layout: this.getLayout(),
        root: nodeData,
        theme: {
          template: this.getTheme(),
          config: this.getCustomThemeConfig()
        },
        view: this.view.getTransformData()
      };
    } else {
      data = nodeData;
    }
    return simpleDeepClone(data);
  }
  //  导出
  async export(...args) {
    try {
      if (!this.doExport) {
        throw new Error("请注册Export插件！");
      }
      let result = await this.doExport.export(...args);
      return result;
    } catch (error) {
      this.opt.errorHandler(ERROR_TYPES.EXPORT_ERROR, error);
    }
  }
  //  转换位置
  toPos(x, y) {
    return {
      x: x - this.elRect.left,
      y: y - this.elRect.top
    };
  }
  //  设置只读模式、编辑模式
  setMode(mode) {
    if (![CONSTANTS.MODE.READONLY, CONSTANTS.MODE.EDIT].includes(mode)) {
      return;
    }
    const isReadonly = mode === CONSTANTS.MODE.READONLY;
    if (isReadonly === this.opt.readonly) return;
    this.opt.readonly = isReadonly;
    if (this.opt.readonly) {
      this.execCommand("CLEAR_ACTIVE_NODE");
    }
    this.emit("mode_change", mode);
  }
  // 获取svg数据
  getSvgData({
    paddingX = 0,
    paddingY = 0,
    ignoreWatermark = false,
    addContentToHeader,
    addContentToFooter,
    node
  } = {}) {
    const { watermarkConfig, openPerformance } = this.opt;
    if (openPerformance) {
      this.renderer.forceLoadNode(node);
    }
    const { cssTextList, header, headerHeight, footer, footerHeight } = handleGetSvgDataExtraContent({
      addContentToHeader,
      addContentToFooter
    });
    const svg = this.svg;
    const draw = this.draw;
    const origWidth = svg.width();
    const origHeight = svg.height();
    const origTransform = draw.transform();
    const elRect = this.elRect;
    draw.scale(1 / origTransform.scaleX, 1 / origTransform.scaleY);
    const rect = draw.rbox();
    let clipData = null;
    if (node) {
      clipData = getNodeTreeBoundingRect(
        node,
        rect.x,
        rect.y,
        paddingX,
        paddingY
      );
    }
    const fixHeight = 0;
    rect.width += paddingX * 2;
    rect.height += paddingY * 2 + fixHeight + headerHeight + footerHeight;
    draw.translate(paddingX, paddingY);
    svg.size(rect.width, rect.height);
    draw.translate(-rect.x + elRect.left, -rect.y + elRect.top);
    let clone = svg.clone();
    const hasWatermark = this.watermark && this.watermark.hasWatermark();
    if (!ignoreWatermark && hasWatermark) {
      this.watermark.isInExport = true;
      const { onlyExport } = watermarkConfig;
      const needReDrawWatermark = rect.width > origWidth || rect.height > origHeight;
      if (needReDrawWatermark) {
        this.width = rect.width;
        this.height = rect.height;
        this.watermark.onResize();
        clone = svg.clone();
        this.width = origWidth;
        this.height = origHeight;
        this.watermark.onResize();
      } else if (onlyExport) {
        this.watermark.onResize();
        clone = svg.clone();
      }
      if (onlyExport) {
        this.watermark.clear();
      }
      this.watermark.isInExport = false;
    }
    ;
    [cssContent, ...cssTextList].forEach((s) => {
      clone.add(SVG(`<style>${s}</style>`));
    });
    if (header && headerHeight > 0) {
      clone.findOne(".smm-container").translate(0, headerHeight);
      header.width(rect.width);
      header.y(paddingY);
      clone.add(header, 0);
    }
    if (footer && footerHeight > 0) {
      footer.width(rect.width);
      footer.y(rect.height - paddingY - footerHeight);
      clone.add(footer);
    }
    const defs = svg.find("defs");
    const defs2 = clone.find("defs");
    defs.forEach((def, defIndex) => {
      const def2 = defs2[defIndex];
      if (!def2) return;
      const children = def.children();
      const children2 = def2.children();
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        const child2 = children2[i];
        if (child && child2) {
          child2.attr("id", child.attr("id"));
        }
      }
    });
    svg.size(origWidth, origHeight);
    draw.transform(origTransform);
    return {
      svg: clone,
      // 思维导图图形的整体svg元素，包括：svg（画布容器）、g（实际的思维导图组）
      svgHTML: clone.svg(),
      // svg字符串
      clipData,
      rect: {
        ...rect,
        // 思维导图图形未缩放时的位置尺寸等信息
        ratio: rect.width / rect.height
        // 思维导图图形的宽高比
      },
      origWidth,
      // 画布宽度
      origHeight,
      // 画布高度
      scaleX: origTransform.scaleX,
      // 思维导图图形的水平缩放值
      scaleY: origTransform.scaleY
      // 思维导图图形的垂直缩放值
    };
  }
  // 添加插件
  addPlugin(plugin, opt) {
    let index = _MindMap.hasPlugin(plugin);
    if (index === -1) {
      _MindMap.usePlugin(plugin, opt);
      this.initPlugin(plugin);
    }
  }
  // 移除插件
  removePlugin(plugin) {
    let index = _MindMap.hasPlugin(plugin);
    if (index !== -1) {
      _MindMap.pluginList.splice(index, 1);
      if (this[plugin.instanceName]) {
        if (this[plugin.instanceName].beforePluginRemove) {
          this[plugin.instanceName].beforePluginRemove();
        }
        delete this[plugin.instanceName];
      }
    }
  }
  // 实例化插件
  initPlugin(plugin) {
    this[plugin.instanceName] = new plugin({
      mindMap: this,
      pluginOpt: plugin.pluginOpt
    });
  }
  // 销毁
  destroy() {
    this.emit("beforeDestroy");
    this.renderer.textEdit.hideEditTextBox();
    this.renderer.textEdit.removeTextEditEl();
    [..._MindMap.pluginList].forEach((plugin) => {
      if (this[plugin.instanceName] && this[plugin.instanceName].beforePluginDestroy) {
        this[plugin.instanceName].beforePluginDestroy();
      }
      this[plugin.instanceName] = null;
    });
    this.event.unbind();
    this.svg.remove();
    Style_default.removeBackgroundStyle(this.el);
    this.el.classList.remove("smm-mind-map-container");
    this.el.innerHTML = "";
    this.el = null;
    this.removeCss();
  }
};
MindMap2.pluginList = [];
MindMap2.usePlugin = (plugin, opt = {}) => {
  if (MindMap2.hasPlugin(plugin) !== -1) return MindMap2;
  plugin.pluginOpt = opt;
  MindMap2.pluginList.push(plugin);
  return MindMap2;
};
MindMap2.hasPlugin = (plugin) => {
  return MindMap2.pluginList.findIndex((item) => {
    return item === plugin;
  });
};
MindMap2.defineTheme = (name, config = {}) => {
  if (themes_default[name]) {
    return new Error("该主题名称已存在");
  }
  themes_default[name] = es_default(default_default, config);
};
var simple_mind_map_default = MindMap2;
export {
  simple_mind_map_default as default
};
//# sourceMappingURL=simple-mind-map.js.map
